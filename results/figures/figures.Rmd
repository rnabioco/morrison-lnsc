---
title: "CHIKV LNSC figures"
author: "Ryan Sheridan"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc:       true
    toc_float: true
    toc_depth: 2
    theme:     cosmo
    highlight: kate
params:
  
  
  src_dir:      "src"
  so_dir:       "~/Dropbox/Ryan/Projects/morrison-lnsc/results/sobjs"
  so_24:        "~/Dropbox/Ryan/Projects/morrison-scRNA-seq/results/2021-01-08/sobjs/so.rds"
  tm:           "8hpi"                    # Timepoint label
  unenr_dir:    "results/2021-04-16"      # Directory for unenriched data
  enr_dir:      "results/2021-07-16"      # Directory for CHIKV-enriched data
  gene_min:     250                       # Min number of detected genes per cell
  gene_max:     8000                      # Max number of detected genes per cell
  mito_max:     20                        # Max percentage mito reads per cells
  type_res:     10                        # Clustering resolution for annotating cell types
  lec_res:      10                        # Clustering resolution for annotating LECs
  frc_res:      3                         # Clustering resolution for annotating fibroblasts
editor_options: 
  chunk_output_type: console
---

<br>

```{r "chunk opts", include = FALSE}
# Default chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo    = FALSE,
  dpi     = 500
)

knitr::knit(here::here(params$src_dir, "setup.Rmd"), "")
```

## Figure 1

Chikungunya virus is found in MARCO-expressing floor lymphatic endothelial cells
in the draining lymph node at 8 hpi

A.  UMAP projection shows the fraction of counts aligning to the CHIKV genome for the 8 hpi timepoint.
B.  UMAP projection shows CHIKV+ cells (>0 CHIKV counts) for the 8 hpi timepoint.
C.  The percentage of CHIKV counts is shown for cell types with >40 total cells and >3 CHIKV+ cells for the 8 hpi CHIKV-infected sample.
D.  The fraction of cells identified as CHIKV+ is shown for each cell type in C. Labels show the number of CHIKV+ cells/total cells.
E.  MARCO expression is shown for fLECs for mock-infected cells and CHIKV-infected cells classified as either CHIKV low or CHIKV high. P values were calculated using a two-sided Wilcoxon rank-sum test with Bonferroni correction. In the boxplot, the central lines, the box limits, and the whiskers represent medians, the interquartile range (IQR), and min/max values that are not outliers, respectively. Outliers are shown as points and include any values that are more than 1.5Ã— IQR away from the box.
F.  Madcam1 expression is shown for fLECs as described in E.

```{r "fig 1A", fig.width = 10, fig.height = 10}
# Format plot data
dat <- so_8@meta.data %>%
  arrange(tot_pct_CHIKV)

# Create UMAP
pseudo <- dat$tot_pct_CHIKV
pseudo <- min(pseudo[pseudo > 0]) / 2

A <- dat %>%
  ggplot(aes(UMAP_1, UMAP_2, fill = tot_pct_CHIKV + pseudo)) +
  geom_point_trace(
    color = "grey",
    trace_position = "bottom"
  ) +
  scale_fill_gradientn(colours = c("white", "#D7301F"), trans = "log10", labels = scales::label_number()) +
  guides(fill = guide_colorbar(title.position = "top", ticks = FALSE, title = "% CHIKV counts")) +
  umap_theme +
  theme(
    aspect.ratio         = 0.9,
    legend.position      = "top",
    legend.title         = element_text(hjust = 0.5, size = ttl_pt2 * 1.5),
    legend.text          = element_text(angle = 45, hjust = 1), 
    legend.direction     = "horizontal",
    legend.justification = 0.2,
    legend.key.width     = unit(30, "pt"),
    legend.key.height    = unit(5, "pt")
  )
```

```{r "CHIKV-high cell types", fig.width = 10, fig.height = 10}
# Format plot data
# ONLY SHOW CELLS WITH >3 CHIKV-HIGH CELLS
chikv_pos_dat <- so_8@meta.data %>%
  filter(chikv_grp == chikv_grps[2]) %>%
  group_by(lec_type) %>%
  mutate(lec_type = ifelse(n() > 3, lec_type, "other")) %>%
  ungroup()

plt_labs <- get_nlab_fun(chikv_pos_dat, "lec_type", l = "\n", r = "")
plt_labs <- plt_labs()
plt_labs <- map_chr(plt_labs, type_lab_fn)
plt_labs <- plt_labs[c(names(plt_labs)[names(plt_labs) != "other"], "other")]

chikv_pos_dat <- chikv_pos_dat %>%
  mutate(lec_type = fct_relevel(lec_type, names(plt_labs)))

# Create UMAP
chikv_typs_u <- so_8@meta.data %>%
  # mutate(lec_type = fct_relevel(lec_type, names(plt_labs))) %>%
  ggplot(aes(UMAP_1, UMAP_2)) +
  geom_point_trace(
    color = "grey",
    fill  = "white",
    trace_position = "bottom"
  ) +
  geom_point(aes(color = lec_type), data = chikv_pos_dat) +
  scale_color_manual(values = lec_type_cols, labels = plt_labs) +
  scale_y_discrete(labels = type_lab_fn) +
  guides(color = guide_legend(override.aes = list(size = 4))) +
  labs(title = "CHIKV+ cell types") +
  umap_theme +
  theme(
    aspect.ratio         = 0.9,
    plot.title           = element_text(size = ttl_pt2 * 1.5, hjust = 0.2),
    legend.title         = element_blank(),
    legend.key.height    = unit(35, "pt"),
    legend.justification = "bottom",
    legend.text          = element_text(size = ttl_pt1)
  )
```

```{r "8hpi fraction CHIKV-high"}
# Format plot data
# ONLY PLOTTING ENRICHED COUNTS
dat <- so_8@meta.data %>%
  as_tibble(rownames = ".cell_id") %>%
  filter(treatment == "CHIKV")

# Fraction CHIKV-high cells
# top cell types with >40 total cells, >3 CHIKV+ cells
frac_dat <- dat %>%
  group_by(lec_type) %>%
  summarize(
    n    = length(chikv_grp[chikv_grp == chikv_grps[2]]),
    tot  = n(),
    frac = n / tot,
    .groups = "drop"
  ) %>%
  group_by(lec_type) %>%
  mutate(
    tot      = sum(tot),
    tot_frac = sum(n) / tot,
    n_lab    = label_comma()(tot),
    n_lab    = str_c(lec_type, "\nn = ", n, "/", n_lab),
    n_lab    = str_replace(n_lab, "_", " ")
  ) %>%
  ungroup() %>%
  filter(tot > 40, n > 3) %>%
  mutate(lec_type = fct_reorder(lec_type, tot_frac, max, .desc = TRUE))

frac_lvls <- levels(frac_dat$lec_type)

n_lab <- set_names(frac_dat$n_lab, frac_dat$lec_type)

frac_8 <- frac_dat %>%
  filter(lec_type %in% frac_lvls) %>%
  ggplot(aes(lec_type, tot_frac, fill = lec_type, color = lec_type)) +
  geom_col(
    width = 0.55, size = 1, alpha = 0.5,
    position = position_dodge2(padding = 0.12)
  ) +
  scale_fill_manual(values = lec_type_cols) +
  scale_color_manual(values = lec_type_cols) +
  scale_x_discrete(labels = n_lab) +
  scale_y_continuous(breaks = c(0, 0.1, 0.2)) +
  labs(y = "Fraction\nCHIKV+ cells") +
  base_theme +
  theme(
    axis.text.y = element_text(size = txt_pt1),
    axis.text.x = element_text(size = ttl_pt2, angle = 45, hjust = 1),
    axis.title.x = element_blank(),
    legend.position = "none",
  )
```

```{r "8hpi CHIKV counts boxes", fig.width = 10, fig.height = 5}
# Create boxplots
# Only plot CHIKV-high cells for cell types shown in bargraphs
count_bxs <- dat %>%
  filter(chikv_grp == "CHIKV-high", lec_type %in% frac_lvls) %>%
  mutate(lec_type = fct_relevel(lec_type, frac_lvls)) %>%
  ggplot(aes(lec_type, tot_pct_CHIKV, fill = lec_type, color = lec_type)) +
  geom_boxplot(
    size = 1, outlier.size = 1.5, outlier.alpha = 1,
    alpha = 0.5, width = 0.55,
    position = position_dodge2(padding = 0.12)
  ) +
  scale_x_discrete(labels = plt_labs) +
  scale_y_continuous(expand = expansion(c(0.05, 0.2)), trans = "log10") +
  scale_fill_manual(values = lec_type_cols) +
  scale_color_manual(values = lec_type_cols) +
  labs(y = "% CHIKV counts") +
  base_theme +
  theme(
    plot.margin     = margin(5, 5, 5, 35),
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.title.y    = element_text(size = ttl_pt2),
    axis.text.x     = element_blank(),
    axis.ticks.x    = element_blank()
  )

count_bxs <- plot_grid(
  count_bxs, frac_8,
  labels = c("C", "D"), label_size = ttl_pt2 * 1.5,
  align = "v", axis = "rl",
  ncol = 1,
  rel_heights = c(1, 1)
)



# # CALCULATE P-VALUES
# x <- dat %>%
#   filter(chikv_grp == "CHIKV-high")
# 
# typs <- table(x$lec_type)
# typs <- names(typs[typs > 2])
# 
# typs %>%
#   set_names() %>%
#   map_dfr(~ {
#     x <- x %>%
#       mutate(p_type = ifelse(lec_type == .x, lec_type, "other")) %>%
#       split(.$p_type)
# 
#     x <- x[c(.x, "other")]
#     
#     typ_dat <- x[[1]]$tot_pct_CHIKV
#     oth_dat <- x[[2]]$tot_pct_CHIKV
#     
#     # x <- x %>%
#     #   split(.$lec_type)
#     # typ_dat <- x["fLEC"][[1]]$tot_pct_CHIKV
#     # oth_dat <- x[.x][[1]]$tot_pct_CHIKV
# 
#     p <- wilcox.test(typ_dat, oth_dat, alternative = "g")
#     p <- tidy(p)
# 
#     p %>%
#       mutate(
#         type = .x,
#         n    = length(typ_dat),
#         med  = median(typ_dat),
#         mean = mean(typ_dat),
#         sd   = sd(typ_dat)
#       )
#   }) %>%
#   arrange(p.value) %>%
#   mutate(p_adj = p.adjust(p.value, method = "bonferroni"))
```

```{r "fig1 examples", fig.width = 3, fig.height = 5}
plt_dat <- so_8 %>%
  mutate_meta(
    mutate,
    chikv_grp = recode(
      chikv_grp,
      `CHIKV-low` = "CHIKV-",
      `CHIKV-high` = "CHIKV+"
    )
  )

plt_lvls <- c("mock", "CHIKV-", "CHIKV+")

marco_bxs <- plt_dat %>%
  create_gene_boxplot(
    GENE = "Marco", TYPE = "fLEC",
    clr = "#D7301F", lvls = plt_lvls
  )

madcam_bxs <- plt_dat %>%
  create_gene_boxplot(
    GENE = "Madcam1", TYPE = "fLEC",
    clr = "#E69F00", lvls = plt_lvls
  )


# # CHECK FOR CONTAMINATING fLEC CLUSTERS
# # filter 24hpi Marco_LEC clusters to remove Madcam1+ cells
# # removal of Madcam1+ clusters does not affect overall result
# # i.e. CHIKV-high still shows higher Marco expression than CHIKV-low
# test_dat <- so_lec_24 %>%
#   mutate_meta(
#     mutate,
#     chikv_grp = ifelse(treatment == "mock", treatment, chikv_grp)
#   ) %>%
#   subset(lec_type == "Marco_LEC") %>%
#   FetchData(c(
#     "Madcam1", "Marco",
#     "seurat_clusters", "orig.ident", "treatment", "rep",
#     "chikv_grp"
#   ))
# 
# clsts <- test_dat %>%
#   group_by(seurat_clusters) %>%
#   summarize(sig = mean(Madcam1), n = n()) %>%
#   as.data.frame() %>%
#   arrange(desc(sig)) %>%
#   filter(sig <= 0.4) %>%
#   pull(seurat_clusters)
# 
# plt_dat <- so_lec_24 %>%
#   subset(seurat_clusters %in% clsts)
# 
# plt_dat %>%
#   create_gene_boxplot("Madcam1", "Marco_LEC")
# 
# plt_dat %>%
#   create_gene_boxplot("Marco", "Marco_LEC")
```

```{r "fig 1", fig.width = 16, fig.height = 12}
top <- plot_grid(
  A, chikv_typs_u,
  labels = c("A", "B"), label_size = ttl_pt2 * 1.5,
  nrow   = 1,
  align  = "h",
  axis   = "tb"
)

bot <- plot_grid(
  # count_bxs, NULL, marco_bxs, NULL, marco_bxs_2, NULL, madcam_bxs, NULL,
  # labels = c("", "", "E", "", "", "", "F"),
  # rel_widths = c(0.8, 0.05, 0.36, 0.05, 0.36, 0.05, 0.36, 0.5)
  count_bxs, NULL, marco_bxs, NULL, madcam_bxs, NULL,
  labels = c("", "", "E", "", "F"),
  label_size = ttl_pt2 * 1.5,
  nrow   = 1,
  rel_widths = c(1.2, 0.05, 0.36, 0.05, 0.36, 0.2)
)

plot_grid(
  top, NULL, bot,
  ncol = 1,
  rel_heights = c(1, 0.05, 0.7)
)
```

---

<br>

<br>

## Figure S2

```{r "UMAPs", fig.width = 10, fig.height = 10}
# Pseudo count for pct_mito
pseudo <- so_24$pct_mito
pseudo <- min(pseudo[pseudo > 0]) / 2

# Format data
dat <- so_24@meta.data %>%
  as_tibble(rownames = "cell_id") %>%
  mutate(pct_mito = pct_mito + pseudo) %>%
  arrange(CHIKV_sgRNA_fc)

chikv_dat <- dat %>%
  filter(chikv_grp == chikv_grps[2])

# Cell type UMAP
type_umap <- dat %>%
  plot_scatter(
    "lec_type",
    plot_colors  = lec_type_cols,
    plot_lvls    = NULL,
    size         = 0.2,
    label_params = list(size = txt_pt2)
  ) +
  umap_theme +
  theme(
    aspect.ratio = 0.9,
    legend.title = element_blank(), legend.key.height = unit(30, "pt")
  )
  
# sgRNA ratio UMAP
sgRNA_umap <- dat %>%
  ggplot(aes(UMAP_1, UMAP_2, fill = CHIKV_sgRNA_fc)) +
  geom_point_trace(
    color = "grey",
    trace_position = "bottom",
    size = 0.5
  ) +
  scale_fill_gradientn(colours = c("white", "#0072B2", "#002037"), labels = scales::label_number()) +
  guides(fill = guide_colorbar(title.position = "top", ticks = FALSE, title = "CHIKV sgRNA ratio")) +
  umap_theme +
  theme(
    aspect.ratio         = 0.9,
    legend.position      = "top",
    legend.title         = element_text(hjust = 0.5, size = ttl_pt2),
    legend.direction     = "horizontal",
    legend.justification = 0.5,
    legend.key.width     = unit(30, "pt"),
    legend.key.height    = unit(5, "pt")
  )
```

```{r "scatter plots v1", fig.width = 10, fig.height = 7, eval = FALSE}
# ONLY PLOT CHIKV-HIGH CELLS
# Shouldn't include any CHIKV-low cells, since they have been filtered
# stringently based on QC and CHIKV-high cells have not. This would influence
# correlations

# Stats to plot
y_vars <- c(
  "# mouse genes\nexpressed" = "nFeature_RNA",
  "% mitochondrial\nreads" = "pct_mito"
)

x_var <- "CHIKV_sgRNA_fc"
typs  <- c("Marco_LEC", "BEC", "PvC", "unassigned-LEC")

# Scatter plots
plt_dat <- chikv_dat %>%
  filter(lec_type %in% typs) %>%
  mutate(lec_type = fct_relevel(lec_type, typs)) %>%
  dplyr::rename(!!!syms(y_vars)) %>%
  pivot_longer(all_of(names(y_vars))) %>%
  group_by(lec_type, name) %>%
  mutate(
    cor = cor(log10(!!sym(x_var)), log10(value)),
    cor = str_c("r = ", round(cor, 2))
  ) %>%
  ungroup()

scatter <- plt_dat %>%
  split(.$lec_type) %>%
  unname() %>%
  imap(~ {
    clmn <- .y
    
    .x <- .x %>%
      split(.$name)
    
    top <- names(.x)[1]
    
    .x %>%
      imap(~ {
        if (clmn == 1) y_ttl <- .y
        else           y_ttl <- NULL
        
        ttl <- NULL
        sub <- NULL
        x_ttl <- NULL
        
        if (.y == top) {
          ttl   <- type_lab_fn(unique(.x$lec_type))
          sub   <- str_c("n = ", nrow(.x))
        }
        
        .x %>%
          ggplot(aes(!!sym(x_var), value, color = lec_type)) +
          geom_point() +
          geom_smooth(
            method = "lm", formula = y ~ x,
            color = "black", linewidth = 0.5, linetype = 2, alpha = 0.2) +
          geom_text(
            aes(Inf, Inf, label = cor),
            hjust = 1.2, vjust = 1.2,
            color = "black",
            check_overlap = TRUE
          ) +
          scale_color_manual(values = lec_type_cols) +
          scale_x_log10() +
          scale_y_log10(expand = expansion(c(0.05, 0.10))) +
          labs(title = ttl, subtitle = sub, x = x_ttl, y = y_ttl) +
          theme(aspect.ratio = 0.9) +
          base_theme +
          theme(
            legend.position = "none",
            axis.text.x = element_text(size = txt_pt1),
            axis.text.y = element_text(size = txt_pt1)
          )
      })
  }) %>%
  flatten()

# x-axis title
x_ttl <- scatter[[1]] +
  labs(title = "CHIKV sgRNA ratio") +
  theme(
    plot.title = element_text(hjust = 0.5, vjust = 1, size = ttl_pt2)
  )

x_ttl <- get_title(x_ttl)

# Create final figure
scatter <- scatter %>%
  wrap_plots(byrow = FALSE, nrow = 2)

scatter <- list(scatter, x_ttl) %>%
  wrap_plots(ncol = 1, heights = c(1, 0.1))
```

```{r "scatter plots v2", fig.width = 10, fig.height = 7}
# ONLY PLOT CHIKV-HIGH CELLS
# Shouldn't include any CHIKV-low cells, since they have been filtered
# stringently based on QC and CHIKV-high cells have not. This would influence
# correlations

# Stats to plot
y_vars <- c(
  "# mouse genes\nexpressed" = "nFeature_RNA",
  "% mitochondrial\nreads" = "pct_mito"
)

x_var <- c("CHIKV sgRNA ratio" = "CHIKV_sgRNA_fc")
typs  <- c("Marco_LEC", "unassigned-LEC")

# Scatter plots
plt_dat <- chikv_dat %>%
  filter(lec_type %in% typs) %>%
  mutate(lec_type = fct_relevel(lec_type, typs)) %>%
  dplyr::rename(!!!syms(y_vars)) %>%
  pivot_longer(all_of(names(y_vars)))

scatter <- plt_dat %>%
  split(.$name) %>%
  imap(~ {
    
    log_trans <- grepl("mouse genes", .y)
    
    if (log_trans) {
      y_fn    <- log10
      y_trans <- "log10"
    } else {
      y_fn    <- function(x) x
      y_trans <- "identity"
    }
    
    n_lab <- get_nlab_fun(.x, "lec_type", l = "\n", r = "")
    
    cor_dat <- .x %>%
      summarize(
        cor = list(tidy(cor.test(
          log10(!!sym(unname(x_var))), y_fn(value),
          method = "pearson",
          alternative = "two.sided"
        ))),
        
        pval = map_dbl(cor, pull, p.value),
        pval = format_pvalue(pval),
        pval = str_c("italic(p) == ", pval),
        cor  = map_dbl(cor, pull, estimate),
        cor  = str_c("italic(r) == ", round(cor, 2))
        # cor  = str_c(cor, " ~ ", pval)
      )
    
    .x %>%
      ggplot(aes(!!sym(unname(x_var)), value, color = lec_type)) +
      geom_point() +
      geom_smooth(
        method = "lm", formula = y ~ x,
        color = "black", linewidth = 0.5, linetype = 2, alpha = 0.2
      ) +
      geom_text(
        aes(Inf, Inf, label = cor),
        data = cor_dat,
        parse = TRUE,
        hjust = 1.2, vjust = 1.2,
        color = "black"
      ) +
      scale_color_manual(values = lec_type_cols, labels = n_lab) +
      scale_x_log10() +
      scale_y_continuous(trans = y_trans, expand = expansion(c(0.05, 0.10))) +
      guides(color = guide_legend(override.aes = list(size = 4))) +
      labs(x = names(x_var), y = .y) +
      theme(aspect.ratio = 0.9) +
      base_theme +
      theme(
        aspect.ratio = 0.9,
        legend.position = "bottom",
        legend.title = element_blank(),
        axis.text.x = element_text(size = txt_pt1),
        axis.text.y = element_text(size = txt_pt1)
      )
  })

# Create final figure
scatter <- scatter %>%
  wrap_plots(byrow = FALSE, nrow = 1)

# ggsave(
#   here("results/figures/2023-07-04_alt_scatter_plots.pdf"),
#   width = 10, height = 7,
#   dpi = 600, device = "pdf"
# )
```

```{r "sgRNA signal"}
# Format plot data
# only include cell types with >40 cells
plt_dat <- dat %>%
  filter(treatment == treats[2]) %>%
  group_by(lec_type) %>%
  filter(n() > 40) %>%
  ungroup()

# Fraction CHIKV-high cells
frac_dat <- plt_dat %>%
  group_by(lec_type, rep) %>%
  summarize(
    n = length(chikv_grp[chikv_grp == chikv_grps[2]]),
    tot = n(),
    frac = n / tot,
    .groups = "drop"
  ) %>%
  group_by(lec_type) %>%
  mutate(
    tot      = sum(tot),
    tot_n    = sum(n),
    tot_frac = tot_n / tot,
    n_lab    = label_comma()(tot),
    n_lab    = str_c(lec_type, "\nn = ", tot_n, "/", n_lab),
    n_lab    = str_replace(n_lab, "_", " ")
  ) %>%
  filter(sum(n) > 3) %>%
  ungroup() %>%
  mutate(lec_type = fct_reorder(lec_type, frac, max, .desc = TRUE))

n_lab <- set_names(frac_dat$n_lab, frac_dat$lec_type)

frac_24 <- frac_dat %>%
  ggplot(aes(lec_type, frac, fill = lec_type, color = lec_type)) +
  geom_col(
    position = position_dodge2(padding = 0.12),
    alpha = 0.5
  ) +
  scale_fill_manual(values = lec_type_cols) +
  scale_color_manual(values = lec_type_cols) +
  scale_x_discrete(labels = n_lab) +
  labs(y = "Fraction\nCHIKV-high cells") +
  base_theme +
  theme(
    axis.text.y = element_text(size = txt_pt1),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_blank(),
    legend.position = "none",
    aspect.ratio = 0.25,
    plot.margin = margin(25, 5, 5, 15)
  )

# sgRNA ratio
# Only include cell types with >40 cells
# For figure S1B a pseudo count of 1 was added to both sgRNA and 5' counts to
# eliminate division by zero
# For violin plots do not need to add pseudo count since we are filtering to
# remove cells with 0 counts
sgRNA_boxes <- plt_dat %>%
  filter(
    CHIKV_sgRNA > 0,
    CHIKV_5 > 0
  ) %>%
  mutate(
    CHIKV_sgRNA_fc_raw = CHIKV_sgRNA / CHIKV_5
  ) %>%
  group_by(lec_type) %>%
  filter(n() > 40) %>%
  ungroup() %>%
  plot_violin(
    "CHIKV_sgRNA_fc_raw",
    cluster_col = "lec_type",
    plot_colors = lec_type_cols,
    plot_lvls   = NULL,
    trans       = "log10",
    scale       = "width",
    draw_quantiles = c(0.25, 0.75)
  ) +
  labs(y = "CHIKV sgRNA\nratio") +
  base_theme +
  theme(
    aspect.ratio    = 0.25,
    plot.margin     = margin(25, 5, 5, 15),
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.text.x     = element_text(angle = 45, hjust = 1),
    axis.text.y     = element_text(size = txt_pt1),
  )



# # Calculate p-values
# p_dat <- plt_dat %>%
#   filter(
#     CHIKV_sgRNA > 0,
#     CHIKV_5 > 0
#   ) %>%
#   mutate(CHIKV_sgRNA_fc_raw = CHIKV_sgRNA / CHIKV_5) %>%
#   group_by(lec_type) %>%
#   filter(n() > 40) %>%
#   ungroup() %>%
#   dplyr::select(lec_type, CHIKV_sgRNA_fc_raw, CHIKV_sgRNA_fc) %>%
#   split(.$lec_type)
# 
# target <- p_dat$`unassigned-LEC`
# 
# p_dat %>%
#   imap_dfr(~ {
#     wilcox.test(target$CHIKV_sgRNA_fc_raw, .x$CHIKV_sgRNA_fc_raw) %>%
#       tidy() %>%
#       mutate(lec_type = .y)
#   }) %>%
#   mutate(p_adj = p.adjust(p.value, method = "bonferroni")) %>%
#   arrange(p.value)
```

CHIKV may target MARCO-expressing LECs for infection

A.  UMAP projection shows annotated cell types for the 24 hpi timepoint.
B.  UMAP projection shows CHIKV sgRNA ratio (sgRNA counts / 5' counts) for the 24 hpi timepoint.
C.  The fraction of cells identified as CHIKV-high is shown for each cell type for the 24 hpi timepoint. Labels show the number of CHIKV-high cells/total cells.
D.  CHIKV sgRNA ratio is shown for cells with >0 sgRNA counts and >0 5' counts. Cell types with >40 cells are shown.
E.  The correlation between CHIKV sgRNA ratio and QC metrics is shown for CHIKV-high cells for Marco LECs and unassigned LECs.

```{r "fig S1 v2", fig.width = 16, fig.height = 14}
top <- plot_grid(
  type_umap, sgRNA_umap,
  labels = c("A", "B"), label_size = ttl_pt2 * 1.5,
  align = "vh", axis = "trbl",
  nrow = 1
)

left <- plot_grid(
  frac_24, sgRNA_boxes,
  labels = c("C", "D"), label_size = ttl_pt2 * 1.5,
  align = "v", axis = "rl",
  ncol = 1
)

right <- plot_grid(
  NULL, scatter, NULL,
  rel_heights = c(0.15, 1, 0.15),
  ncol = 1
)

bot <- plot_grid(
  left, right,
  labels = c("", "E"), label_size = ttl_pt2 * 1.5,
  # rel_widths = c(0.75, 1),
  nrow = 1
)

plot_grid(
  top, bot,
  rel_heights = c(1, 0.75),
  ncol = 1
)
```

---

<br>

<br>

## Figure S3

A.  The correlation between annotated LEC subsets and reference data is shown for the 8 hpi and 24 hpi timepoint.
B.  The expression of select marker genes is shown for the 8 hpi and 24 hpi timepoints.

```{r "cell type heatmaps v1", fig.width = 8, fig.height = 5}
# Format heatmap data
h_dat <- so_lec %>%
  SplitObject("tm") %>%
  imap(~ {
    obj <- .x
    set_names(treats, str_c(.y, "-", treats)) %>%
      map(~ subset(obj, treatment == .x))
  }) %>%
  flatten() %>%
  map(~ {
    .x %>%
      mutate_meta(
        mutate,
        lec_type = lec_subtype,
        lec_type = recode(lec_type, unassigned = "unassigned-LEC")
      )
  })

h_mat <- h_dat %>%
  map(~ {
    .x %>%
      clustify(
        ref_mat        = ref_lec,
        cluster_col    = "lec_type",
        seurat_out     = FALSE,
        compute_method = "spearman",
        n_genes        = 2000
      ) %>%
      as_tibble(rownames = "assigned_type") %>%
      pivot_longer(
        cols      = -assigned_type,
        names_to  = "ref_type",
        values_to = "r"
      )
  })

# Format LEC types labels
lec_labs <- h_dat %>%
  map(~ {
    typs <- .x@meta.data %>%
      group_by(lec_type) %>%
      dplyr::filter(n() > 10) %>%
      pull(lec_type) %>%
      unique()
    
    .x %>%
      subset(lec_type %in% typs)
  }) %>%
  map(get_nlab_fun, "lec_type", l = "\n", r = "")
  
# Create heatmaps
heat_args <- list(
  df_in    = h_mat,
  ttl      = names(h_mat),
  lec_labs = lec_labs
)

type_heats <- heat_args %>%
  pmap(create_cor_heatmap, ln_clr = fade_0) %>%
  plot_grid(plotlist = .)
```

```{r "type examples extended", fig.width = 10, fig.height = 6.5}
tms <- c("8hpi", "24hpi")

gns <- c(
  "Lyve1", "Marco",    # Marco LECs
  "Madcam1", "Vcam1",  # fLECs
  "Ptx3",              # Ptx3 LECs
  "Ackr4"              # cLECs
)

# Format data
typ_bx_dat <- list("8hpi" = so_8, "24hpi" = so_24) %>%
  imap_dfr(~ {
    clmns <- c(
      "cell_type", "lec_type", "frc_type",
      "treatment", "orig.ident", "rep", "chikv_grp", gns
    )
    
    .x %>%
      FetchData(clmns) %>%
      as_tibble(rownames = "cell_id") %>%
      mutate(
        tm = .y,
        tm = fct_relevel(tm, tms),
        tm_treat = str_c(tm, "-", treatment),
        tm_treat = fct_relevel(tm_treat, unlist(map(tms, str_c, "-", treats)))
      )
  })

# Create boxplots
type_boxes <- gns %>%
  map(~ {
    lvls <- typ_bx_dat %>%
      group_by(lec_type) %>%
      summarize(
        stats = list(boxplot.stats(!!sym(.x))),
        med   = map_dbl(stats, ~ .x$stats[3]),
        q3    = map_dbl(stats, ~ .x$stats[4]),
        q4    = map_dbl(stats, ~ .x$stats[5]),
        mx    = max(!!sym(.x))
      ) %>%
      arrange(med, q3, q4, mx) %>%
      pull(lec_type) %>%
      rev()
      
    typ_bx_dat %>%
      mutate(
        lec_type = fct_relevel(lec_type, lvls),
        chikv_grp = fct_relevel(chikv_grp, chikv_grps)
      ) %>%
      ggplot(aes(lec_type, !!sym(.x), color = lec_type, fill = lec_type, alpha = chikv_grp)) +
      geom_boxplot(
        size = 0.25, color = "black",
        outlier.size = 0.01, outlier.alpha = 0.1,
        position = position_dodge2(preserve = "single"),
        key_glyph = draw_key_point,
      ) +
      scale_color_manual(values = lec_type_cols) +
      scale_fill_manual(values = lec_type_cols) +
      scale_alpha_manual(values = c(`CHIKV-low` = 0.5, `CHIKV-high` = 1)) +
      scale_x_discrete(labels = type_lab_fn) +
      facet_wrap(~ tm_treat, ncol = 1) +
      labs(y = str_c(.x, " expression")) +
      guides(
        fill = "none", color = "none",
        alpha = guide_legend(
          override.aes = list(shape = 15, fill = "black", size = 4)
        )
      ) +
      base_theme +
      theme(
        aspect.ratio    = 0.15,
        legend.position = "top",
        legend.title    = element_blank(),
        legend.text     = element_text(size = txt_pt1),
        axis.title.x    = element_blank(),
        axis.text.x     = element_text(size = txt_pt2, angle = 90, hjust = 1, vjust = 0.5),
        axis.text.y     = element_text(size = txt_pt1 * 0.75),
        strip.text      = element_text(size = txt_pt2)
      )
  }) %>%
  plot_grid(
    plotlist = .,
    align = "vh",
    axis  = "trbl",
    nrow  = 2
  )
```

```{r "fig S1 cell type", fig.width = 12, fig.height = 18}
plot_grid(
  type_heats, NULL, type_boxes,
  rel_heights = c(0.7, 0.04, 1),
  label_size  = ttl_pt2 * 1.5,
  labels      = c("A", "B"),
  ncol        = 1
)
```

### V2

This is an alternate version of fig S3 that includes UMAPs showing the
integrated projections used for annotating cell types.

A.  UMAP projection shows cell type annotations for integrated data.
B.  UMAP projection shows endothelial cell type annotations for integrated endothelial cell data.
C.  The correlation between annotated endothelial subsets and reference data is shown.
D.  The expression of select marker genes is shown for the 8 hpi and 24 hpi timepoints.

```{r "fig S1 cell type UMAPs", fig.width = 12, fig.height = 6}
create_type_umaps <- function(so_in, data_col, clrs = type_cols, ttl = NULL, ...) {
  res <- so_in %>%
    mutate_meta(~ {
      .x %>%
        group_by(tm, treatment) %>%
        mutate(
          n_lab = label_comma()(n()),
          n_lab = str_c("n = ", n_lab)
        ) %>%
        ungroup() %>%
        mutate(
          tm = fct_relevel(tm, c("8hpi", "24hpi")),
          treatment = fct_relevel(treatment, treats)
        )
    }) %>%
    plot_scatter(
      data_col,
      x = "hUMAP_1",
      y = "hUMAP_2",
      n_label     = "legend",
      plot_colors = clrs,
      ...
    ) + 
    geom_text(
      aes(Inf, Inf, label = n_lab),
      hjust = 1.1, vjust = 1.2, color = "black",
      check_overlap = TRUE
    ) +
    facet_grid(tm ~ treatment) +
    ggtitle(ttl) +
    theme(
      aspect.ratio = 0.8,
      axis.title   = element_blank(),
      axis.text    = element_blank(),
      axis.ticks   = element_blank(),
      legend.title = element_blank(),
      plot.title   = element_text(face = "plain", hjust = 0.5),
      legend.position = "bottom"
    )
  
  res
}

# Load merged objects containing all cells
all_u <- so_merge_df %>%
  create_type_umaps(
    "cell_type",
    clrs = type_cols,
    ttl  = "Cell types",
    size = 0.001
  )

lec_u <- so_lec %>%
  create_type_umaps(
    "lec_subtype",
    clrs = lec_type_cols,
    ttl  = "Endothelial cell types",
    size = 0.001
  )

# Create final figure
type_fig <- plot_grid(
  all_u, lec_u,
  align = "h",
  axis  = "tb",
  nrow  = 1,
  labels = c("A", "B"),
  label_size  = ttl_pt2 * 1.5
)
```

```{r "cell type heatmaps v2", fig.width = 8, fig.height = 5}
# Alternate version of cell type heatmaps
# calculate correlations using combined data for all samples

# Format heatmap data
h_dat <- so_lec %>%
  mutate_meta(
    mutate,
    lec_type = lec_subtype,
    lec_type = recode(lec_type, unassigned = "unassigned-LEC")
  )

rm(so_lec)

h_mat <- h_dat %>%
  clustify(
    ref_mat        = ref_lec,
    cluster_col    = "lec_type",
    seurat_out     = FALSE,
    compute_method = "spearman",
    n_genes        = 2000
  ) %>%
  as_tibble(rownames = "assigned_type") %>%
  pivot_longer(
    cols      = -assigned_type,
    names_to  = "ref_type",
    values_to = "r"
  )

# Format LEC types labels
typs <- h_dat@meta.data %>%
  group_by(lec_type) %>%
  dplyr::filter(n() > 10) %>%
  pull(lec_type) %>%
  unique()

lec_labs <- h_dat %>%
  subset(lec_type %in% typs) %>%
  get_nlab_fun("lec_type", l = "\n", r = "")
  
# Create heatmaps
heat_args <- list(
  df_in    = h_mat,
  ttl      = names(h_mat),
  lec_labs = lec_labs
)

type_heats_v2 <- h_mat %>%
  create_cor_heatmap(ln_clr = fade_0)

type_heats_v2 <- plot_grid(
  type_heats_v2, NULL,
  labels     = c("C", ""),
  label_size = ttl_pt2 * 1.5
)
```

```{r "fig S1 cell type v2", fig.width = 12, fig.height = 20}
plot_grid(
  type_fig, NULL, type_heats_v2, NULL, type_boxes,
  rel_heights = c(0.7, 0.04, 0.4, 0.04, 1.2),
  labels      = c("", "", "", "", "D"),
  label_size  = ttl_pt2 * 1.5,
  ncol        = 1
)
```



```{r "cell type sample heatmaps", fig.width = 8, fig.height = 5, eval = FALSE}
# Format heatmap data
h_dat <- list("8hpi" = so_lec_8, "24hpi" = so_lec_24) %>%
  imap(~ {
    obj <- .x
    set_names(treats, str_c(.y, "-", treats)) %>%
      map(~ subset(obj, treatment == .x))
  }) %>%
  flatten() %>%
  map(~ {
    .x %>%
      mutate_meta(
        mutate,
        lec_type = recode(lec_type, unassigned = "unassigned-LEC")
      )
  })

rm(so_lec_8, so_lec_24)

# Calculate average expression to use for correlation calculations
ref_mats <- h_dat %>%
  map(~ {
    average_clusters(
      mat         = .x@assays$RNA@data,
      metadata    = .x@meta.data,
      cluster_col = "lec_type"
    )
  })

# Calculate correlation
h_mat <- h_dat %>%
  imap_dfr(~ {
    mat <- .x
    mat_sample <- .y
    
    ref_mats %>%
      imap_dfr(~ {
        mat %>%
          clustify(
            ref_mat        = .x,
            cluster_col    = "lec_type",
            seurat_out     = FALSE,
            compute_method = "spearman",
            n_genes        = 2000
            # query_genes    = VariableFeatures(h_dat$`24hpi-mock`),
            # low_threshold_cell = 50,
          ) %>%
          as_tibble(rownames = "assigned_type") %>%
          pivot_longer(
            cols      = -assigned_type,
            names_to  = "ref_type",
            values_to = "r"
          ) %>%
          mutate(
            mat_sample = mat_sample,
            ref_sample = .y
          )
      })
  })

# Format data for text labels
txt_dat <- h_mat %>%
  filter(mat_sample != ref_sample) %>%
  group_by(assigned_type, mat_sample, ref_sample) %>%
  summarize(
    ref_type = ref_type[r == max(r)],
    top_cor = round(max(r), 2),
    .groups = "drop"
  )
  
  # rowwise() %>%
  # mutate(sams = str_c(sort(c(mat_sample, ref_sample)), collapse = "-")) %>%
  # ungroup() %>%
  # group_by(sams) %>%
  
# Create heatmaps
h_mat %>%
  filter(mat_sample != ref_sample) %>%
  ggplot(aes(ref_type, assigned_type, fill = r)) +
  geom_tile() +
  
  geom_text(
    aes(label = top_cor, fill = NULL),
    data = txt_dat
  ) +
  
  scale_fill_gradientn(colours = c("white", "red")) +
  facet_grid(mat_sample ~ ref_sample, scales = "free") +
  djvdj_theme() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

```{r "type examples", fig.width = 10, fig.height = 6.5, eval = FALSE}
# Genes to plot
gns <- c(
  "Lyve1", "Marco",    # Marco LECs
  "Madcam1", "Vcam1",  # fLECs
  "Ptx3",              # Ptx3 LECs
  "Ackr4"              # cLECs
)

all_gns <- c(gns, c("Mxra8", "Ccl21a", "Il7", "Cxcl13", "Cxcl9"))

# Format data
typ_bx_dat <- list("8hpi" = so_8, "24hpi" = so_24) %>%
  imap_dfr(~ {
    if (identical(.y, "8hpi")) {
      .x <- .x %>%
        mutate_meta(mutate, frc_type = fib_subtype)
    }
    
    clmns <- c(
      "cell_type", "lec_type", "frc_type",
      "treatment", "orig.ident", "rep", "chikv_grp", all_gns
    )
    
    .x %>%
      FetchData(clmns) %>%
      as_tibble(rownames = "cell_id") %>%
      mutate(
        tm = .y,
        tm = fct_relevel(tm, tms),
        tm_treat = str_c(tm, "-", treatment),
        tm_treat = fct_relevel(tm_treat, unlist(map(tms, str_c, "-", treats)))
      )
  })

# Create boxplots
type_boxes <- gns %>%
  map(~ {
    lvls <- typ_bx_dat %>%
      group_by(lec_type) %>%
      summarize(
        stats = list(boxplot.stats(!!sym(.x))),
        med   = map_dbl(stats, ~ .x$stats[3]),
        q3    = map_dbl(stats, ~ .x$stats[4]),
        q4    = map_dbl(stats, ~ .x$stats[5]),
        mx    = max(!!sym(.x))
      ) %>%
      arrange(med, q3, q4, mx) %>%
      pull(lec_type) %>%
      rev()
      
    typ_bx_dat %>%
      mutate(lec_type = fct_relevel(lec_type, lvls)) %>%
      ggplot(aes(lec_type, !!sym(.x), color = lec_type, fill = lec_type)) +
      geom_boxplot(
        size = 0.5, alpha = 0.5,
        outlier.size = 0.1, outlier.alpha = 1,
        position = position_dodge2(preserve = "single")
      ) +
      scale_color_manual(values = lec_type_cols) +
      scale_fill_manual(values = lec_type_cols) +
      scale_x_discrete(labels = type_lab_fn) +
      facet_wrap(~ tm, ncol = 1) +
      labs(y = str_c(.x, " expression")) +
      base_theme +
      theme(
        aspect.ratio    = 0.16,
        legend.position = "none",
        axis.title.x    = element_blank(),
        axis.text.x     = element_text(angle = 45, hjust = 1),
        axis.text.y     = element_text(size = txt_pt1)
      )
  }) %>%
  plot_grid(
    plotlist = .,
    align = "vh",
    axis  = "trbl",
    nrow  = 2
  )
```

```{r "INTEGRATION", eval = FALSE}
# Clustering resolutions
rslns <- c(1, 3, 5)

# Merge timepoints
so_merge <- merge(so_lec_8, so_lec_24) %>%
  run_m3drop(threshold = 0.001) %>%
  ScaleData(assay = "RNA") %>%
  cluster_RNA(
    resolution = rslns,
    dims       = 1:40
  ) %>%
  mutate_meta(
    mutate,
    tm = replace_na(tm, "24hpi"),
    sample = ifelse(is.na(sample), str_c(treatment, tm, rep, sep = "-"), sample)
  )

# Variables to regress out
vars_to_regress <- c("pct_mito", "nCount_RNA")

# Cluster each treatment separately
so_treats <- set_names(treats) %>%
  map(~ subset(so_merge, treatment == .x))

rm(so_merge)  

so_treats <- so_treats %>%
  map(~ {
    .x %>%
      subset_sobj(
        dims         = 1:40,
        rsln         = rslns,
        var_p        = 0.001,
        regress_vars = vars_to_regress
      )
  })

# Integration features
features <- SelectIntegrationFeatures(object.list = so_treats)

# Scale data using integration features
so_int <- so_treats %>%
  map(~ {
    .x %>%
      ScaleData(features = features) %>%
      RunPCA(features = features)
  })

rm(so_treats)

# Get integration anchors and integrate
int_anchors <- so_int %>%
  FindIntegrationAnchors(
    anchor.features = features,
    reduction = "rpca"
  )

so_int <- IntegrateData(
  anchorset = int_anchors,
  normalization.method = "LogNormalize"
)

rm(int_anchors)

# Scale and cluster integrated data
DefaultAssay(so_int) <- "integrated"

so_int <- so_int %>%
  ScaleData(vars.to.regress = vars_to_regress) %>%
  RunPCA() %>%
  RunUMAP(dims = 1:40, reduction.key = "intUMAP_") %>%
  FindNeighbors(dims = 1:40) %>%
  FindClusters(resolution = rslns)

so_int <- so_int %>%
  AddMetaData(FetchData(., str_c("intUMAP_", 1:2)))

DefaultAssay(so_int) <- "RNA"

so_int %>%
  qsave(here(params$so_dir, "so_int.qs"))
```

```{r "cell type markers", fig.height = 21, fig.width = 20, eval = FALSE}
feats <- c(
  "Ptprc",           # hematopoietic cells
  "Pdpn", "Pecam1",  # LECs (+/+), BECs (-/+), FRCs (+/-)
  "Pdgfra",          # Fibroblasts
  "Acta2", "Itga7",  # PvCs
  "Cd14", "Fcgr3",   # macrophages/monocytes
  "Fcgr1",           # macrophages
  "Nkg7",            # NK cells
  "Cd3e",            # T cells
  "Cd19"             # B cells
)

feats %>%
  map(~ {
    so_8 %>%
      plot_example_gene(
        .x, "lec_type",
        box_colors  = lec_type_cols,
        umap_colors = c("white", "#D7301F")
      )
  }) %>%
  plot_grid(plotlist = ., ncol = 4)
```

```{r "lec type markers", fig.height = 28, fig.width = 20, eval = FALSE}
feats <- c(
  "Marco", "Lyve1", "Tspan7",        # Marco LECs
  "Madcam1", "Vcam1", "Clu", "Ltb",  # fLECs
  "Ptx3", "Stab2",                   # Ptx3 LECs
  "Cldn11", "Esam",                  # Valve LECs
  "Ackr4", "Foxc2",                  # cLECs
  "Ccl21a"                           # Collecting LECs
)

feats %>%
  map(~ {
    so_8 %>%
      plot_example_gene(
        .x, "lec_type",
        box_colors  = lec_type_cols,
        umap_colors = c("white", "#D7301F")
      )
  }) %>%
  plot_grid(plotlist = ., ncol = 4)
```

---

<br>

<br>

## Figure 5

Differentially expressed genes were identified for each cell type for mock vs 8 hpi and 8 hpi vs 24 hpi. Genes were considered upregulated if the log2 fold change was >0.15 for 8 hpi and >0.25 for 24 hpi for all replicates and the largest p-value for all replicates was <0.05.

Gene ontology terms (biological process) were then identified for the top 200 upregulated genes (sorted by maximum p-value between replicates) for each cell type. Terms were filtered to only include those with an adjusted p-value <0.05 and at least 3 or 10 upregulated genes overlapping the term for the 8 hpi and 24 hpi timepoints, respectively. Terms identified for each cell type were combined and clustered into 5 modules based on the pairwise overlap between terms.

A.  UMAP projection shows cells from the 8 hpi and 24 hpi timepoints, cells are colored by sample.
B.  UMAP projection shows cells from the 8 hpi and 24 hpi timepoints, cells are colored by cell type.
C.  The 8 hpi timeopoint shows upregulation of genes associated with an innate immune response. Enrichment scores are shown for each cell type for the primary gene ontology module identified for genes upregulated at the 8 hpi timepoint. Enrichment score is the fraction of upregulated genes overlapping the term divided by the fraction of background genes overlapping the term. GO terms that are significantly enriched are marked by the diamond.
D.  A selection of top upregulated genes identified for the terms shown in A are plotted. Points show the median expression for the mock (m), 8 hpi (8h), and 24 hpi (24h) samples, grey bars show the interquartile range. A solid line indicates that the gene is significantly upregulated between the samples.
E.  Enrichment scores are shown for the primary GO modules identified for the 24 hpi timepoint, as described in C.
F.  Top upregulated genes identified for the terms shown in E are plotted as described in D.

```{r "DEGs"}
# Create object to compare CHIKV 24 hpi with 8 hpi
# only use top two biological replicates with the most cells
top_reps <- as.character(so_24$rep) %>%
  table() %>%
  sort() %>%
  tail(2) %>%
  names() %>%
  sort()

new_reps <- set_names(
  seq_along(top_reps), top_reps
)

so_merge <- so_24 %>%
  subset(treatment == "CHIKV") %>%
  subset(rep %in% names(new_reps)) %>%
  mutate_meta(~ {
    .x %>%
      mutate(
        rep = recode(rep, !!!new_reps),
        treatment = "24hpi"
      )
  })

so_merge <- so_8 %>%
  subset(treatment == "CHIKV") %>%
  mutate_meta(mutate, treatment = "8hpi") %>%
  merge(so_merge)

# Create objects to compare CHIKV-low/-high cells
so_8_chikv <- so_8 %>%
  subset(treatment == "CHIKV")

so_24_chikv <- so_24 %>%
  subset(treatment == "CHIKV")

# Identify up/down regulated genes
# use FindConservedMarkers()
deg_args <- list(
  so_in      = c("so_8", "so_8", "so_24", "so_24", "so_merge", "so_merge", "so_8_chikv", "so_24_chikv"),
  treat_clmn = c(rep("treatment", 6), rep("chikv_grp", 2)),
  ident_1    = c(rep("CHIKV", 4), rep("24hpi", 2), rep("CHIKV-high", 2)),
  ident_2    = c(rep("mock", 4),  rep("8hpi", 2),  rep("CHIKV-low", 2)),
  log_fc     = list(
    c(0.15, Inf), c(-Inf, -0.15),  # 8 hpi up and down
    c(0.25, Inf), c(-Inf, -0.25),  # 24 hpi up and down
    c(0.25, Inf), c(-Inf, -0.25),  # merged up and down
    c(0.15, Inf), c(0.15, Inf)     # CHIKV-high up
  )
)

degs <- deg_args %>%
  pmap(~ {
    args <- list(...)

    if      (all(args$log_fc > 0)) typ <- "-up"
    else if (all(args$log_fc < 0)) typ <- "-down"
    else                           typ <- ""
    
    prfx <- str_remove(args$so_in, "^so_")
    file <- str_c(prfx, "_lectype_chikv", typ, "_markers.tsv")
    file <- here("results/tables", file)
    
    d <- eval(sym(args$so_in)) %>%
      get_degs(
        log_fc     = args$log_fc,
        file       = file,
        ident_1    = args$ident_1,
        ident_2    = args$ident_2,
        treat_clmn = args$treat_clmn,
        type_clmn  = "lec_type"
      ) %>%
      list()
    
    names(d) <- str_c(args$so_in, typ)
    
    d
  }) %>%
  flatten()

rm(so_8_chikv, so_24_chikv)
```

```{r "GO"}
# Prepare GO data to measure similarity
go_sim_data <- godata(
  OrgDb   = org.Mm.eg.db,
  keytype = "SYMBOL",
  ont     = "BP"
)

# Get GO terms
# only use top 200 DEGs
# go_degs <- degs[grepl("^so_(8|merge)-up$|_chikv-up$", names(degs))] %>%
go_degs <- degs[grepl("^so_(8|merge)-up$", names(degs))] %>%
  map(~ {
    .x %>%
      arrange(max_pval) %>%
      split(.$lec_type) %>%
      map(pull, gene) %>%
      map(head, 200)
  })

go <- go_degs %>%
  imap(~ {
    typ   <- str_remove(.y, ".+(?=-)")
    so_in <- str_remove(.y, "-.+$")
    prfx  <- str_remove(so_in, "^so_")
    file  <- str_c(prfx, "_lectype_chikv", typ, "_go")
    file  <- here("results/tables", file)
    
    .x %>%
      get_go(
        so_in     = eval(sym(so_in)),
        file      = file,
        type_clmn = "lec_type"
      )
  })
```

```{r "GO clusters"}
# Cell types to exclude from GO analysis
# exclude CD45+ cell types and erythrocytes
exclude_cell_types <- c(
  "T cells", "B cells", "Macrophages",
  "Erythrocytes", "unassigned", "unassigned-LEC"
)

# Only use terms with >= 3 overlapping genes for 8 hpi and 10 for 24 hpi
so_8_re <- "^(so_8-|so_[0-9]+_chikv)"

clusters <- go %>%
  imap(~ {
    ovlp <- ifelse(grepl(so_8_re, .y), 3, 10)
    k    <- ifelse(grepl(so_8_re, .y), 5, 5)
    
    get_clusters(.x, k = k, n_overlap = ovlp, n_shared = 1)
  }) %>%
  discard(is.null)

# Calculate similarity between 8hpi and 24hpi terms
clusters_merged <- clusters$`so_merge-up`$clusters %>%
  mutate(cluster = str_c("24hpi-", cluster))

clusters_merged <- clusters$`so_8-up`$clusters %>%
  mutate(cluster = str_c("8hpi-", cluster)) %>%
  bind_rows(clusters_merged)

cluster_lvls <- unique(clusters_merged$cluster)

clusters_merged <- clusters_merged %>%
  split(.$cluster) %>%
  map(pull, ID)

comps <- names(clusters_merged) %>%
  expand.grid(names(clusters_merged)) %>%
  as.list()

cluster_sim <- map2_dfr(comps$Var1, comps$Var2, ~ {
  sim <- mgoSim(
    GO1 = clusters_merged[[.x]],
    GO2 = clusters_merged[[.y]],
    semData = go_sim_data
  )
  
  tibble(var1 = .x, var2 = .y, sim = sim)
})

# Create heatmap
sim_heatmap <- cluster_sim %>%
  mutate(
    var1 = fct_relevel(var1, cluster_lvls),
    var2 = fct_relevel(var2, rev(cluster_lvls))
  ) %>%
  ggplot(aes(var1, var2, fill = sim)) +
  geom_tile() +
  scale_fill_gradientn(colours = c("lightblue", "white", "red")) +
  djvdj_theme() +
  theme(
    aspect.ratio = 1,
    axis.title = element_blank()
  )
```

```{r "GO heatmaps"}
# Cluster titles
ttls <- as_labeller(c(`1` = "Innate Immune Response", `2` = "Inflammatory Response"))

# Cluster colors
clrs_8  <- c(`1` = "#E69F00", `2` = "#56B4E9")
clrs_24 <- c(`1` = "#D7301F", `2` = "#6A51A3")

# Create heatmaps
# only showing cell types that have at least one overlapping term plotted and
# are not in exclude_cell_types
# pval, qval, n_overlap cutoffs should match those used for clustering
go_heat <- clusters %>%
  imap(~ {
    go_in  <- go[[.y]]
    ovlp   <- ifelse(grepl(so_8_re, .y), 3, 10)
    # n_gns  <- ifelse(grepl(so_8_re, .y), 10, 20)
    
    if (grepl("^so_8-", .y)) {
      clrs  <- clrs_8
      clsts <- 1
    } else {
      clrs  <- clrs_24
      clsts <- 1:2
    }
    
    .x$clusters %>%
      create_go_heatmap(
        go_in     = go_in,
        n_overlap = ovlp,
        # n_genes   = n_gns,
        clusters  = clsts,
        clrs      = clrs,
        cluster_labels = ttls,
        exclude_cell_types = exclude_cell_types
      )
  })

# # Calculate frequency of words for each GO cluster
# clusters %>%
#   map_dfr(~ {
#     .x$clusters %>%
#       split(.$cluster) %>%
#       map_dfr(~ {
#         .x %>%
#           filter(cluster == 1) %>%
#           pull(ID) %>%
#           simplifyEnrichment::keyword_enrichment_from_GO()
#       })
#   })
# 
# clst_matches <- cluster_sim %>%
#   filter(var1 != var2) %>%
#   group_by(var1) %>%
#   filter(
#     sim > 0.6,
#     sim == max(sim[sim < 1])
#   ) %>%
#   rowwise() %>%
#   mutate(matches = list(sort(as.character(c(var1, var2))))) %>%
#   pull(matches) %>%
#   unique()
```

```{r "8hpi examples"}
# Example genes to plot
obj <- "so_8-up"
genes_to_plot <- c("Bst2", "Isg15", "Irf7")

gns <- go[[obj]]@compareClusterResult %>%
  as_tibble() %>%
  right_join(go_heat[[obj]]$terms, by = "Description") %>%
  mutate(geneID = str_split(geneID, "/")) %>%
  unnest(geneID) %>%
  group_by(geneID, cluster) %>%
  summarize(n = n_distinct(Cluster), .groups = "drop") %>%
  distinct(geneID, .keep_all = TRUE) %>%
  arrange(cluster, desc(n)) %>%
  filter(geneID %in% genes_to_plot)

top_sig <- degs[[obj]] %>%
  filter(gene %in% gns$geneID) %>%
  group_by(gene) %>%
  summarize(pval = min(max_pval), .groups = "drop")

gns <- gns %>%
  left_join(top_sig, by = c(geneID = "gene")) %>%
  arrange(desc(n), pval) %>%
  group_by(cluster) %>%
  dplyr::slice(1:3)

gns <- set_names(as.character(gns$cluster), gns$geneID)

# Create plots
examples_8 <- create_gene_plots(
  exp_data   = list("8hpi" = so_8, "24hpi" = so_merge),
  deg_data   = list("8hpi" = degs$`so_8-up`, "24hpi" = degs$`so_merge-up`),
  gns        = gns,
  clrs       = clrs_8,
  type_clmn  = "lec_type",
  exclude_cell_types = exclude_cell_types,
  only_show_upreg = FALSE
)
```

```{r "24hpi examples"}
# Example genes to plot
# HAND SELECTING SOME FAVORITES
obj <- "so_merge-up"
genes_to_plot <- c("Ccl2", "Isg15", "Ifi203", "Cxcl9", "Cxcl10", "Ccl7")

gns <- go[[obj]]@compareClusterResult %>%
  as_tibble() %>%
  right_join(go_heat[[obj]]$terms, by = "Description") %>%
  mutate(geneID = str_split(geneID, "/")) %>%
  unnest(geneID) %>%
  group_by(geneID, cluster) %>%
  summarize(n = n_distinct(Cluster), .groups = "drop") %>%
  distinct(geneID, .keep_all = TRUE) %>%
  arrange(cluster, desc(n))

top_sig <- degs[[obj]] %>%
  filter(gene %in% gns$geneID) %>%
  group_by(gene) %>%
  summarize(pval = min(max_pval), .groups = "drop")

gns <- gns %>%
  left_join(top_sig, by = c(geneID = "gene")) %>%
  arrange(cluster, desc(n), pval) %>%
  filter(geneID %in% genes_to_plot)

gns <- set_names(as.character(gns$cluster), gns$geneID)

# Create plots
examples_24 <- create_gene_plots(
  exp_data   = list("8hpi" = so_8, "24hpi" = so_merge),
  deg_data   = list("8hpi" = degs$`so_8-up`, "24hpi" = degs$`so_merge-up`),
  gns        = gns,
  clrs       = clrs_24,
  type_clmn  = "lec_type",
  exclude_cell_types = exclude_cell_types,
  only_show_upreg = FALSE
)


# gns %>%
#   filter(grepl("C[xc][clr]|I[fs][irg]", geneID))
```

```{r "additional examples"}
# Additional example genes to plot
obj <- "so_merge-up"
genes_to_plot <- c("Ccl19", "Ccl21a", "Il7", "Csf1", "Cxcl13", "Tnfsf13b")

# Create plots
other_examples <- create_gene_plots(
  exp_data   = list("8hpi" = so_8, "24hpi" = so_merge),
  deg_data   = list("8hpi" = degs$`so_8-up`, "24hpi" = degs$`so_merge-up`),
  gns        = genes_to_plot,
  clrs       = clrs_24,
  type_clmn  = "lec_type",
  exclude_cell_types = exclude_cell_types,
  only_show_upreg = FALSE
) +
  theme(plot.margin = margin(20, 0, 0, 0))

other_examples <- plot_grid(
  NULL, other_examples, NULL,
  labels     = c("", "G", ""),
  label_size = ttl_pt2 * 1.5,
  nrow       = 1,
  rel_widths = c(0.25, 0.5, 0.25),
  hjust      = -1,
  vjust      = 1.5
)
```

```{r "fig 5 UMAPs", fig.width = 12, fig.height = 6}
create_type_umaps <- function(so_in, data_col, x = "hUMAP_1", y = "hUMAP_2",
                              clrs = type_cols, ttl = NULL, n_lab = TRUE,
                              facet_plot = c("tm", "treatment"), ...) {
  res <- so_in %>%
    mutate_meta(~ {
      dat <- .x
      
      if (!is.null(facet_plot)) {
        dat <- dat %>%
          group_by(!!!syms(facet_plot))
      }
      
      dat %>%
        mutate(
          n_lab = label_comma()(n()),
          n_lab = str_c("n = ", n_lab)
        ) %>%
        ungroup() %>%
        mutate(
          tm = fct_relevel(tm, c("8hpi", "24hpi")),
          treatment = fct_relevel(treatment, treats)
        )
    })
  
  args <- list(
    input = res,
    data_col = data_col,
    x = x,
    y = y,
    plot_colors = clrs,
    ...
  )
  
  args$n_label <- args$n_label %||% "legend"
  
  res <- lift_dl(plot_scatter)(args) +
    ggtitle(ttl) +
    theme(
      aspect.ratio = 0.9,
      plot.margin  = margin(15, 15, 30, 15),
      axis.title   = element_blank(),
      axis.text    = element_blank(),
      axis.ticks   = element_blank(),
      legend.title = element_blank(),
      panel.background = element_blank(),
      plot.title   = element_text(face = "plain", hjust = 0.5),
      legend.position = "right"
    )
  
  if (n_lab) {
    res <- res +
      geom_text(
        aes(Inf, Inf, label = n_lab),
        hjust = 1.1, vjust = 1.2, color = "black",
        check_overlap = TRUE
      )
  }
  
  if (!is.null(facet_plot)) {
    frm <- case_with(
      length(facet_plot) == 1 ~ str_c("~ ", facet_plot),
      length(facet_plot) > 1  ~ str_c(facet_plot[1:2], collapse = " ~ ")
    )
    
    res <- res +
      facet_grid(as.formula(frm))
  }
  
  res
}

# Format UMAP data
u_lvls <- unique(so_merge_df$tm_treat)

u_clrs <- set_names(
  ito_cols[seq_along(u_lvls)],
  u_lvls
)

# UMAP showing sample groups
treat_u <- so_merge_df %>%
  create_type_umaps(
    "tm_treat",
    x = "UMAP_1",
    y = "UMAP_2",
    size = 0.05,
    plot_lvls = u_lvls,
    clrs       = u_clrs,
    facet_plot = NULL,
    n_lab = TRUE
  )

# UMAP showing cell types
typ_u <- so_merge_df %>%
  create_type_umaps(
    "cell_type",
    x = "UMAP_1",
    y = "UMAP_2",
    clrs = type_cols,
    size = 0.05,
    facet_plot = NULL,
    n_lab = TRUE
  )

# Create final figure
u_fig <- plot_grid(
  treat_u, typ_u,
  align = "h",
  axis  = "tb",
  nrow  = 1,
  labels = c("A", "B"),
  label_size = ttl_pt2 * 1.5
)
```

```{r "GO figures", fig.width = 13, fig.height = 18}
top <- plot_grid(
  go_heat$`so_8-up`$heatmap, examples_8,
  labels = c("C", "D"),
  label_size = ttl_pt2 * 1.5,
  hjust  = c(-0.4, 1),
  vjust  = 0.98,
  nrow   = 1,
  align  = "h",
  axis   = "tb"
)

bot <- plot_grid(
  go_heat$`so_merge-up`$heatmap, examples_24,
  labels = c("E", "F"),
  label_size = ttl_pt2 * 1.5,
  hjust  = c(-0.4, 1),
  nrow   = 1,
  align  = "h",
  axis   = "tb"
)

plot_grid(
  u_fig, top, bot, other_examples,
  ncol = 1,
  rel_heights = c(0.8, 0.64, 1, 1)
)
```

<br>

### Extended GO analysis {.tabset .tabset-pills}

A.  Dendrogram showing gene ontology modules. GO terms were identified for each cell type and filtered as described for Fig 5. Terms were clustered into 5 modules based on the pairwise overlap between terms.
B.  Enrichment scores are shown for each GO module identified for each timepoint, as described in Fig 5.
C.  Top upregulated genes are shown for each GO module as described in Fig 5. Genes were sorted to 

```{r "EXPANDED FIGURES", fig.width = 16, fig.height = 19, results = "asis"}
# Split GO objects by cell type
go_type <- go %>%
  imap(~ {
    obj  <- .x
    typs <- unique(obj@compareClusterResult$Cluster)
    base <- str_remove(.y, "(?<=-).+")
    nms  <- str_c(base, c("all", as.character(typs)))
    
    l <- map(typs, ~ filter(obj, Cluster == .x))
    l <- append(list(obj), l)
    
    names(l) <- nms
    
    l
  }) %>%
  flatten()

# Create expanded GO figures
create_go_summary_figures <- function(go_in, sample_name, n_clsts = 5,
                                      n_terms = 6, n_genes = 4, pval = 0.05,
                                      qval = 0.2) {
  
  # Cluster GO terms
  # n_gns   <- ifelse(grepl(so_8_re, .y), 10, 20)
  ovlp    <- ifelse(grepl(so_8_re, sample_name), 3, 10)
  shrd    <- ifelse(grepl("-all$", sample_name), 2, 1)
  typ_plt <- !grepl("-all$", sample_name)
  
  clsts <- go_in %>%
    get_clusters(
      k         = n_clsts,
      n_overlap = ovlp,
      n_shared  = 1
    )
  
  if (is.null(clsts)) return(NULL)
  
  obj    <- str_remove(sample_name, "-.+$")
  obj    <- str_c(obj, "-up")
  go_typ <- go[[obj]]  # use objects containing all cell types for plotting
  
  # Create tree
  clst_ids <- as.character(unique(sort(clsts$clusters$cluster)))
  
  clst_clrs <- set_names(
    unname(type_cols)[1:n_distinct(clst_ids)],
    clst_ids
  )
  
  cl <- split(
    names(clsts$clusters_object),
    clsts$clusters_object
  )
  
  tr <- ggtree(clsts$object, linewidth = 1)
  
  clades <- cl %>%
    map_int(~ MRCA(tr, .x))
  
  tr <- groupClade(tr, clades, group_name = "cluster") +
    aes(color = cluster) +
    scale_color_manual(values = clst_clrs) +
    geom_tiplab(angle = 90, hjust = 1, nudge_x = -0.1) +
    layout_dendrogram() +
    theme(
      legend.position = "none",
      plot.margin = margin(6, 6, 250, 6)
    )
  
  # Create heatmaps
  heat <- clsts$clusters %>%
    create_go_heatmap(
      go_in      = go_typ,
      n_overlap  = ovlp,
      n_clusters = n_clsts,
      # n_genes    = n_gns,
      n_terms    = n_terms,
      n_col      = 1,
      free_y     = FALSE,
      clrs       = clst_clrs,
      exclude_cell_types = exclude_cell_types
    )
  
  heat$heatmap <- heat$heatmap +
    theme(axis.text = element_text(size = 10))
  
  # Select genes to plot
  n_gns <- seq_len(n_genes)
  go_gn <- go_typ
  
  if (typ_plt) go_gn <- go_in
  
  # Example genes to plot
  heat_terms <- heat$terms %>%
    dplyr::select(Description, cluster, ID)
  
  gns <- go_gn@compareClusterResult %>%
    as_tibble() %>%
    right_join(heat_terms, by = c("ID", "Description")) %>%  # only include genes for
                                                             # plotted terms
    mutate(geneID = str_split(geneID, "/")) %>%
    unnest(geneID) %>%
    
    # consider genes upregulated in cell types with significant overlap with
    # a plotted term
    mutate(                      
      sig_overlap = p.adjust < pval & qvalue < qval & Count >= ovlp
    ) %>%
    filter(!Cluster %in% exclude_cell_types) %>%
    group_by(geneID, cluster, sig_overlap) %>%
    summarize(n = n_distinct(Cluster), .groups = "drop") %>%
    group_by(geneID, cluster) %>%
    mutate(n = sum(n)) %>%
    ungroup() %>%
    distinct(geneID, .keep_all = TRUE) %>%
    arrange(cluster, desc(sig_overlap), desc(n))
  
  top_sig <- degs[[obj]] %>%
    filter(gene %in% gns$geneID) %>%
    group_by(gene) %>%
    summarize(pval = min(max_pval), .groups = "drop")
  
  gns <- gns %>%
    left_join(top_sig, by = c(geneID = "gene")) %>%
    arrange(desc(sig_overlap), desc(n), pval) %>%
    group_by(cluster) %>%
    dplyr::slice(n_gns) %>%
    ungroup()
  
  gns <- set_names(as.character(gns$cluster), gns$geneID)

  # gns <- go_gn@compareClusterResult %>%
  #   as_tibble() %>%
  #   right_join(heat$terms, by = "Description") %>%
  #   mutate(geneID = str_split(geneID, "/")) %>%
  #   unnest(geneID) %>%
  #   group_by(geneID, cluster) %>%
  #   summarize(n = n_distinct(Cluster), .groups = "drop") %>%
  #   distinct(geneID, .keep_all = TRUE) %>%
  #   arrange(cluster, desc(n)) %>%
  #   group_by(cluster) %>%
  #   dplyr::slice(n_gns) %>%
  #   ungroup()
  # 
  # gns <- set_names(
  #   as.character(gns$cluster),
  #   gns$geneID
  # )
  
  # Create gene plots
  gn_plts <- create_gene_plots(
    exp_data   = list("8hpi" = so_8, "24hpi" = so_merge),
    deg_data   = list("8hpi" = degs$`so_8-up`, "24hpi" = degs$`so_merge-up`),
    gns        = gns,
    cell_types = 8,
    clrs       = clst_clrs,
    exclude_cell_types = exclude_cell_types
  ) +
    theme(
      plot.margin = margin(6, 40, 6, 40, unit = "pt"),
      axis.text   = element_text(size = 7),
      strip.text  = element_text(size = 8)
    )
  
  # Create final figure
  bot <- plot_grid(
    heat$heatmap + theme(plot.margin = margin(6, 40, 6, 40, unit = "pt")),
    gn_plts,
    nrow = 1,
    labels = c("B", "C"),
    rel_widths = c(0.9, 1),
    align = "h",
    axis  = "tb"
  )
  
  res <- plot_grid(
    tr, bot,
    ncol = 1,
    rel_heights = c(0.3, 1),
    labels = "A"
  )
  
  res
}

go_type[grepl("-all$", names(go_type))] %>%
  iwalk(~ {
    ttl <- str_remove(.y, "^so_")
    ttl <- str_replace(ttl, "^merge", "24hpi-8hpi")
    
    cat("\n\n#### ", ttl, "\n\n")
    
    plt <- create_go_summary_figures(
      go_in       = .x,
      sample_name = .y,
    )
    
    if (is.null(plt)) {
      plt <- ggplot() +
        geom_blank()
    }
    
    print(plt)
    cat("\n\n<br>\n\n")
  })
```

### Cluster similarity

The similarity between GO clusters identified for the 8 and 24 hpi timepoints is shown below.

```{r "cluster similarity heatmap", fig.width = 8, fig.height = 4}
sim_heatmap
```


