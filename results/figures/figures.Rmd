---
title: "CHIKV LNSC figures"
author: "Ryan Sheridan"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc:       true
    toc_float: true
    toc_depth: 2
    theme:     cosmo
    highlight: kate
params:
  
  
  src_dir:      "src"
  so_dir:       "~/Dropbox/Ryan/Projects/morrison-lnsc/results/sobjs"
  table_dir:    "results/tables"
  geo_dir:      "results/geo"
  so_24:        "~/Dropbox/Ryan/Projects/morrison-scRNA-seq/results/2021-01-08/sobjs/so.rds"
  tm:           "8hpi"                    # Timepoint label
  unenr_dir:    "results/2021-04-16"      # Directory for unenriched data
  enr_dir:      "results/2021-07-16"      # Directory for CHIKV-enriched data
  gene_min:     250                       # Min number of detected genes per cell
  gene_max:     8000                      # Max number of detected genes per cell
  mito_max:     20                        # Max percentage mito reads per cells
  type_res:     10                        # Clustering resolution for annotating cell types
  frc_res:      3                         # Clustering resolution for annotating fibroblasts
  lec_res:      11.5                      # Clustering resolution for annotating LECs
  lec_n_genes:  1500                      # Number of variable genes for annotating LECs
editor_options: 
  chunk_output_type: inline
---

<br>

```{r "chunk opts", include = FALSE}
# Default chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo    = FALSE,
  dpi     = 500
)

knitr::knit(here::here(params$src_dir, "setup.Rmd"), "")
```

## Figure 1

Chikungunya virus is found in MARCO-expressing floor lymphatic endothelial cells
in the draining lymph node at 8 hpi

A.  UMAP projection shows the relative viral burden for the 8 hpi timepoint. CHIKV score was calculated using the CHIKV-capture libraries. For each cell the number of counts aligning to the CHIKV genome was divided by the total counts (mouse + CHIKV counts) for the cell. A pseudo count (smallest non-zero value / 2) was added to each value plotted.
B.  UMAP projection shows CHIKV+ cells (CHIKV score >0) for the 8 hpi timepoint. Cell types with <=3 CHIKV+ cells are labeled as "other".
C.  CHIKV scores (as described in A) are shown for CHIKV+ cell types with >40 total cells and >3 CHIKV+ cells for the 8 hpi sample. P values were calculated using a one-sided Wilcoxon rank sum test with Bonferroni correction to assess whether CHIKV scores for each cell type were elevated when compared with all other CHIKV+ cells. Only adjusted p values <0.05 are shown. For each boxplot, the central lines, box limits, and whiskers represent medians, the interquartile range (IQR), and min/max values that are not outliers, respectively. Outliers are shown as points and include any values that are more than 1.5Ã— IQR away from the box.
D.  The fraction of cells identified as CHIKV+ is shown for each cell type in C. Labels show the number of CHIKV+ cells/total cells. P values were calculated using a one-sided hypergeometric test with Bonferroni correction to assess whether the frequency of CHIKV+ cells was greater than expected for each cell type. Only adjusted p values <0.05 are shown.
E.  MARCO expression is shown for fLECs for mock-infected cells and CHIKV-infected cells classified as either CHIKV- or CHIKV+. P values were calculated using a two-sided Wilcoxon rank-sum test with Bonferroni correction. Boxplots were drawn as described in C.
F.  Madcam1 expression is shown for fLECs as described in E.

```{r "CHIKV score umap", fig.width = 10, fig.height = 10}
# Format plot data
score_clmn <- c(enr_pct_CHIKV = "CHIKV score")

fig1_dat <- so_8@meta.data %>%
  as_tibble(rownames = ".cell_id") %>%
  arrange(!!sym(names(score_clmn)))

# Coordinates for circle annotation
circ_coords <- fig1_dat %>%
  filter(lec_type == "fLEC") %>%
  summarize(
    x   = mean(UMAP_1),
    y   = mean(UMAP_2),
    rad = diff(range(UMAP_1))
  )

# Create UMAP
# add pseudo count since scale will be log-transformed
# smallest non-zero value divided by 2
pseudo <- fig1_dat[[names(score_clmn)]]
pseudo <- min(pseudo[pseudo > 0]) / 2

chikv_score_umap <- fig1_dat %>%
  ggplot(aes(UMAP_1, UMAP_2, fill = !!sym(names(score_clmn)) + pseudo)) +
  geom_point_trace(
    color = "grey",
    trace_position = "bottom"
  ) +
  geom_circle(
    aes(x0 = x, y0 = y, r = rad, x = NULL, y = NULL),
    data      = circ_coords,
    fill      = NA,
    color     = "black",
    linetype  = 2,
    linewidth = 0.75
  ) +
  scale_fill_gradientn(
    colours = c("white", "#D7301F"),
    trans   = "log10",
    labels  = scales::label_number()
  ) +
  guides(fill = guide_colorbar(
    title.position = "top", ticks = FALSE, title = score_clmn
  )) +
  
  ggtitle("CHIKV score") +
  umap_theme +
  theme(
    plot.title           = element_text(size = ttl_pt2 * 1.5, hjust = 0.2),
    legend.title         = element_blank(),
    legend.position      = "top",
    legend.text          = element_text(angle = 45, hjust = 1), 
    legend.direction     = "horizontal",
    legend.justification = 0.2,
    legend.key.width     = unit(30, "pt"),
    legend.key.height    = unit(5, "pt")
  )
```

```{r "CHIKV+ cell types umap", fig.width = 10, fig.height = 10}
# Format plot data
# only show cells with >3 CHIKV+ cells, show remaining as "other"
chikv_pos_dat <- fig1_dat %>%
  filter(chikv_grp == chikv_grps[2]) %>%
  group_by(lec_type) %>%
  mutate(lec_type = ifelse(n() > 3, lec_type, "other")) %>%
  ungroup()

plt_labs <- get_nlab_fun(chikv_pos_dat, "lec_type", l = "\n", r = "")
plt_labs <- plt_labs()
plt_labs <- map_chr(plt_labs, type_lab_fn)
plt_labs <- plt_labs[c(names(plt_labs)[names(plt_labs) != "other"], "other")]

chikv_pos_dat <- chikv_pos_dat %>%
  mutate(lec_type = fct_relevel(lec_type, names(plt_labs)))

# Create UMAP
chikv_typs_umap <- so_8@meta.data %>%
  ggplot(aes(UMAP_1, UMAP_2)) +
  geom_point_trace(
    color = "grey",
    fill  = "white",
    trace_position = "bottom"
  ) +
  geom_point(aes(color = lec_type), data = chikv_pos_dat) +
  geom_circle(
    aes(x0 = x, y0 = y, r = rad, x = NULL, y = NULL),
    data      = circ_coords,
    fill      = NA,
    color     = "black",
    linetype  = 2,
    linewidth = 0.75
  ) +
  
  scale_color_manual(values = lec_type_cols, labels = plt_labs) +
  scale_y_discrete(labels = type_lab_fn) +
  guides(color = guide_legend(override.aes = list(size = 4))) +
  labs(title = "CHIKV+ cell types") +
  umap_theme +
  theme(
    plot.title           = element_text(size = ttl_pt2 * 1.5, hjust = 0.2),
    legend.title         = element_blank(),
    legend.key.height    = unit(35, "pt"),
    legend.justification = "bottom",
    legend.text          = element_text(size = ttl_pt1)
  )
```

```{r "Fraction CHIKV+ boxes"}
# Fraction CHIKV+ cells
# only include CHIKV samples
frac_dat <- fig1_dat %>%
  filter(treatment == treats[2]) %>%
  group_by(lec_type) %>%
  summarize(
    type_n    = length(chikv_grp[chikv_grp == chikv_grps[2]]),
    type_tot  = n(),
    type_frac = type_n / type_tot,
    .groups   = "drop"
  ) %>%
  mutate(
    n     = sum(type_n),
    tot   = sum(type_tot),
    frac  = n / tot,
    n_lab = label_comma()(type_tot),
    n_lab = str_c(lec_type, "\nn = ", type_n, "/", n_lab),
    n_lab = str_replace(n_lab, "_", " ")
  ) %>%
  mutate(lec_type = fct_reorder(lec_type, type_frac, max, .desc = TRUE))

n_lab <- set_names(frac_dat$n_lab, frac_dat$lec_type)

# Perform hypergeometric test
frac_dat <- frac_dat %>%
  group_by(lec_type) %>%
  mutate(p_val = .calc_fisher(
    x = type_n,
    k = type_tot,
    m = n,
    n = tot - n
  )) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p_val, method = "bonferroni")) %>%
  rowwise() %>%
  mutate(p_lab = .format_pvalue(p_adj)) %>%
  ungroup() %>%
  arrange(p_adj)

# Filter cells for plotting
# only plot cell types with >40 total cells, >3 CHIKV+ cells
# use frac_lvls to filter cell types for fig 1C
frac_dat <- frac_dat %>%
  filter(type_tot > 40, type_n > 3)

frac_lvls <- levels(frac_dat$lec_type)
frac_lvls <- frac_lvls[frac_lvls %in% frac_dat$lec_type]

# Create bargraphs
frac_8 <- frac_dat %>%
  ggplot(aes(lec_type, type_frac, fill = lec_type, color = lec_type)) +
  geom_col(
    width = 0.55, linewidth = 1, alpha = 0.5,
    position = position_dodge2(padding = 0.12)
  ) +
  
  geom_text(
    aes(label = p_lab),
    data = ~ filter(.x, p_adj < 0.05),
    color = "black", vjust = -0.3, hjust = 0.4, parse = TRUE
  ) +
  
  scale_fill_manual(values = lec_type_cols) +
  scale_color_manual(values = lec_type_cols) +
  scale_x_discrete(labels = n_lab) +
  scale_y_continuous(breaks = seq(0, 1, 0.1), expand = expansion(c(0.05, 0.3))) +
  labs(y = "Fraction\nCHIKV+ cells") +
  base_theme +
  theme(
    axis.text.y = element_text(size = txt_pt1),
    axis.text.x = element_text(size = ttl_pt1, angle = 45, hjust = 1),
    axis.title.x = element_blank(),
    legend.position = "none",
  )
```

```{r "CHIKV score boxes", fig.width = 10, fig.height = 5}
# Calculate p-values
# only calculate p-values for cell types included in fraction bargraphs
# alternative hypothesis is that group1 is greater
# use bonferroni correction, only show p-values <0.05
bx_dat <- fig1_dat %>%
  filter(chikv_grp == chikv_grps[2])

p_dat <- bx_dat %>%
  filter(lec_type %in% frac_lvls) %>%
  pull(lec_type) %>%
  unique() %>%
  map_dfr(~ {
    d <- bx_dat %>%
      mutate(p_type = ifelse(lec_type == .x, lec_type, "other")) %>%
      split(.$p_type)

    typ_dat <- d[[.x]][[names(score_clmn)]]
    oth_dat <- d[["other"]][[names(score_clmn)]]

    p <- wilcox.test(typ_dat, oth_dat, alternative = "greater")
    p <- tidy(p)

    p %>%
      mutate(
        lec_type = .x,
        n        = length(typ_dat),
        med      = median(typ_dat),
        mean     = mean(typ_dat),
        max      = max(typ_dat),
        sd       = sd(typ_dat)
      )
  }) %>%
  arrange(p.value) %>%
  mutate(p_adj = p.adjust(p.value, method = "bonferroni")) %>%
  filter(p_adj < 0.05) %>%
  rowwise() %>%
  mutate(p_lab = .format_pvalue(p_adj)) %>%
  ungroup()

# Create boxplots
# Only plot CHIKV+ cells for cell types shown in Fig 1D bargraphs
count_bxs <- bx_dat %>%
  filter(lec_type %in% frac_lvls) %>%
  mutate(lec_type = fct_relevel(lec_type, frac_lvls)) %>%
  
  ggplot(aes(lec_type, !!sym(names(score_clmn)), fill = lec_type, color = lec_type)) +
  geom_boxplot(
    size = 1, outlier.size = 1.5, outlier.alpha = 1,
    alpha = 0.5, width = 0.55,
    position = position_dodge2(padding = 0.12)
  ) +
  
  geom_text(
    aes(y = max, label = p_lab),
    data = p_dat,
    color = "black", vjust = -1, hjust = 0.4, parse = TRUE
  ) +
  
  scale_y_continuous(expand = expansion(c(0.05, 0.2)), trans = "log10") +
  scale_fill_manual(values = lec_type_cols) +
  scale_color_manual(values = lec_type_cols) +
  labs(y = score_clmn) +
  base_theme +
  theme(
    plot.margin     = margin(5, 5, 5, 35),
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.title.y    = element_text(size = ttl_pt2),
    axis.text.x     = element_blank(),
    axis.ticks.x    = element_blank()
  )

count_bxs <- plot_grid(
  count_bxs, frac_8,
  labels = c("C", "D"), label_size = ttl_pt2 * 1.5,
  align = "v", axis = "rl",
  ncol = 1,
  rel_heights = c(1, 1)
)
```

```{r "fig 1 examples", fig.width = 3, fig.height = 5}
plt_dat <- so_8 %>%
  mutate_meta(
    mutate,
    chikv_grp = recode(
      chikv_grp,
      `CHIKV-low` = "CHIKV-",
      `CHIKV-high` = "CHIKV+"
    )
  )

plt_lvls <- c("mock", "CHIKV-", "CHIKV+")

marco_bxs <- plt_dat %>%
  create_gene_boxplot(
    GENE = "Marco", TYPE = "fLEC",
    clr = "#D7301F", lvls = plt_lvls
  )

madcam_bxs <- plt_dat %>%
  create_gene_boxplot(
    GENE = "Madcam1", TYPE = "fLEC",
    clr = "#E69F00", lvls = plt_lvls
  )
```

```{r "fig 1", fig.width = 16, fig.height = 12}
top <- wrap_plots(
  chikv_score_umap, plot_spacer(), chikv_typs_umap,
  widths = c(1, 0.05, 1)
) +
  plot_annotation(tag_levels = "A") &
  theme(plot.tag = element_text(size = ttl_pt2 * 1.5, face = "bold"))

bot <- plot_grid(
  count_bxs, NULL, marco_bxs, NULL, madcam_bxs, NULL,
  labels = c("", "", "E", "", "F"),
  label_size = ttl_pt2 * 1.5,
  nrow   = 1,
  rel_widths = c(1, 0.05, 0.36, 0.05, 0.36, 0.4)
)

plot_grid(
  top, NULL, bot,
  ncol = 1,
  rel_heights = c(1, 0.05, 0.7)
)
```

---

<br>

<br>

## Figure S2

```{r "UMAPs", fig.width = 10, fig.height = 10}
# Format data
figS2_dat <- so_24@meta.data %>%
  as_tibble(rownames = "cell_id") %>%
  arrange(sgRNA_ratio_pseudo)

# Coordinates for circle
circ_coords <- figS2_dat %>%
  filter(
    treatment == treats[2],
    cell_type_2 == "LEC"
  ) %>%
  summarize(
    x   = mean(UMAP_1) - 0.25,
    y   = mean(UMAP_2),
    rad = diff(range(UMAP_1))
  )

# Cell type UMAP
type_umap <- figS2_dat %>%
  plot_scatter(
    "lec_type",
    plot_colors  = lec_type_cols,
    plot_lvls    = c("FRC", "unassigned-LEC", "Marco_LEC", "fLEC"),
    size         = 0.2,
    label_params = list(size = ttl_pt2)
  ) +
  geom_circle(
    aes(x0 = x, y0 = y, r = 2, x = NULL, y = NULL),
    data      = circ_coords,
    fill      = NA,
    color     = "black",
    linetype  = 2,
    linewidth = 0.75
  ) +
  guides(color = guide_legend(nrow = 5, override.aes = list(size = 4))) +
  umap_theme +
  theme(
    legend.title = element_blank(),
    legend.position = "top"
    # legend.key.height = unit(30, "pt")
  )
  
# sgRNA ratio UMAP
sgRNA_umap <- figS2_dat %>%
  ggplot(aes(UMAP_1, UMAP_2, fill = sgRNA_ratio_pseudo)) +
  geom_point_trace(
    color = "grey",
    trace_position = "bottom",
    size = 0.5
  ) +
  geom_circle(
    aes(x0 = x, y0 = y, r = 2, x = NULL, y = NULL),
    data      = circ_coords,
    fill      = NA,
    color     = "black",
    linetype  = 2,
    linewidth = 0.75
  ) +
  scale_fill_gradientn(
    colours = c("white", "#0072B2", "#002037"),
    labels = scales::label_number()
  ) +
  guides(fill = guide_colorbar(
    title.position = "top", ticks = FALSE, title = "CHIKV sgRNA ratio"
  )) +
  umap_theme +
  theme(
    aspect.ratio         = 0.9,
    legend.position      = "top",
    legend.title         = element_text(hjust = 0.5, size = ttl_pt2),
    legend.direction     = "horizontal",
    legend.justification = 0.5,
    legend.key.width     = unit(30, "pt"),
    legend.key.height    = unit(5, "pt")
  )
```

```{r "scatter plots", fig.width = 10, fig.height = 7}
# Only plot CHIKV-high cells
# do not include any CHIKV-low cells since they have been filtered
# stringently based on QC and CHIKV-high cells have not. Including CHIKV-low
# cells would influence correlations

# Stats to plot
y_vars <- c(
  "# mouse genes\nexpressed" = "nFeature_RNA",
  "% mitochondrial\nreads"   = "pct_mito"
)

x_var <- c("CHIKV sgRNA ratio" = "sgRNA_ratio_pseudo")
typs  <- c("Marco_LEC", "unassigned-LEC")

# Format scatter plot data
plt_dat <- figS2_dat %>%
  filter(
    chikv_grp == chikv_grps[2],
    lec_type %in% typs
  ) %>%
  mutate(lec_type = fct_relevel(lec_type, typs)) %>%
  dplyr::rename(!!!syms(y_vars)) %>%
  pivot_longer(all_of(names(y_vars)))

# Scatter plots
scatter <- plt_dat %>%
  split(.$name) %>%
  imap(~ {
    log_trans <- grepl("mouse genes", .y)
    
    y_fn    <- function(x) x
    y_trans <- "identity"
    
    if (log_trans) {
      y_fn    <- log10
      y_trans <- "log10"
    }
    
    n_lab <- get_nlab_fun(.x, "lec_type", l = "\n", r = "")
    
    cor_dat <- .x %>%
      summarize(
        cor = list(tidy(cor.test(
          log10(!!sym(unname(x_var))), y_fn(value),
          method = "pearson",
          alternative = "two.sided"
        ))),

        pval = map_dbl(cor, pull, p.value),
        pval = format_pvalue(pval),
        pval = str_c("italic(p) == ", pval),
        cor  = map_dbl(cor, pull, estimate),
        cor  = str_c("italic(r) == ", round(cor, 2))
      )

    .x %>%
      ggplot(aes(!!sym(unname(x_var)), value, color = lec_type)) +
      geom_point() +
      geom_smooth(
        method = "lm", formula = y ~ x,
        color = "black", linewidth = 0.5, linetype = 2, alpha = 0.2
      ) +
      geom_text(
        aes(Inf, Inf, label = cor),
        data = cor_dat,
        parse = TRUE,
        hjust = 1.2, vjust = 1.2,
        color = "black"
      ) +
      scale_color_manual(values = lec_type_cols, labels = n_lab) +
      scale_x_log10() +
      scale_y_continuous(trans = y_trans, expand = expansion(c(0.05, 0.10))) +
      guides(color = guide_legend(override.aes = list(size = 4))) +
      labs(x = names(x_var), y = .y) +
      base_theme +
      theme(
        aspect.ratio    = 0.9,
        legend.position = "right",
        legend.title    = element_blank(),
        legend.text     = element_text(size = ttl_pt2),
        legend.key.height = unit(50, "pt"),
        axis.text.x     = element_text(size = txt_pt1),
        axis.text.y     = element_text(size = txt_pt1)
      )
  })

# Create final figure
scatter <- scatter %>%
  wrap_plots(
    byrow = FALSE, ncol = 1, guides = "collect"
  )
```

```{r "fraction CHIKV-high"}
# Fraction CHIKV-high cells
frac_dat <- figS2_dat %>%
  filter(treatment == treats[2]) %>%
  group_by(lec_type, rep) %>%
  summarize(
    rep_n    = length(chikv_grp[chikv_grp == chikv_grps[2]]),
    rep_tot  = n(),
    rep_frac = rep_n / rep_tot,
    .groups  = "drop"
  ) %>%
  group_by(lec_type) %>%
  mutate(
    type_n    = sum(rep_n),
    type_tot  = sum(rep_tot),
    type_frac = type_n / type_tot,
    n_lab     = label_comma()(type_tot),
    n_lab     = str_c(lec_type, "\nn = ", type_n, "/", n_lab),
    n_lab     = str_replace(n_lab, "_", " ")
  ) %>%
  ungroup() %>%
  mutate(
    n        = sum(rep_n),
    tot      = sum(rep_tot),
    frac     = n / tot,
    lec_type = fct_reorder(lec_type, type_frac, max, .desc = TRUE)
  )

# Perform hypergeometric test
p_dat <- frac_dat %>%
  group_by(lec_type, type_n, type_tot, tot, n, n_lab) %>%
  summarize(rep_frac = max(rep_frac), .groups = "drop") %>%
  group_by(lec_type) %>%
  mutate(p_val = .calc_fisher(
    x = type_n,
    k = type_tot,
    m = n,
    n = tot - n
  )) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p_val, method = "bonferroni")) %>%
  rowwise() %>%
  mutate(p_lab = .format_pvalue(p_adj)) %>%
  ungroup() %>%
  arrange(p_adj)

# Create bargraphs
# Only include cell types with >40 total cells, >3 CHIKV-high cells
n_lab <- set_names(p_dat$n_lab, p_dat$lec_type)

frac_24 <- frac_dat %>%
  filter(type_tot > 40, type_n > 3) %>%
  ggplot(aes(lec_type, rep_frac, fill = lec_type, color = lec_type)) +
  geom_col(
    position = position_dodge2(padding = 0.12),
    alpha = 0.5
  ) +
  
  geom_text(
    aes(label = p_lab),
    data = filter(p_dat, p_adj < 0.05),
    color = "black", vjust = -1, hjust = 0.4,
    size = 10 / .pt,
    parse = TRUE
  ) +
  
  scale_fill_manual(values = lec_type_cols) +
  scale_color_manual(values = lec_type_cols) +
  scale_x_discrete(labels = n_lab) +
  scale_y_continuous(expand = expansion(c(0.05, 0.3))) +
  labs(y = "Fraction\nCHIKV-high cells") +
  base_theme +
  theme(
    axis.text.y     = element_text(size = txt_pt1, color = "black"),
    axis.text.x     = element_text(size = txt_pt2, angle = 45, hjust = 1, color = "black"),
    axis.title.x    = element_blank(),
    legend.position = "none",
    aspect.ratio    = 0.25,
    plot.margin     = margin(25, 5, 5, 15)
  )
```

```{r "sgRNA ratio violins"}
# Format sgRNA ratio data
# Only include cell types with >40 total cells after filtering
# For figure S2B a pseudo count of 1 was added to both sgRNA and 5' counts to
# eliminate division by zero
# For violin plots do not need to add pseudo count since we are filtering to
# remove cells with 0 counts
bx_dat <- figS2_dat %>%
  filter(CHIKV_sgRNA > 0, CHIKV_5 > 0) %>%
  group_by(lec_type) %>%
  filter(n() > 40) %>%
  ungroup()

# Create violin plots
bx_lvls <- bx_dat %>%
  group_by(lec_type) %>%
  summarize(
    med = median(sgRNA_ratio),
    q3  = quantile(sgRNA_ratio, 0.75),
    max = max(sgRNA_ratio),
    .groups = "drop"
  ) %>%
  arrange(desc(med), desc(q3), desc(max)) %>%
  pull(lec_type)

sgRNA_boxes <- bx_dat %>%
  plot_violin(
    "sgRNA_ratio",
    cluster_col = "lec_type",
    plot_colors = lec_type_cols,
    plot_lvls   = bx_lvls,
    scale       = "width",
    draw_quantiles = c(0.25, 0.75)
  ) +
  scale_y_continuous(trans = "log10", expand = expansion(c(0.05, 0.15))) +
  labs(y = "CHIKV\nsgRNA ratio") +
  base_theme +
  theme(
    aspect.ratio    = 0.32,
    plot.margin     = margin(5, 5, 0, 15),
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.text.x     = element_text(size = txt_pt2, angle = 45, hjust = 1, color = "black"),
    axis.text.y     = element_text(size = txt_pt1, color = "black"),
  )

# Calculate p-values
# p-values are corrected for all comparisons
# write table with all p-values
bx_p_vals <- bx_dat %>%
  calc_p_vals(
    data_column = "sgRNA_ratio",
    type_column = "lec_type"
  )

p_file <- here(params$table_dir, "figS2_sgRNA_pval.tsv")

bx_p_vals %>%
  write_tsv(p_file)

# Comparisons for p-value labels
bx_comps <- bx_lvls %>%
  imap(~ {
    tp2 <- bx_lvls[.y + 1]

    if (!is.na(tp2)) c(.x, tp2)
  }) %>%
  Filter(negate(is.null), .)

# Add p-value labels
bx_comps %>%
  walk(~ {
    p <- bx_p_vals %>%
      filter(`Cell type 1` %in% .x & `Cell type 2` %in% .x) %>%
      pull(p_adj)
    
    sgRNA_boxes <<- sgRNA_boxes %>%
      add_pvals(
        x        = .x[1],
        xend     = .x[2],
        y        = 500,
        p_y      = 1500,
        p_val    = p,
        size     = 10 / .pt,
        line_col = "grey75"
      )
  })
```

CHIKV may target MARCO-expressing LECs for infection

A.  UMAP projection shows annotated cell types for the 24 hpi timepoint.
B.  UMAP projection shows CHIKV sgRNA ratio (sgRNA counts / 5' counts) for the 24 hpi timepoint. A pseudo count of 1 was added to the sgRNA and 5' counts.
C.  The fraction of cells identified as CHIKV-high is shown for each biological replicate for cell types with >40 total cells and >3 CHIKV-high cells for the 24 hpi timepoint. Labels show the number of CHIKV-high cells/total cells. P values were calculated using a one-sided hypergeometric test as described in figure 1D.
D.  CHIKV sgRNA ratio is shown for cells with >0 sgRNA counts, >0 5' counts, and >40 total cells. P values were calculated using a two-sided Wilcoxon rank sum test with Bonferroni correction. For each violin plot, the central point and flanking lines represent medians and the interquartile range (IQR), respectively.
E.  The correlation between CHIKV sgRNA ratio and QC metrics is shown for CHIKV-high cells for Marco LECs and unassigned LECs.

```{r "fig S2", fig.width = 13, fig.height = 13.7}
top <- wrap_plots(
  type_umap, sgRNA_umap,
  nrow = 1
) +
  plot_annotation(tag_levels = "A") &
  theme(plot.tag = element_text(size = ttl_pt2 * 1.5, face = "bold"))

left <- plot_grid(
  frac_24, sgRNA_boxes,
  labels = c("C", "D"), label_size = ttl_pt2 * 1.5,
  align = "v", axis = "rl",
  ncol = 1
)

bot <- plot_grid(
  left, scatter,
  labels = c("", "E"), label_size = ttl_pt2 * 1.5,
  rel_widths = c(1, 0.75),
  nrow = 1
)

plot_grid(
  top, bot,
  rel_heights = c(1, 0.8),
  ncol = 1
)
```

---

<br>

<br>

## Figure S3

A.  UMAP projection shows cell type annotations for integrated data.
B.  UMAP projection shows endothelial cell type annotations for integrated endothelial cell data.
C.  The correlation between annotated endothelial subsets and reference data is shown.
D.  The expression of select marker genes is shown for the 8 hpi and 24 hpi timepoints.

```{r "fig S3 cell type UMAPs", fig.width = 12, fig.height = 6}
plt_args <- list(
  so_in    = list(so_merge_df, so_lec),
  data_col = c("cell_type", "lec_subtype"),
  clrs     = list(type_cols, lec_type_cols),
  ttl      = c("Cell types", "Endothelial cell types")
)

type_umaps <- plt_args %>%
  pmap(~ {
    args <- list(...)
    
    create_type_umaps(
      so_in      = args$so_in,
      data_col   = args$data_col,
      facet_plot = c("tm", "treatment"),
      clrs       = args$clrs,
      size       = 0.001,
      ttl        = args$ttl
    ) +
      guides(color = guide_legend(nrow = 3, override.aes = list(size = 4))) +
      theme(
        legend.position = "bottom",
        legend.text     = element_text(size = txt_pt2)
      )
  })

# Create final figure
type_fig <- plot_grid(
  plotlist = type_umaps,
  align = "h",
  axis  = "tb",
  nrow  = 1,
  labels = c("A", "B"),
  label_size  = ttl_pt2 * 1.5
)
```

```{r "fig S3 cell type heatmaps", fig.width = 8, fig.height = 5}
# Calculate correlations using combined data for all samples
# Format heatmap data
h_dat <- so_lec %>%
  mutate_meta(
    mutate,
    lec_type = lec_subtype,
    lec_type = recode(lec_type, unassigned = "unassigned-LEC")
  )

rm(so_lec)

h_mat <- h_dat %>%
  clustify(
    ref_mat        = ref_lec,
    cluster_col    = "lec_type",
    seurat_out     = FALSE,
    compute_method = "spearman",
    n_genes        = 2000
  ) %>%
  as_tibble(rownames = "assigned_type") %>%
  pivot_longer(
    cols      = -assigned_type,
    names_to  = "ref_type",
    values_to = "r"
  )

# Format LEC types labels
typs <- h_dat@meta.data %>%
  group_by(lec_type) %>%
  dplyr::filter(n() > 10) %>%
  pull(lec_type) %>%
  unique()

lec_labs <- h_dat %>%
  subset(lec_type %in% typs) %>%
  get_nlab_fun("lec_type", l = "\n", r = "")
  
# Create heatmaps
type_heats_v2 <- h_mat %>%
  create_cor_heatmap(ln_clr = fade_0) +
  theme(
    axis.text.x = element_text(size = txt_pt2),
    axis.text.y = element_text(size = txt_pt2),
    axis.title  = element_text(size = ttl_pt2)
  )

heats_fig <- plot_grid(
  type_heats_v2, NULL,
  labels     = c("C", ""),
  label_size = ttl_pt2 * 1.5
)
```

```{r "fig S3 type examples extended", fig.width = 10, fig.height = 6.5}
gns <- c(
  "Lyve1", "Marco",    # Marco LECs
  "Madcam1", "Vcam1",  # fLECs
  "Ptx3",              # Ptx3 LECs
  "Ackr4"              # cLECs
)

# Format data
typ_bx_dat <- list("8hpi" = so_8, "24hpi" = so_24) %>%
  imap_dfr(~ {
    clmns <- c(
      "cell_type", "lec_type", "frc_type",
      "treatment", "tm_treat", "orig.ident", "rep", "chikv_grp",
      gns
    )
    
    .x %>%
      FetchData(clmns) %>%
      as_tibble(rownames = "cell_id") %>%
      mutate(
        tm = .y,
        tm = fct_relevel(tm, tms),
        tm_treat = fct_relevel(tm_treat, unlist(map(tms, str_c, "-", treats)))
      )
  })

# Create boxplots
type_boxes <- gns %>%
  map(~ {
    lvls <- typ_bx_dat %>%
      group_by(lec_type) %>%
      summarize(
        stats = list(boxplot.stats(!!sym(.x))),
        med   = map_dbl(stats, ~ .x$stats[3]),
        q3    = map_dbl(stats, ~ .x$stats[4]),
        q4    = map_dbl(stats, ~ .x$stats[5]),
        mx    = max(!!sym(.x))
      ) %>%
      arrange(med, q3, q4, mx) %>%
      pull(lec_type) %>%
      rev()
      
    typ_bx_dat %>%
      mutate(
        lec_type = fct_relevel(lec_type, lvls),
        chikv_grp = fct_relevel(chikv_grp, chikv_grps)
      ) %>%
      ggplot(aes(lec_type, !!sym(.x), color = lec_type, fill = lec_type, alpha = chikv_grp)) +
      geom_boxplot(
        size = 0.25, color = "black",
        outlier.size = 0.01, outlier.alpha = 0.1,
        position = position_dodge2(preserve = "single"),
        key_glyph = draw_key_point,
      ) +
      scale_color_manual(values = lec_type_cols) +
      scale_fill_manual(values = lec_type_cols) +
      scale_alpha_manual(values = c(`CHIKV-low` = 0.5, `CHIKV-high` = 1)) +
      scale_x_discrete(labels = type_lab_fn) +
      facet_wrap(~ tm_treat, ncol = 1) +
      labs(y = str_c(.x, " expression")) +
      guides(
        fill = "none", color = "none",
        alpha = guide_legend(
          override.aes = list(shape = 15, fill = "black", size = 4)
        )
      ) +
      base_theme +
      theme(
        aspect.ratio    = 0.15,
        legend.position = "top",
        legend.title    = element_blank(),
        legend.text     = element_text(size = ttl_pt1),
        axis.title.x    = element_blank(),
        axis.text.x     = element_text(size = txt_pt2, angle = 90, hjust = 1, vjust = 0.5),
        axis.text.y     = element_text(size = txt_pt1 * 0.75),
        strip.text      = element_text(size = txt_pt2)
      )
  })

type_boxes <- type_boxes %>%
  wrap_plots(nrow = 2, guides = "collect") &
  theme(legend.position = "top")
```

```{r "fig S3", fig.width = 12, fig.height = 20}
plot_grid(
  type_fig, heats_fig, type_boxes,
  rel_heights = c(0.9, 0.4, 1.2),
  labels      = c("", "", "D"),
  label_size  = ttl_pt2 * 1.5,
  ncol        = 1
)
```

---

<br>

<br>

## Figure 5

```{r "DEGs"}
# Create merged object to compare CHIKV 24 hpi with 8 hpi
# only use top two 24 hpi biological replicates with the most cells
# set replicate names to match 8 hpi, this is required by FindConservedMarkers()
top_reps <- as.character(so_24$rep) %>%
  table() %>%
  sort() %>%
  tail(2) %>%
  names() %>%
  sort()

new_reps <- set_names(
  seq_along(top_reps), top_reps
)

so_merge <- so_24 %>%
  subset(treatment == "CHIKV") %>%
  subset(rep %in% names(new_reps)) %>%
  mutate_meta(
    mutate,
    rep = recode(rep, !!!new_reps),
    treatment = tm
  )
  
so_merge <- so_8 %>%
  subset(treatment == "CHIKV") %>%
  mutate_meta(mutate, treatment = tm) %>%
  merge(so_merge)

# Create objects to compare CHIKV-low/-high cells
so_8_chikv <- so_8 %>%
  subset(treatment == "CHIKV")

so_24_chikv <- so_24 %>%
  subset(treatment == "CHIKV")

# Identify up/down regulated genes
# use FindConservedMarkers()
# genes are filtered based on log_fc and maximum raw p-value (not adjusted)
deg_args <- tribble(
  ~so_in,        ~type_clmn, ~treat_clmn, ~ident_1,     ~ident_2,    ~log_fc,
  "so_8",        "lec_type", "treatment", "CHIKV",      "mock",      c(0.15, Inf),    # 8hpi-mock up/down 
  "so_merge",    "lec_type", "treatment", "24hpi",      "8hpi",      c(0.25, Inf),    # 24hpi-8hpi up/down
  
  "so_8",        "cell_type_2", "treatment", "CHIKV",   "mock",      c(0.15, Inf),    # 8hpi-mock up/down broad cell types
  "so_8",        "cell_type_2", "treatment", "CHIKV",   "mock",      c(-Inf, -0.15),
  "so_merge",    "cell_type_2", "treatment", "24hpi",   "8hpi",      c(0.25, Inf),    # 24hpi-8hpi up/down broad cell types
  "so_merge",    "cell_type_2", "treatment", "24hpi",   "8hpi",      c(-Inf, -0.25)
)

degs <- deg_args %>%
  pmap(~ {
    args <- list(...)
    
    if      (all(args$log_fc > 0)) typ <- "-up"
    else if (all(args$log_fc < 0)) typ <- "-down"
    else                           typ <- ""
    
    prfx  <- str_remove(args$so_in, "^so_")
    label <- str_remove_all(args$type_clmn, "_")
    file  <- str_c(prfx, "_", label, "_chikv", typ, "_markers.tsv")
    file  <- here(params$table_dir, file)
    
    d <- eval(sym(args$so_in)) %>%
      get_degs(
        log_fc     = args$log_fc,
        pval       = 0.05,
        ident_1    = args$ident_1,
        ident_2    = args$ident_2,
        treat_clmn = args$treat_clmn,
        type_clmn  = args$type_clmn,
        file       = file
      ) %>%
      list()
    
    names(d) <- str_c(args$so_in, typ, "_", label)
    
    d
  }) %>%
  flatten()

rm(so_8_chikv, so_24_chikv)
```

```{r "GO"}
# Prepare GO data to measure similarity
go_sim_data <- godata(
  OrgDb   = org.Mm.eg.db,
  keytype = "SYMBOL",
  ont     = "BP"
)

# Comparisons to use for GO analysis and plotting
# only want to use two main comparisons for figures
go_comps  <- grep("^so_(8|merge)-up_lectype$", names(degs), value = TRUE)
plt_comps <- grep("^so_(8|merge)-up_lectype$", names(degs), value = TRUE)

# Get GO terms
# only use top 200 DEGs sorted by max p-value
go_degs <- degs[go_comps] %>%
  map(~ {
    .x %>%
      arrange(max_pval) %>%
      split(.$lec_type) %>%
      map(pull, gene) %>%
      map(head, 200)       # TOP 200 DEGs
  })

go <- go_degs %>%
  imap(~ {
    # Get name of Seurat object
    so_in <- str_remove(.y, "-.+$")       # object is first part of name
    
    # Format file name
    typ  <- str_remove(.y, ".+(?=-)")
    clmn <- str_extract(typ, "[a-zA-Z0-9]+$")
    typ  <- str_remove(typ, str_c("_", clmn))
    prfx <- str_remove(so_in, "^so_")
    file <- str_c(prfx, "_", clmn, "_chikv", typ, "_go")
    file <- here(params$table_dir, file)  # file extension gets added later
    
    .x %>%
      get_go(
        so_in     = eval(sym(so_in)),
        file      = file,
        type_clmn = "lec_type"
      )
  })
```

```{r "GO clusters"}
# Cell types to exclude from GO analysis
# exclude CD45+ cell types and erythrocytes
exclude_cell_types <- c(
  "T cells", "B cells", "Macrophages",
  "Erythrocytes", "unassigned", "unassigned-LEC"
)

# Set overlap cutoff for GO terms to use for clustering
# only use terms with >= 3 overlapping genes for 8 hpi (and CHIKV-high/low)
# and >= 10 overlapping genes for 24 hpi
min_ovlp_re <- "^so_(8|24_chikv)"
  
go_ovlp <- set_names(
  rep(10, length(go_comps)),
  go_comps
)

go_ovlp[grepl(min_ovlp_re, names(go_ovlp))] <- 3

# Cluster GO terms
clst_args <- list(
  go_in = go[plt_comps],
  ovlp  = go_ovlp[plt_comps]
)

clusters <- clst_args %>%
  pmap(~ {
    args <- list(...)
    
    get_go_clusters(
      go_in     = args$go_in,
      k         = 5,
      pval      = 0.05,
      n_overlap = args$ovlp,  # Min genes needed to overlap term for it to
                              # be marked significant
      n_shared  = 1,          # Min number of cell types needed to share term for the
                              # term to be included in clustering
      exclude_cell_types = NULL
    )
  }) %>%
  purrr::discard(is.null)

# Calculate similarity between each 8hpi and 24hpi GO cluster
# want to determine which GO clusters are most similar to each other
clusters_merged <- clusters[plt_comps] %>%
  imap(~ {
    nm <- str_extract(.y, "(?<=so_)[0-9a-zA-Z]+")
    nm <- str_replace(nm, "merge", "24")
    nm <- str_c(nm, "hpi-")
    
    .x$clusters %>%
      mutate(cluster = str_c(nm, cluster))
  }) %>%
  bind_rows()

cluster_lvls <- unique(clusters_merged$cluster)

clusters_merged <- clusters_merged %>%
  split(.$cluster) %>%
  map(pull, ID)

comps <- names(clusters_merged) %>%
  expand.grid(names(clusters_merged)) %>%
  as.list()

cluster_sim <- map2_dfr(comps$Var1, comps$Var2, ~ {
  sim <- mgoSim(                  # this calculates semantic similarity for
    GO1 = clusters_merged[[.x]],  # lists of GO terms
    GO2 = clusters_merged[[.y]],
    semData = go_sim_data
  )
  
  tibble(var1 = .x, var2 = .y, sim = sim)
})

# Create heatmap showing GO cluster similarity
sim_heatmap <- cluster_sim %>%
  mutate(
    var1 = fct_relevel(var1, cluster_lvls),
    var2 = fct_relevel(var2, rev(cluster_lvls))
  ) %>%
  ggplot(aes(var1, var2, fill = sim)) +
  geom_tile() +
  scale_fill_gradientn(colours = c("lightblue", "white", "red")) +
  djvdj_theme() +
  theme(
    aspect.ratio = 1,
    axis.title = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

```{r "GO heatmaps"}
# Cluster titles
ttls <- as_labeller(c(
  `1` = "Innate Immune Response",
  `2` = "Inflammatory Response"
))

# Cluster colors
go_clrs <- setNames(
  list(
    c(`1` = "#E69F00"),
    c(`1` = "#D7301F", `2` = "#6A51A3")
  ),
  plt_comps
)

# Create heatmaps
# only showing cell types that have at least one overlapping term plotted and
# are not in exclude_cell_types
# pval and n_overlap cutoffs should match those used for clustering
plt_args <- list(
  go_in    = go[plt_comps],
  clst_dat = clusters[plt_comps],
  clrs     = go_clrs[plt_comps],
  ovlp     = go_ovlp[plt_comps],
  clsts    = list(1, 1:2)
)

go_heat <- plt_args %>%
  pmap(~ {
    args  <- list(...)
    
    create_go_heatmap(
      df_in          = args$clst_dat$clusters,
      go_in          = args$go_in,
      pval           = 0.05,
      n_overlap      = args$ovlp,   # Min genes needed to overlap term for it to
                                    # be marked significant
      n_genes        = 3,           # Min DEGs represented on plot to include cell type
      clusters       = args$clsts,  # Clusters to plot
      clrs           = args$clrs,
      cluster_labels = ttls,
      exclude_cell_types = exclude_cell_types
    )
  })
```

```{r "inflammatory examples"}
plt_args <- list(
  go_in   = go[plt_comps],
  degs_in = degs[plt_comps],
  heat    = go_heat[plt_comps],
  clrs    = go_clrs[plt_comps],
  genes   = list(
    c("Irf7", "Bst2", "Zbp1"),
    c("Ccl2", "Isg15", "Ifi203", "Cxcl9", "Cxcl10", "Ccl7")
  )
)

cell_type_lvls <- c(
  "LEC", "cLEC", "Collecting", "fLEC", "tzLEC",
  "Valve", "Marco_LEC", "BEC", "FRC",
  "PvC"
)

go_examples <- plt_args %>%
  pmap(~ {
    args <- list(...)
    
    # Identify genes to plot
    gns <- get_go_genes(
      go_in    = args$go_in@compareClusterResult,
      degs_in  = args$degs_in,
      clust_in = args$heat$terms,
      genes    = args$genes,
      exclude_cell_types = exclude_cell_types
    )
    
    # Create plots
    create_go_gene_plots(
      all_exp_data = list("8hpi" = so_8, "24hpi" = so_merge),
      all_degs_data = list(
        "8hpi"  = degs$`so_8-up_lectype`,
        "24hpi" = degs$`so_merge-up_lectype`
      ),
      genes              = gns,
      clrs               = args$clrs,
      type_clmn          = "lec_type",
      exclude_cell_types = exclude_cell_types,
      cell_type_lvls     = cell_type_lvls,
      only_show_upreg    = TRUE,
      ttl                = "Upregulated"
    )
  })
```

```{r "homeostatic examples"}
# Additional example genes to plot
genes_to_plot <- c("Ccl19", "Ccl21a", "Il7", "Cxcl13")

# DEGs to use for setting linetype
# merge DEGs so both up- and down-regulated get marked
degs_8_merged  <- bind_rows(degs[c("so_8-up_celltype2", "so_8-down_celltype2")])
degs_24_merged <- bind_rows(degs[c("so_merge-up_celltype2", "so_merge-down_celltype2")])

# Create plots
other_examples <- create_go_gene_plots(
  all_exp_data   = list("8hpi" = so_8, "24hpi" = so_merge),
  all_degs_data  = list("8hpi" = degs_8_merged, "24hpi" = degs_24_merged),
  genes          = genes_to_plot,
  clrs           = "grey75",
  type_clmn      = "cell_type_2",
  cell_types     = c("LEC", "BEC", "FRC"),
  cell_type_lvls = cell_type_lvls,
  ln_size        = 1.5,
  pt_size        = 2
) +
  theme(
    plot.margin = margin(20, 0, 0, 0),
    legend.position = "right",
    legend.key.height = unit(25, "pt")
  )

other_examples <- plot_grid(
  other_examples, NULL,
  labels     = c("G", ""),
  label_size = ttl_pt2 * 1.5,
  rel_widths = c(0.9, 1),
  nrow       = 1
)
```

```{r "fig 5 UMAPs", fig.width = 12, fig.height = 6}
# Format UMAP data
u_lvls <- unique(so_merge_df$tm_treat)

u_clrs <- set_names(
  ito_cols[seq_along(u_lvls)],
  u_lvls
)

# UMAP showing sample groups
plt_args <- list(
  data_col  = c("tm_treat", "cell_type"),
  clrs      = list(u_clrs, type_cols),
  plot_lvls = list(u_lvls, NULL)
)

fig5_umaps <- plt_args %>%
  pmap(
    create_type_umaps,
    so_in      = so_merge_df,
    x          = "UMAP_1",
    y          = "UMAP_2",
    size       = 0.05,
    facet_plot = NULL,
    n_lab      = TRUE,
    key_height = 35,
    lab_size   = txt_pt2 + 1
  ) %>%
  map(~ .x + theme(plot.margin = margin(5, 5, 5, 30)))

# Create final figure
u_fig <- plot_grid(
  plotlist   = fig5_umaps,
  align      = "h",
  axis       = "tb",
  nrow       = 1,
  labels     = c("A", "B"),
  label_size = ttl_pt2 * 1.5
)
```

Differentially expressed genes were identified for each cell type for mock (from 8 hpi experiment) vs 8 hpi and 8 hpi vs 24 hpi. Since the 8 hpi timepoint only has two biological replicates, the top two replicates from the 24 hpi timepoint with the most cells were used for the 8 vs 24 hpi comparison. Genes were considered upregulated if the log2 fold change was >0.15 for 8 hpi and >0.25 for 24 hpi for all replicates and the largest p value for all replicates was <0.05.

```{r "DEG parameters", eval = FALSE}
as.data.frame(deg_args)
```

<br>

Gene ontology terms (biological process) were identified for the top 200 upregulated genes (sorted by maximum p value between replicates) for each cell type. Terms were filtered to only include those with an adjusted p-value <0.05 and at least 3 or 10 upregulated genes overlapping the term for the 8 hpi and 24 hpi timepoints, respectively. Terms with <10 or >750 genes were excluded from the analysis. Terms identified for each cell type were combined and clustered into 5 modules based on the pairwise overlap between terms. The top modules, sorted by number of terms, are shown in C and E.

A.  UMAP projection shows cells from the 8 hpi and 24 hpi timepoints, cells are colored by sample.
B.  UMAP projection shows cells from the 8 hpi and 24 hpi timepoints, cells are colored by cell type.
C.  Enrichment scores are shown for each cell type for the primary gene ontology module identified for genes upregulated at the 8 hpi timepoint. The top five terms, sorted by number of cell types showing significant enrichment for the term, are shown. Enrichment scores were calculated as the fraction of upregulated genes overlapping the term divided by the fraction of background genes overlapping the term. Cell types are only shown if they have at least one upregulated gene overlapping any of the terms.
D.  A selection of top upregulated genes identified for the terms from A are shown. Points show the median expression for the mock (m), 8 hpi (8h), and 24 hpi (24h) samples, grey bars show the interquartile range. A solid line indicates that the gene is significantly upregulated between the samples.
E.  Enrichment scores are shown for the top two GO modules identified for the 24 hpi timepoint, as described in C.
F.  A selection of top upregulated genes identified for the terms shown in E are plotted as described in D.
G.  Expression of homeostatic cytokines is shown for BECs, FRCs (combination of FRCs and PvCs shown in A-F), and LECs as described in D. A solid line indicates that the gene is significantly up- or down-regulated between the samples.  

```{r "GO figures", fig.width = 14.3, fig.height = 21}
plt_args <- list(
  heat     = go_heat[plt_comps],
  examples = go_examples[plt_comps],
  labels   = list(c("C", "D"), c("E", "F")),
  vjust    = c(0.98, 1.5)
)

plt_panels <- plt_args %>%
  pmap(~ {
    args <- list(...)
    
    plot_grid(
      args$heat$heatmap, args$examples,
      labels     = args$labels,
      label_size = ttl_pt2 * 1.5,
      vjust      = args$vjust,
      hjust      = c(-0.4, 0.5),
      nrow       = 1,
      align      = "h",
      axis       = "tb"
    )
  })

plot_grid(
  u_fig,
  plt_panels[[1]], plt_panels[[2]],
  other_examples,
  ncol = 1,
  rel_heights = c(0.8, 0.64, 1, 0.7)
)
```

```{r "supp table"}
# Names for sheets to save
sheet_nms <- names(degs) %>%
  str_remove("^so_") %>%
  str_remove("_[a-zA-Z0-9]+$") %>%
  str_replace("^8", "8hpi-mock") %>%
  str_replace("^24", "24hpi-mock") %>%
  str_replace("^merge", "24hpi-8hpi") %>%
  set_names(names(degs))

# Format DEG tables
degs_tbls <- degs %>%
  map(~ {
    typ_clmns <- c(
      cell_type = "lec_type",
      cell_type = "cell_type_2"
    )
    
    .x %>%
      relocate(any_of(typ_clmns), .before = gene) %>%
      dplyr::select(-minimump_p_val, -ends_with("_adj")) %>%
      arrange(cell_type) %>%
      mutate(cell_type = fct_relevel(cell_type, cell_type_lvls)) %>%
      arrange(cell_type, max_pval)
  })

# Format GO tables
go_clmns <- c(
  cell_type = "Cluster",
  "Description", "ID",
  "GeneRatio", "BgRatio",
  "geneID", "enrichment",
  "pvalue", "p.adjust"
)

clsts_filt <- clusters[plt_comps] %>%
  map(~ dplyr::select(.x$clusters, Description, ID, cluster))

go_tbls <- go[plt_comps] %>%
  imap(~ {
    .x@compareClusterResult %>%
      as_tibble() %>%
      filter(p.adjust < 0.05, n_ovlp >= go_ovlp[[.y]]) %>%
      dplyr::select(all_of(go_clmns)) %>%
      arrange(cell_type) %>%
      mutate(cell_type = fct_relevel(cell_type, cell_type_lvls)) %>%
      left_join(clsts_filt[[.y]], by = c("ID", "Description")) %>%
      arrange(cluster, cell_type, p.adjust, enrichment)
  })

# Format fig 5G tables
fig5g_degs <- c(
  "so_8-up_celltype2", "so_8-down_celltype2",
  "so_merge-up_celltype2", "so_merge-down_celltype2"
)

fig5g_degs <- degs_tbls[fig5g_degs] %>%
  imap_dfr(~ {
    nm <- sheet_nms[[.y]]
    
    .x %>%
      mutate(comparison = nm) %>%
      filter(cell_type %in% c("LEC", "BEC", "FRC"))
  })

# Format sheet names
names(go_tbls) <- sheet_nms[names(go_tbls)] %>%
  map_chr(~ str_c(.x, "_GO"))

degs_tbls <- degs_tbls[plt_comps]

names(degs_tbls) <- sheet_nms[names(degs_tbls)] %>%
  map_chr(~ str_c(.x, "_genes"))

sheets <- append(degs_tbls, go_tbls)
sheets <- append(sheets, list(Fig5G = fig5g_degs))

# Write excel file
ex_file <- here(params$table_dir, "fig5_supp.xlsx")

if (!file.exists(ex_file)) {
  sheets %>%
    iwalk(~ {
      .x %>%
        as.data.frame() %>%
        write.xlsx(
          file      = ex_file,
          sheetName = .y,
          row.names = FALSE,
          append    = TRUE
        )
    })
}
```

---

<br>

<br>

## Session info

```{r}
session_info()
```
