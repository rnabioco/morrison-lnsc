---
title: "CHIKV LNSC figures"
author: "Ryan Sheridan"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc:       true
    toc_float: true
    toc_depth: 2
    theme:     cosmo
    highlight: kate
params:
  src_dir:      "src"
  so_dir:       "~/Dropbox/Ryan/Projects/morrison-lnsc/results/sobjs"
  orig_so_dir:  "~/Dropbox/Ryan/Projects/morrison-scRNA-seq/results"
  type_res:     10                        # Clustering resolution for annotating cell types
  lec_res:      10                        # Clustering resolution for annotating LECs
  frc_res:      3                         # Clustering resolution for annotating fibroblasts
---

<br>

```{r "chunk opts", echo = FALSE}
# Default chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo    = FALSE,
  dpi     = 500
)

knitr::knit(here::here(params$src_dir, "setup.Rmd"), "")
```

# Lucas et al. figures

## Figure 1

Chikungunya virus is found in MARCO-expressing floor lymphatic endothelial cells
in the draining lymph node at 8 hpi

A.  UMAP projection shows the fraction of counts aligning to the CHIKV genome for the 8 hpi timepoint.
B.  UMAP projection shows CHIKV+ cells (>0 CHIKV counts) for the 8 hpi timepoint.
C.  CHIKV counts are shown for cell types with >50 cells for the 8 hpi CHIKV-infected sample.
D.  The fraction of cells identified as CHIKV+ is shown for each cell type for the 8 hpi timepoint.
E.  MARCO expression is shown for fLECs for mock-infected cells and CHIKV-infected cells classified as either CHIKV low or CHIKV high. P values were calculated using a two-sided Wilcoxon rank-sum test with Bonferroni correction. In the boxplot, the central lines, the box limits, and the whiskers represent medians, the interquartile range (IQR), and min/max values that are not outliers, respectively. Outliers are shown as points and include any values that are more than 1.5Ã— IQR away from the box.
F.  Madcam1 expression is shown for fLECs as described in E.

```{r "fig 1A", fig.width = 10, fig.height = 10}
# Format plot data
dat <- so_8@meta.data %>%
  arrange(tot_pct_CHIKV)

# Create UMAP
pseudo <- dat$tot_pct_CHIKV
pseudo <- min(pseudo[pseudo > 0]) / 2

A <- dat %>%
  ggplot(aes(UMAP_1, UMAP_2, fill = tot_pct_CHIKV + pseudo)) +
  geom_point_trace(
    color = "grey",
    trace_position = "bottom"
  ) +
  scale_fill_gradientn(colours = c("white", "#D7301F"), trans = "log10", labels = scales::label_number()) +
  guides(fill = guide_colorbar(title.position = "top", ticks = FALSE, title = "% CHIKV counts")) +
  umap_theme +
  theme(
    aspect.ratio         = 0.9,
    legend.position      = "top",
    legend.title         = element_text(hjust = 0.5, size = ttl_pt2 * 1.5),
    legend.text          = element_text(angle = 45, hjust = 1), 
    legend.direction     = "horizontal",
    legend.justification = 0.2,
    legend.key.width     = unit(30, "pt"),
    legend.key.height    = unit(5, "pt")
  )
```

```{r "CHIKV-high cell types", fig.width = 10, fig.height = 10}
# Format plot data
dat <- so_8@meta.data %>%
  filter(chikv_grp == chikv_grps[2])

plt_labs <- get_nlab_fun(dat, "lec_type", l = "\n", r = "")
plt_labs <- plt_labs()
plt_labs <- map_chr(plt_labs, type_lab_fn)

dat <- dat %>%
  mutate(lec_type = fct_relevel(lec_type, names(plt_labs)))

# Create UMAP
chikv_typs_u <- so_8@meta.data %>%
  mutate(lec_type = fct_relevel(lec_type, names(plt_labs))) %>%
  ggplot(aes(UMAP_1, UMAP_2)) +
  geom_point_trace(
    color = "grey",
    fill  = "white",
    trace_position = "bottom"
  ) +
  geom_point(aes(color = lec_type), data = dat) +
  scale_color_manual(values = lec_type_cols, labels = plt_labs) +
  scale_y_discrete(labels = type_lab_fn) +
  guides(color = guide_legend(override.aes = list(size = 4))) +
  labs(title = "CHIKV+ cell types") +
  umap_theme +
  theme(
    aspect.ratio         = 0.9,
    plot.title           = element_text(size = ttl_pt2 * 1.5, hjust = 0.2),
    legend.title         = element_blank(),
    legend.key.height    = unit(35, "pt"),
    legend.justification = "bottom",
    legend.text          = element_text(size = ttl_pt1)
  )
```

```{r "8hpi fraction CHIKV-high"}
# Format plot data
# ONLY PLOTTING ENRICHED COUNTS
dat <- so_8@meta.data %>%
  as_tibble(rownames = ".cell_id") %>%
  filter(treatment == "CHIKV") %>%
  group_by(lec_type) %>%
  filter(n() > 50) %>%
  ungroup() %>%
  mutate(
    counts = tot_nCount_CHIKV - nCount_CHIKV
    # counts = tot_nCount_CHIKV
    # enr = tot_nCount_CHIKV + 1
  )

# Fraction CHIKV-high cells
frac_dat <- dat %>%
  group_by(lec_type, rep) %>%
  summarize(
    n = length(chikv_grp[chikv_grp == chikv_grps[2]]),
    tot = n(),
    frac = n / tot,
    .groups = "drop"
  ) %>%
  group_by(lec_type) %>%
  mutate(tot = sum(tot)) %>%
  ungroup() %>%
  mutate(lec_type = fct_reorder(lec_type, frac, max, .desc = TRUE))

frac_lvls <- levels(frac_dat$lec_type)

n_lab <- get_nlab_fun(dat, "lec_type", l = "\n", r = "")

n_lab <- n_lab() %>%
  map_chr(str_replace, "_", " ")

frac_8 <- frac_dat %>%
  ggplot(aes(lec_type, frac, fill = lec_type, color = lec_type, alpha = rep)) +
  geom_col(position = position_dodge2(padding = 0.12), width = 0.8, size = 1) +
  scale_alpha_manual(values = c(0.3, 0.7)) +
  scale_fill_manual(values = lec_type_cols) +
  scale_color_manual(values = lec_type_cols) +
  scale_x_discrete(labels = n_lab) +
  labs(y = "Fraction\nCHIKV+ cells") +
  base_theme +
  theme(
    # aspect.ratio = 0.2
    # plot.margin = margin(25, 5, 5, 15)
    axis.text.y = element_text(size = txt_pt1),
    axis.text.x = element_text(size = ttl_pt2, angle = 45, hjust = 1),
    axis.title.x = element_blank(),
    legend.position = "none",
  )
```

```{r "fig 1B", fig.width = 10, fig.height = 5}
# Create boxplots
count_bxs <- dat %>%
  mutate(lec_type = fct_relevel(lec_type, frac_lvls)) %>%
  ggplot(
    aes(lec_type, counts + 1, fill = lec_type, color = lec_type, alpha = rep)
  ) +
  geom_boxplot(size = 1, outlier.size = 1.5, outlier.alpha = 1, position = position_dodge2(padding = 0.12), width = 0.8) +
  scale_y_log10() +
  scale_x_discrete(labels = plt_labs)+
  scale_fill_manual(values = lec_type_cols) +
  scale_color_manual(values = lec_type_cols) +
  scale_alpha_manual(values = c(0.3, 0.7)) +
  labs(y = "CHIKV\ncounts + 1") +
  base_theme +
  theme(
    # axis.text.x     = element_text(size = ttl_pt2, angle = 90, vjust = 0.5, hjust = 1)
    # aspect.ratio = 0.2,
    plot.margin     = margin(35, 5, 5, 25),
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.title.y    = element_text(size = ttl_pt2),
    axis.text.x     = element_blank(),
    axis.ticks.x    = element_blank()
  )

count_bxs <- plot_grid(
  count_bxs, frac_8,
  labels = c("C", "D"), label_size = ttl_pt2 * 1.5,
  align = "v", axis = "rl",
  ncol = 1,
  rel_heights = c(1, 1)
)
```

```{r "fig1 examples", fig.width = 3, fig.height = 5}
plt_dat <- so_8 %>%
  mutate_meta(
    mutate,
    chikv_grp = recode(
      chikv_grp,
      `CHIKV-low` = "CHIKV-",
      `CHIKV-high` = "CHIKV+"
    )
  )

marco_bxs <- plt_dat %>%
  create_gene_boxplot("Marco", "fLEC", clr = "#D7301F")

madcam_bxs <- plt_dat %>%
  create_gene_boxplot("Madcam1", "fLEC", clr = "#E69F00")


# # CHECK FOR CONTAMINATING fLEC CLUSTERS
# # filter 24hpi Marco_LEC clusters to remove Madcam1+ cells
# # removal of Madcam1+ clusters does not affect overall result
# # i.e. CHIKV-high still shows higher Marco expression than CHIKV-low
# test_dat <- so_lec_24 %>%
#   mutate_meta(
#     mutate,
#     chikv_grp = ifelse(treatment == "mock", treatment, chikv_grp)
#   ) %>%
#   subset(lec_type == "Marco_LEC") %>%
#   FetchData(c(
#     "Madcam1", "Marco",
#     "seurat_clusters", "orig.ident", "treatment", "rep",
#     "chikv_grp"
#   ))
# 
# clsts <- test_dat %>%
#   group_by(seurat_clusters) %>%
#   summarize(sig = mean(Madcam1), n = n()) %>%
#   as.data.frame() %>%
#   arrange(desc(sig)) %>%
#   filter(sig <= 0.4) %>%
#   pull(seurat_clusters)
# 
# plt_dat <- so_lec_24 %>%
#   subset(seurat_clusters %in% clsts)
# 
# plt_dat %>%
#   create_gene_boxplot("Madcam1", "Marco_LEC")
# 
# plt_dat %>%
#   create_gene_boxplot("Marco", "Marco_LEC")
```

```{r "fig 1", fig.width = 15, fig.height = 12}
top <- plot_grid(
  A, chikv_typs_u,
  labels = c("A", "B"), label_size = ttl_pt2 * 1.5,
  nrow   = 1,
  align  = "h",
  axis   = "tb"
)

bot <- plot_grid(
  count_bxs, NULL, marco_bxs, NULL, madcam_bxs,
  labels = c("", "", "E", "", "F"), label_size = ttl_pt2 * 1.5,
  nrow   = 1,
  rel_widths = c(1, 0.05, 0.36, 0.05, 0.36)
)

plot_grid(
  top, NULL, bot,
  ncol = 1,
  rel_heights = c(1, 0.05, 0.7)
)

# l <- plot_grid(
#   A, C,
#   labels = c("A", "C"), label_size = ttl_pt2 * 1.5,
#   ncol   = 1,
#   align  = "v",
#   axis   = "rl"
# )
# 
# r <- plot_grid(
#   B, D,
#   labels = c("B", "D"), label_size = ttl_pt2 * 1.5,
#   ncol   = 1,
#   align  = "v",
#   axis   = "rl"
# )
# 
# plot_grid(l, r, nrow = 1, rel_widths = c(1, 0.5))
```

<br>

## Figure S1

CHIKV may target MARCO-expressing LECs for infection

```{r "UMAPs", fig.width = 10, fig.height = 10}
# Pseudo count for pct_mito
pseudo <- so_24$pct_mito
pseudo <- min(pseudo[pseudo > 0]) / 2

# Format data
dat <- so_24@meta.data %>%
  as_tibble(rownames = "cell_id") %>%
  mutate(pct_mito = pct_mito + pseudo) %>%
  arrange(CHIKV_sgRNA_fc)

chikv_dat <- dat %>%
  filter(chikv_grp == chikv_grps[2])

# Cell type UMAP
type_umap <- dat %>%
  plot_scatter(
    "lec_type",
    plot_colors  = lec_type_cols,
    plot_lvls    = NULL,
    size         = 0.2,
    label_params = list(size = txt_pt2)
  ) +
  umap_theme +
  theme(
    aspect.ratio = 0.9,
    legend.title = element_blank(), legend.key.height = unit(30, "pt")
  )
  
# sgRNA ratio UMAP
sgRNA_umap <- dat %>%
  ggplot(aes(UMAP_1, UMAP_2, fill = CHIKV_sgRNA_fc)) +
  geom_point_trace(
    color = "grey",
    trace_position = "bottom",
    size = 0.5
  ) +
  scale_fill_gradientn(colours = c("white", "#0072B2", "#002037"), labels = scales::label_number()) +
  guides(fill = guide_colorbar(title.position = "top", ticks = FALSE, title = "CHIKV sgRNA ratio")) +
  umap_theme +
  theme(
    aspect.ratio         = 0.9,
    legend.position      = "top",
    legend.title         = element_text(hjust = 0.5, size = ttl_pt2),
    legend.direction     = "horizontal",
    legend.justification = 0.5,
    legend.key.width     = unit(30, "pt"),
    legend.key.height    = unit(5, "pt")
  )
```

```{r "scatter plots", fig.width = 10, fig.height = 7}
# ONLY PLOT CHIKV-HIGH CELLS
# Shouldn't include any CHIKV-low cells, since they have been filtered
# stringently based on QC and CHIKV-high cells have not. This would influence
# correlations

# Stats to plot
y_vars <- c(
  "# mouse genes\nexpressed" = "nFeature_RNA",
  "% mitochondrial\nreads" = "pct_mito"
)

x_var <- "CHIKV_sgRNA_fc"
typs  <- c("Marco_LEC", "BEC", "PvC", "unassigned-LEC")

# Scatter plots
plt_dat <- chikv_dat %>%
  filter(lec_type %in% typs) %>%
  mutate(lec_type = fct_relevel(lec_type, typs)) %>%
  dplyr::rename(!!!syms(y_vars)) %>%
  pivot_longer(all_of(names(y_vars))) %>%
  group_by(lec_type, name) %>%
  mutate(
    cor = cor(log10(!!sym(x_var)), log10(value)),
    cor = str_c("r = ", round(cor, 2))
  ) %>%
  ungroup()

scatter <- plt_dat %>%
  split(.$lec_type) %>%
  unname() %>%
  imap(~ {
    clmn <- .y
    
    .x <- .x %>%
      split(.$name)
    
    top <- names(.x)[1]
    
    .x %>%
      imap(~ {
        if (clmn == 1) y_ttl <- .y
        else           y_ttl <- NULL
        
        ttl <- NULL
        sub <- NULL
        x_ttl <- NULL
        
        if (.y == top) {
          ttl   <- type_lab_fn(unique(.x$lec_type))
          sub   <- str_c("n = ", nrow(.x))
        }
        
        .x %>%
          ggplot(aes(!!sym(x_var), value, color = lec_type)) +
          geom_point() +
          geom_smooth(
            method = "lm", formula = y ~ x,
            color = "black", linewidth = 0.5, linetype = 2, alpha = 0.2) +
          geom_text(
            aes(Inf, Inf, label = cor),
            hjust = 1.2, vjust = 1.2,
            color = "black",
            check_overlap = TRUE
          ) +
          scale_color_manual(values = lec_type_cols) +
          scale_x_log10() +
          scale_y_log10(expand = expansion(c(0.05, 0.10))) +
          labs(title = ttl, subtitle = sub, x = x_ttl, y = y_ttl) +
          theme(aspect.ratio = 0.9) +
          base_theme +
          theme(
            legend.position = "none",
            axis.text.x = element_text(size = txt_pt1),
            axis.text.y = element_text(size = txt_pt1)
          )
      })
  }) %>%
  flatten()

# x-axis title
x_ttl <- scatter[[1]] +
  labs(title = "CHIKV sgRNA ratio") +
  theme(
    plot.title = element_text(hjust = 0.5, vjust = 1, size = ttl_pt2)
  )

x_ttl <- get_title(x_ttl)

# Create final figure
scatter <- scatter %>%
  wrap_plots(byrow = FALSE, nrow = 2)

scatter <- list(scatter, x_ttl) %>%
  wrap_plots(ncol = 1, heights = c(1, 0.1))
```

```{r "scatter plots v2", fig.width = 10, fig.height = 7, eval = FALSE}
# ONLY PLOT CHIKV-HIGH CELLS
# Shouldn't include any CHIKV-low cells, since they have been filtered
# stringently based on QC and CHIKV-high cells have not. This would influence
# correlations

# Stats to plot
y_vars <- c(
  "# mouse genes\nexpressed" = "nFeature_RNA",
  "% mitochondrial\nreads" = "pct_mito"
)

x_var <- c("CHIKV sgRNA ratio" = "CHIKV_sgRNA_fc")
typs  <- c("Marco_LEC", "unassigned-LEC")

# Scatter plots
plt_dat <- chikv_dat %>%
  filter(lec_type %in% typs) %>%
  mutate(lec_type = fct_relevel(lec_type, typs)) %>%
  dplyr::rename(!!!syms(y_vars)) %>%
  pivot_longer(all_of(names(y_vars)))

scatter <- plt_dat %>%
  split(.$name) %>%
  imap(~ {
    
    log_trans <- grepl("mouse genes", .y)
    
    if (log_trans) {
      y_fn    <- log10
      y_trans <- "log10"
    } else {
      y_fn    <- function(x) x
      y_trans <- "identity"
    }
    
    n_lab <- get_nlab_fun(.x, "lec_type", l = "\n", r = "")
    
    cor_dat <- .x %>%
      summarize(
        cor = list(tidy(cor.test(
          log10(!!sym(unname(x_var))), y_fn(value),
          method = "pearson",
          alternative = "two.sided"
        ))),
        
        pval = map_dbl(cor, pull, p.value),
        pval = format_pvalue(pval),
        pval = str_c("italic(p) == ", pval),
        cor  = map_dbl(cor, pull, estimate),
        cor  = str_c("italic(r) == ", round(cor, 2))
        # cor  = str_c(cor, " ~ ", pval)
      )
    
    .x %>%
      ggplot(aes(!!sym(unname(x_var)), value, color = lec_type)) +
      geom_point() +
      geom_smooth(
        method = "lm", formula = y ~ x,
        color = "black", linewidth = 0.5, linetype = 2, alpha = 0.2
      ) +
      geom_text(
        aes(Inf, Inf, label = cor),
        data = cor_dat,
        parse = TRUE,
        hjust = 1.2, vjust = 1.2,
        color = "black"
      ) +
      scale_color_manual(values = lec_type_cols, labels = n_lab) +
      scale_x_log10() +
      scale_y_continuous(trans = y_trans, expand = expansion(c(0.05, 0.10))) +
      guides(color = guide_legend(override.aes = list(size = 4))) +
      labs(x = names(x_var), y = .y) +
      theme(aspect.ratio = 0.9) +
      base_theme +
      theme(
        aspect.ratio = 0.9,
        legend.position = "bottom",
        legend.title = element_blank(),
        axis.text.x = element_text(size = txt_pt1),
        axis.text.y = element_text(size = txt_pt1)
      )
  })

# Create final figure
scatter <- scatter %>%
  wrap_plots(byrow = FALSE, nrow = 1)

ggsave(
  here("results/figures/2023-07-04_alt_scatter_plots.pdf"),
  width = 10, height = 7,
  dpi = 600, device = "pdf"
)

```

```{r "sgRNA signal"}
# Format plot data
# only include cell types with >10 cells
plt_dat <- dat %>%
  filter(treatment == treats[2])

typs <- plt_dat %>%
  filter(chikv_grp == chikv_grps[2]) %>%
  pull(lec_type) %>%
  table() %>%
  sort(decreasing = TRUE)

typs <- names(typs[typs > 10])

# Fraction CHIKV-high cells
frac_dat <- plt_dat %>%
  group_by(lec_type, rep) %>%
  summarize(
    n = length(chikv_grp[chikv_grp == chikv_grps[2]]),
    tot = n(),
    frac = n / tot,
    .groups = "drop"
  ) %>%
  group_by(lec_type) %>%
  mutate(tot = sum(tot)) %>%
  ungroup() %>%
  mutate(lec_type = fct_reorder(lec_type, frac, max, .desc = TRUE))

n_lab <- get_nlab_fun(plt_dat, "lec_type", l = "\n", r = "")

n_lab <- n_lab() %>%
  map_chr(str_replace, "_", " ")

frac_24 <- frac_dat %>%
  ggplot(aes(lec_type, frac, fill = lec_type, color = lec_type, alpha = rep)) +
  geom_col(position = "dodge") +
  scale_alpha_manual(values = c(0.1, 0.3, 0.6)) +
  scale_fill_manual(values = lec_type_cols) +
  scale_color_manual(values = lec_type_cols) +
  scale_x_discrete(labels = n_lab) +
  labs(y = "Fraction\nCHIKV-high cells") +
  base_theme +
  theme(
    axis.text.y = element_text(size = txt_pt1),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_blank(),
    legend.position = "none",
    aspect.ratio = 0.2,
    plot.margin = margin(25, 5, 5, 15)
  )

# sgRNA ratio
# Filter to include cells with >0 sgRNA counts and >0 5' counts
sgRNA_boxes <- plt_dat %>%
  filter(
    lec_type %in% typs,
    CHIKV_sgRNA > 0,
    CHIKV_5 > 0
  ) %>%
  plot_violin(
    "CHIKV_sgRNA_fc",
    cluster_col = "lec_type",
    plot_colors = lec_type_cols,
    plot_lvls   = NULL,
    trans       = "log10",
    scale       = "width",
    draw_quantiles = c(0.25, 0.75)
  ) +
  labs(y = "CHIKV sgRNA\nratio") +
  base_theme +
  theme(
    aspect.ratio    = 0.25,
    plot.margin     = margin(25, 5, 5, 15),
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.text.x     = element_text(angle = 45, hjust = 1),
    axis.text.y     = element_text(size = txt_pt1),
  )
```

```{r "type examples", fig.width = 10, fig.height = 6.5}
# Genes to plot
gns <- c(
  "Lyve1", "Marco",    # Marco LECs
  "Madcam1", "Vcam1",  # fLECs
  "Ptx3",              # Ptx3 LECs
  "Ackr4"              # cLECs
)

all_gns <- c(gns, c("Mxra8", "Ccl21a", "Il7", "Cxcl13", "Cxcl9"))

tms <- c("8hpi", "24hpi")

# Format data
typ_bx_dat <- list("8hpi" = so_8, "24hpi" = so_24) %>%
  imap_dfr(~ {
    if (identical(.y, "8hpi")) {
      .x <- .x %>%
        mutate_meta(mutate, fib_type = fib_subtype)
    }
    
    clmns <- c(
      "cell_type", "lec_type", "fib_type",
      "treatment", "orig.ident", "rep", "chikv_grp", all_gns
    )
    
    .x %>%
      FetchData(clmns) %>%
      as_tibble(rownames = "cell_id") %>%
      mutate(
        tm = .y,
        tm = fct_relevel(tm, tms),
        tm_treat = str_c(tm, "-", treatment),
        tm_treat = fct_relevel(tm_treat, unlist(map(tms, str_c, "-", treats)))
      )
  })

# Create boxplots
type_boxes <- gns %>%
  map(~ {
    lvls <- typ_bx_dat %>%
      group_by(lec_type) %>%
      summarize(
        stats = list(boxplot.stats(!!sym(.x))),
        med   = map_dbl(stats, ~ .x$stats[3]),
        q3    = map_dbl(stats, ~ .x$stats[4]),
        q4    = map_dbl(stats, ~ .x$stats[5]),
        mx    = max(!!sym(.x))
      ) %>%
      arrange(med, q3, q4, mx) %>%
      pull(lec_type) %>%
      rev()
      
    typ_bx_dat %>%
      mutate(lec_type = fct_relevel(lec_type, lvls)) %>%
      ggplot(aes(lec_type, !!sym(.x), color = lec_type, fill = lec_type)) +
      geom_boxplot(
        size = 0.5, alpha = 0.5,
        outlier.size = 0.1, outlier.alpha = 1,
        position = position_dodge2(preserve = "single")
      ) +
      scale_color_manual(values = lec_type_cols) +
      scale_fill_manual(values = lec_type_cols) +
      scale_x_discrete(labels = type_lab_fn) +
      facet_wrap(~ tm, ncol = 1) +
      labs(y = str_c(.x, " expression")) +
      base_theme +
      theme(
        aspect.ratio    = 0.16,
        legend.position = "none",
        axis.title.x    = element_blank(),
        axis.text.x     = element_text(angle = 45, hjust = 1),
        axis.text.y     = element_text(size = txt_pt1)
      )
  }) %>%
  plot_grid(
    plotlist = .,
    align = "vh",
    axis  = "trbl",
    nrow  = 2
  )
```

### CHIKV signal

A.  UMAP projection shows annotated cell types for the 24 hpi timepoint.
B.  UMAP projection shows CHIKV sgRNA ratio (sgRNA counts / 5' counts) for the 24 hpi timepoint.
C.  The fraction of cells identified as CHIKV-high is shown for each cell type for the 24 hpi timepoint.
D.  CHIKV sgRNA ratio is shown for cells with >0 sgRNA counts and >0 5' counts. Cell types with >10 cells are shown.
E.  The correlation between CHIKV sgRNA ratio and QC metrics is shown for CHIKV-high cells.

```{r "fig S1 v2", fig.width = 16, fig.height = 14}
top <- plot_grid(
  type_umap, sgRNA_umap,
  labels = c("A", "B"), label_size = ttl_pt2 * 1.5,
  align = "vh", axis = "trbl",
  nrow = 1
)

left <- plot_grid(
  frac_24, sgRNA_boxes,
  labels = c("C", "D"), label_size = ttl_pt2 * 1.5,
  align = "v", axis = "rl",
  ncol = 1
)

right <- plot_grid(
  NULL, scatter, NULL,
  rel_heights = c(0.15, 1, 0.15),
  ncol = 1
)

bot <- plot_grid(
  left, right,
  labels = c("", "E"), label_size = ttl_pt2 * 1.5,
  rel_widths = c(0.75, 1),
  nrow = 1
)

plot_grid(
  top, bot,
  rel_heights = c(1, 0.75),
  ncol = 1
)
```

<br>

### Cell type annotation

A.  The correlation between annotated LEC subsets and reference data is shown for the 8 hpi and 24 hpi timepoint.
B.  The expression of select marker genes is shown for the 8 hpi and 24 hpi timepoints.

```{r "cell type heatmaps", fig.width = 8, fig.height = 5}
# Format heatmap data
h_dat <- so_lec %>%
  SplitObject("tm") %>%
  imap(~ {
    obj <- .x
    set_names(treats, str_c(.y, "-", treats)) %>%
      map(~ subset(obj, treatment == .x))
  }) %>%
  flatten() %>%
  map(~ {
    .x %>%
      mutate_meta(
        mutate,
        lec_type = recode(lec_type, unassigned = "unassigned-LEC")
      )
  })

rm(so_lec_8, so_lec_24)

h_mat <- h_dat %>%
  map(~ {
    .x %>%
      clustify(
        ref_mat        = ref_lec,
        cluster_col    = "lec_type",
        seurat_out     = FALSE,
        compute_method = "spearman",
        n_genes        = 2000
      ) %>%
      as_tibble(rownames = "assigned_type") %>%
      pivot_longer(
        cols      = -assigned_type,
        names_to  = "ref_type",
        values_to = "r"
      )
  })

# Format LEC types labels
lec_labs <- h_dat %>%
  map(~ {
    typs <- .x@meta.data %>%
      group_by(lec_type) %>%
      dplyr::filter(n() > 10) %>%
      pull(lec_type) %>%
      unique()
    
    .x %>%
      subset(lec_type %in% typs)
  }) %>%
  map(get_nlab_fun, "lec_type", l = "\n", r = "")
  
# Create heatmaps
heat_args <- list(
  df_in    = h_mat,
  ttl      = names(h_mat),
  lec_labs = lec_labs
)

type_heats <- heat_args %>%
  pmap(create_cor_heatmap, ln_clr = fade_0) %>%
  plot_grid(plotlist = .)
```

```{r "cell type sample heatmaps", fig.width = 8, fig.height = 5, eval = FALSE}
# Format heatmap data
h_dat <- list("8hpi" = so_lec_8, "24hpi" = so_lec_24) %>%
  imap(~ {
    obj <- .x
    set_names(treats, str_c(.y, "-", treats)) %>%
      map(~ subset(obj, treatment == .x))
  }) %>%
  flatten() %>%
  map(~ {
    .x %>%
      mutate_meta(
        mutate,
        lec_type = recode(lec_type, unassigned = "unassigned-LEC")
      )
  })

rm(so_lec_8, so_lec_24)

# Calculate average expression to use for correlation calculations
ref_mats <- h_dat %>%
  map(~ {
    average_clusters(
      mat         = .x@assays$RNA@data,
      metadata    = .x@meta.data,
      cluster_col = "lec_type"
    )
  })

# Calculate correlation
h_mat <- h_dat %>%
  imap_dfr(~ {
    mat <- .x
    mat_sample <- .y
    
    ref_mats %>%
      imap_dfr(~ {
        mat %>%
          clustify(
            ref_mat        = .x,
            cluster_col    = "lec_type",
            seurat_out     = FALSE,
            compute_method = "spearman",
            n_genes        = 2000
            # query_genes    = VariableFeatures(h_dat$`24hpi-mock`),
            # low_threshold_cell = 50,
          ) %>%
          as_tibble(rownames = "assigned_type") %>%
          pivot_longer(
            cols      = -assigned_type,
            names_to  = "ref_type",
            values_to = "r"
          ) %>%
          mutate(
            mat_sample = mat_sample,
            ref_sample = .y
          )
      })
  })

# Format data for text labels
txt_dat <- h_mat %>%
  filter(mat_sample != ref_sample) %>%
  group_by(assigned_type, mat_sample, ref_sample) %>%
  summarize(
    ref_type = ref_type[r == max(r)],
    top_cor = round(max(r), 2),
    .groups = "drop"
  )
  
  # rowwise() %>%
  # mutate(sams = str_c(sort(c(mat_sample, ref_sample)), collapse = "-")) %>%
  # ungroup() %>%
  # group_by(sams) %>%
  
# Create heatmaps
h_mat %>%
  filter(mat_sample != ref_sample) %>%
  ggplot(aes(ref_type, assigned_type, fill = r)) +
  geom_tile() +
  
  geom_text(
    aes(label = top_cor, fill = NULL),
    data = txt_dat
  ) +
  
  scale_fill_gradientn(colours = c("white", "red")) +
  facet_grid(mat_sample ~ ref_sample, scales = "free") +
  djvdj_theme() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

```{r "type examples extended", fig.width = 10, fig.height = 6.5}
# Create boxplots
type_boxes <- gns %>%
  map(~ {
    lvls <- typ_bx_dat %>%
      group_by(lec_type) %>%
      summarize(
        stats = list(boxplot.stats(!!sym(.x))),
        med   = map_dbl(stats, ~ .x$stats[3]),
        q3    = map_dbl(stats, ~ .x$stats[4]),
        q4    = map_dbl(stats, ~ .x$stats[5]),
        mx    = max(!!sym(.x))
      ) %>%
      arrange(med, q3, q4, mx) %>%
      pull(lec_type) %>%
      rev()
      
    typ_bx_dat %>%
      mutate(
        lec_type = fct_relevel(lec_type, lvls),
        chikv_grp = fct_relevel(chikv_grp, chikv_grps)
      ) %>%
      ggplot(aes(lec_type, !!sym(.x), color = lec_type, fill = lec_type, alpha = chikv_grp)) +
      geom_boxplot(
        size = 0.25, color = "black",
        outlier.size = 0.01, outlier.alpha = 0.1,
        position = position_dodge2(preserve = "single"),
        key_glyph = draw_key_point,
      ) +
      scale_color_manual(values = lec_type_cols) +
      scale_fill_manual(values = lec_type_cols) +
      scale_alpha_manual(values = c(`CHIKV-low` = 0.5, `CHIKV-high` = 1)) +
      scale_x_discrete(labels = type_lab_fn) +
      facet_wrap(~ tm_treat, ncol = 1) +
      labs(y = str_c(.x, " expression")) +
      guides(
        fill = "none", color = "none",
        alpha = guide_legend(
          override.aes = list(shape = 15, fill = "black", size = 4)
        )
      ) +
      base_theme +
      theme(
        aspect.ratio    = 0.15,
        legend.position = "top",
        legend.title    = element_blank(),
        legend.text     = element_text(size = txt_pt1),
        axis.title.x    = element_blank(),
        axis.text.x     = element_text(size = txt_pt2, angle = 90, hjust = 1, vjust = 0.5),
        axis.text.y     = element_text(size = txt_pt1 * 0.75),
        strip.text      = element_text(size = txt_pt2)
      )
  }) %>%
  plot_grid(
    plotlist = .,
    align = "vh",
    axis  = "trbl",
    nrow  = 2
  )
```

```{r "fig S1 v2 cell type", fig.width = 12, fig.height = 18}
plot_grid(
  type_heats, NULL, type_boxes,
  rel_heights = c(0.7, 0.04, 1),
  label_size  = ttl_pt2 * 1.5,
  labels      = c("A", "B"),
  ncol        = 1
)
```



```{r "INTEGRATION", eval = FALSE}
# Clustering resolutions
rslns <- c(1, 3, 5)

# Merge timepoints
so_merge <- merge(so_lec_8, so_lec_24) %>%
  run_m3drop(threshold = 0.001) %>%
  ScaleData(assay = "RNA") %>%
  cluster_RNA(
    resolution = rslns,
    dims       = 1:40
  ) %>%
  mutate_meta(
    mutate,
    tm = replace_na(tm, "24hpi"),
    sample = ifelse(is.na(sample), str_c(treatment, tm, rep, sep = "-"), sample)
  )

# Variables to regress out
vars_to_regress <- c("pct_mito", "nCount_RNA")

# Cluster each treatment separately
so_treats <- set_names(treats) %>%
  map(~ subset(so_merge, treatment == .x))

rm(so_merge)  

so_treats <- so_treats %>%
  map(~ {
    .x %>%
      subset_sobj(
        dims         = 1:40,
        rsln         = rslns,
        var_p        = 0.001,
        regress_vars = vars_to_regress
      )
  })

# Integration features
features <- SelectIntegrationFeatures(object.list = so_treats)

# Scale data using integration features
so_int <- so_treats %>%
  map(~ {
    .x %>%
      ScaleData(features = features) %>%
      RunPCA(features = features)
  })

rm(so_treats)

# Get integration anchors and integrate
int_anchors <- so_int %>%
  FindIntegrationAnchors(
    anchor.features = features,
    reduction = "rpca"
  )

so_int <- IntegrateData(
  anchorset = int_anchors,
  normalization.method = "LogNormalize"
)

rm(int_anchors)

# Scale and cluster integrated data
DefaultAssay(so_int) <- "integrated"

so_int <- so_int %>%
  ScaleData(vars.to.regress = vars_to_regress) %>%
  RunPCA() %>%
  RunUMAP(dims = 1:40, reduction.key = "intUMAP_") %>%
  FindNeighbors(dims = 1:40) %>%
  FindClusters(resolution = rslns)

so_int <- so_int %>%
  AddMetaData(FetchData(., str_c("intUMAP_", 1:2)))

DefaultAssay(so_int) <- "RNA"

so_int %>%
  qsave(here(params$so_dir, "so_int.qs"))
```

```{r "cell type markers", fig.height = 21, fig.width = 20, eval = FALSE}
feats <- c(
  "Ptprc",           # hematopoietic cells
  "Pdpn", "Pecam1",  # LECs (+/+), BECs (-/+), FRCs (+/-)
  "Pdgfra",          # Fibroblasts
  "Acta2", "Itga7",  # PvCs
  "Cd14", "Fcgr3",   # macrophages/monocytes
  "Fcgr1",           # macrophages
  "Nkg7",            # NK cells
  "Cd3e",            # T cells
  "Cd19"             # B cells
)

feats %>%
  map(~ {
    so_8 %>%
      plot_example_gene(
        .x, "lec_type",
        box_colors  = lec_type_cols,
        umap_colors = c("white", "#D7301F")
      )
  }) %>%
  plot_grid(plotlist = ., ncol = 4)
```

```{r "lec type markers", fig.height = 28, fig.width = 20, eval = FALSE}
feats <- c(
  "Marco", "Lyve1", "Tspan7",        # Marco LECs
  "Madcam1", "Vcam1", "Clu", "Ltb",  # fLECs
  "Ptx3", "Stab2",                   # Ptx3 LECs
  "Cldn11", "Esam",                  # Valve LECs
  "Ackr4", "Foxc2",                  # cLECs
  "Ccl21a"                           # Collecting LECs
)

feats %>%
  map(~ {
    so_8 %>%
      plot_example_gene(
        .x, "lec_type",
        box_colors  = lec_type_cols,
        umap_colors = c("white", "#D7301F")
      )
  }) %>%
  plot_grid(plotlist = ., ncol = 4)
```

<br>

## Figure 5

Differentially expressed genes were identified for each cell type for mock vs 8 hpi and 8 hpi vs 24 hpi. Genes were considered upregulated if the log2 fold change was >0.15 for 8 hpi and >0.25 for 24 hpi for all replicates and the largest p-value for all replicates was <0.05.

Gene ontology terms (biological process) were then identified for upregulated genes for each cell type. Terms were filtered to only include those with an adjusted p-value <0.05 and at least 3 or 10 upregulated genes overlapping the term for the 8 hpi and 24 hpi timepoints, respectively. Terms identified for each cell type were combined and clustered into three modules based on the pairwise overlap between terms.

A.  UMAP projection shows cells from the 8 hpi and 24 hpi timepoints, cells are colored by sample.
B.  UMAP projection shows cells from the 8 hpi and 24 hpi timepoints, cells are colored by cell type.
C.  The 8 hpi timeopoint shows upregulation of genes associated with an innate immune response. Enrichment scores are shown for each cell type for the primary gene ontology module identified for genes upregulated at the 8 hpi timepoint. Enrichment score is the fraction of upregulated genes overlapping the term divided by the fraction of background genes overlapping the term. GO terms that are significantly enriched are marked by the diamond.
D.  A selection of top upregulated genes identified for the terms shown in A are plotted. Points show the median expression for the mock (m), 8 hpi (8h), and 24 hpi (24h) samples, grey bars show the interquartile range. A solid line indicates that the gene is significantly upregulated between the samples.
E.  Enrichment scores are shown for the primary GO modules identified for the 24 hpi timepoint, as described in C.
F.  Top upregulated genes identified for the terms shown in E are plotted as described in D.

```{r "DEGs"}
# Create object to compare CHIKV 24 hpi with 8 hpi
top_reps <- as.character(so_24$rep) %>%
  table() %>%
  sort() %>%
  tail(2) %>%
  names() %>%
  sort()

new_reps <- set_names(
  seq_along(top_reps), top_reps
)

so_merge <- so_24 %>%
  subset(treatment == "CHIKV") %>%
  subset(rep %in% names(new_reps)) %>%
  mutate_meta(~ {
    .x %>%
      mutate(
        rep = recode(rep, !!!new_reps),
        treatment = "24hpi"
      )
  })

so_merge <- so_8 %>%
  subset(treatment == "CHIKV") %>%
  mutate_meta(mutate, treatment = "8hpi") %>%
  merge(so_merge)

# Create objects to compare CHIKV-low/-high cells
so_8_chikv <- so_8 %>%
  subset(treatment == "CHIKV")

so_24_chikv <- so_24 %>%
  subset(treatment == "CHIKV")

# Identify up/down regulated genes
deg_args <- list(
  so_in      = c("so_8", "so_8", "so_24", "so_24", "so_merge", "so_merge", "so_8_chikv", "so_24_chikv"),
  treat_clmn = c(rep("treatment", 6), rep("chikv_grp", 2)),
  ident_1    = c(rep("CHIKV", 4), rep("24hpi", 2), rep("CHIKV-high", 2)),
  ident_2    = c(rep("mock", 4),  rep("8hpi", 2),  rep("CHIKV-low", 2)),
  log_fc     = list(
    c(0.15, Inf), c(-Inf, -0.15),  # 8 hpi up and down
    c(0.25, Inf), c(-Inf, -0.25),  # 24 hpi up and down
    c(0.25, Inf), c(-Inf, -0.25),  # merged up and down
    c(0.15, Inf), c(0.15, Inf)     # CHIKV-high up
  )
)

degs <- deg_args %>%
  pmap(~ {
    args <- list(...)

    if      (all(args$log_fc > 0)) typ <- "-up"
    else if (all(args$log_fc < 0)) typ <- "-down"
    else                           typ <- ""
    
    prfx <- str_remove(args$so_in, "^so_")
    # file <- str_c(prfx, "_subtype_chikv", typ, "_markers.tsv")
    file <- str_c(prfx, "_lectype_chikv", typ, "_markers.tsv")
    file <- here("results/tables", file)
    
    d <- eval(sym(args$so_in)) %>%
      get_degs(
        log_fc  = args$log_fc,
        file    = file,
        ident_1 = args$ident_1,
        ident_2 = args$ident_2,
        treat_clmn = args$treat_clmn,
        type_clmn  = "lec_type"
      ) %>%
      list()
    
    names(d) <- str_c(args$so_in, typ)
    
    d
  }) %>%
  flatten()

rm(so_8_chikv, so_24_chikv)
```

```{r "GO"}
# Prepare GO data to measure similarity
go_sim_data <- godata(
  OrgDb   = org.Mm.eg.db,
  keytype = "SYMBOL",
  ont     = "BP"
)

# Get GO terms
# only use top 200 DEGs
# go_degs <- degs[grepl("^so_(8|merge)-up$|_chikv-up$", names(degs))] %>%
go_degs <- degs[grepl("^so_(8|merge)-up$", names(degs))] %>%
  map(~ {
    .x %>%
      arrange(max_pval) %>%
      split(.$subtype) %>%
      map(pull, gene) %>%
      map(head, 200)
  })

go <- go_degs %>%
  imap(~ {
    typ   <- str_remove(.y, ".+(?=-)")
    so_in <- str_remove(.y, "-.+$")
    prfx  <- str_remove(so_in, "^so_")
    # file  <- str_c(prfx, "_lectype_chikv", typ, "_go")
    file  <- str_c(prfx, "_subtype_chikv", typ, "_go")
    file  <- here("results/tables", file)
    
    .x %>%
      get_go(
        so_in = eval(sym(so_in)),
        file  = file
      )
  })
```

```{r "GO clusters"}
# Only use terms with >= 3 overlapping genes for 8 hpi and 10 for 24 hpi
so_8_re <- "^(so_8-|so_[0-9]+_chikv)"

clusters <- go %>%
  imap(~ {
    ovlp <- ifelse(grepl(so_8_re, .y), 3, 10)
    
    get_clusters(.x, k = 3, n_overlap = ovlp, n_shared = 1)
  }) %>%
  discard(is.null)

# Calculate similarity between 8hpi and 24hpi terms
clusters_merged <- clusters$`so_merge-up`$clusters %>%
  mutate(cluster = str_c("24hpi-", cluster))

clusters_merged <- clusters$`so_8-up`$clusters %>%
  mutate(cluster = str_c("8hpi-", cluster)) %>%
  bind_rows(clusters_merged)

cluster_lvls <- unique(clusters_merged$cluster)

clusters_merged <- clusters_merged %>%
  split(.$cluster) %>%
  map(pull, ID)

comps <- names(clusters_merged) %>%
  expand.grid(names(clusters_merged)) %>%
  as.list()

cluster_sim <- map2_dfr(comps$Var1, comps$Var2, ~ {
  sim <- mgoSim(
    GO1 = clusters_merged[[.x]],
    GO2 = clusters_merged[[.y]],
    semData = go_sim_data
  )
  
  tibble(var1 = .x, var2 = .y, sim = sim)
})

# Create heatmap
sim_heatmap <- cluster_sim %>%
  mutate(
    var1 = fct_relevel(var1, cluster_lvls),
    var2 = fct_relevel(var2, rev(cluster_lvls))
  ) %>%
  ggplot(aes(var1, var2, fill = sim)) +
  geom_tile() +
  scale_fill_gradientn(colours = c("lightblue", "white", "red")) +
  djvdj_theme() +
  theme(
    aspect.ratio = 1,
    axis.title = element_blank()
  )
```

```{r "GO heatmaps"}
# # Cluster titles
# clst_matches <- cluster_sim %>%
#   filter(var1 != var2) %>%
#   group_by(var1) %>%
#   filter(
#     sim > 0.6,
#     sim == max(sim[sim < 1])
#   ) %>%
#   rowwise() %>%
#   mutate(matches = list(sort(as.character(c(var1, var2))))) %>%
#   pull(matches) %>%
#   unique()

ttls <- as_labeller(c(`1` = "Innate Immune Response", `2` = "Inflammatory Response"))

# Cluster colors
clrs_8  <- c(`1` = "#E69F00", `2` = "#56B4E9")
clrs_24 <- c(`1` = "#D7301F", `2` = "#6A51A3")

# Create heatmaps
# pval, qval, n_overlap cutoffs should match those used for clustering
go_heat <- clusters %>%
  imap(~ {
    go_in  <- go[[.y]]
    ovlp   <- ifelse(grepl(so_8_re, .y), 3, 10)
    n_clst <- ifelse(grepl(so_8_re, .y), 1, 2)
    n_gns  <- ifelse(grepl(so_8_re, .y), 10, 20)
    
    if (grepl("^so_8-", .y)) clrs <- clrs_8
    else                     clrs <- clrs_24
    
    .x$clusters %>%
      create_go_heatmap(
        go_in      = go_in,
        n_overlap  = ovlp,
        n_genes    = n_gns,
        n_clusters = n_clst,
        clrs       = clrs,
        cluster_labels = ttls
      )
  })

# # Calculate frequency of words for each GO cluster
# clusters %>%
#   map_dfr(~ {
#     .x$clusters %>%
#       split(.$cluster) %>%
#       map_dfr(~ {
#         .x %>%
#           filter(cluster == 1) %>%
#           pull(ID) %>%
#           simplifyEnrichment::keyword_enrichment_from_GO()
#       })
#   })
```

```{r "8hpi examples"}
# Example genes to plot
obj <- "so_8-up"

gns <- go[[obj]]@compareClusterResult %>%
  as_tibble() %>%
  right_join(go_heat[[obj]]$terms, by = "Description") %>%
  mutate(geneID = str_split(geneID, "/")) %>%
  unnest(geneID) %>%
  group_by(geneID, cluster) %>%
  summarize(n = n_distinct(Cluster), .groups = "drop") %>%
  distinct(geneID, .keep_all = TRUE) %>%
  arrange(cluster, desc(n))

top_sig <- degs[[obj]] %>%
  filter(gene %in% gns$geneID) %>%
  group_by(gene) %>%
  summarize(pval = min(max_pval), .groups = "drop")

gns <- gns %>%
  left_join(top_sig, by = c(geneID = "gene")) %>%
  arrange(desc(n), pval) %>%
  group_by(cluster) %>%
  dplyr::slice(1:3)

gns <- set_names(as.character(gns$cluster), gns$geneID)

# Create plots
examples_8 <- create_gene_plots(
  exp_data   = list("8hpi" = so_8, "24hpi" = so_merge),
  deg_data   = list("8hpi" = degs$`so_8-up`, "24hpi" = degs$`so_merge-up`),
  gns        = gns,
  clrs       = clrs_8,
  cell_types = 8
  # cell_types = NULL,
  # only_show_upreg = FALSE
)
```

```{r "24hpi examples"}
# Example genes to plot
# HAND SELECTING SOME FAVORITES
obj <- "so_merge-up"

gns <- go[[obj]]@compareClusterResult %>%
  as_tibble() %>%
  right_join(go_heat[[obj]]$terms, by = "Description") %>%
  mutate(geneID = str_split(geneID, "/")) %>%
  unnest(geneID) %>%
  group_by(geneID, cluster) %>%
  summarize(n = n_distinct(Cluster), .groups = "drop") %>%
  distinct(geneID, .keep_all = TRUE) %>%
  arrange(cluster, desc(n))

top_sig <- degs[[obj]] %>%
  filter(gene %in% gns$geneID) %>%
  group_by(gene) %>%
  summarize(pval = min(max_pval), .groups = "drop")

gns <- gns %>%
  left_join(top_sig, by = c(geneID = "gene")) %>%
  arrange(cluster, desc(n), pval) %>%
  filter(geneID %in% c("Cxcl9", "Cxcl10", "Ccl2", "Ccl7", "Gbp2", "Gbp6"))

# gns %>%
#   filter(grepl("C[xc][clr]|I[fs][irg]", geneID))

gns <- set_names(as.character(gns$cluster), gns$geneID)

# Create plots
examples_24 <- create_gene_plots(
  exp_data   = list("8hpi" = so_8, "24hpi" = so_merge),
  deg_data   = list("8hpi" = degs$`so_8-up`, "24hpi" = degs$`so_merge-up`),
  gns        = gns,
  clrs       = clrs_24,
  cell_types = 8
  # cell_types = NULL,
  # only_show_upreg = FALSE,
)
```

```{r "GO figures", fig.width = 11.8, fig.height = 9}

# # Create final figure
# left <- plot_grid(
#   go_heat$`so_8-up`$heatmap,
#   go_heat$`so_merge-up`$heatmap,
#   labels = c("C", "E"),
#   label_size = ttl_pt2 * 1.5,
#   ncol   = 1,
#   align  = "v",
#   axis   = "r"
# )
# 
# right <- plot_grid(
#   examples_8, examples_24,
#   labels = c("D", "F"),
#   label_size = ttl_pt2 * 1.5,
#   ncol   = 1,
#   align  = "v",
#   axis   = "l"
# )
# 
# plot_grid(
#   left, right,
#   nrow = 1
# )

top <- plot_grid(
  go_heat$`so_8-up`$heatmap, examples_8,
  labels = c("C", "D"),
  label_size = ttl_pt2 * 1.5,
  hjust  = 0.01,
  vjust  = 0.98,
  nrow   = 1,
  align  = "h",
  axis   = "tb"
)

bot <- plot_grid(
  go_heat$`so_merge-up`$heatmap, examples_24,
  labels = c("E", "F"),
  label_size = ttl_pt2 * 1.5,
  hjust  = 0.01,
  nrow   = 1,
  align  = "h",
  axis   = "tb"
)

plot_grid(top, bot, ncol = 1, rel_heights = c(0.64, 1))

```

<br>

### Extended GO analysis {.tabset .tabset-pills}

A.  Dendrogram showing gene ontology modules. GO terms were identified for each cell type and filtered as described for Fig 5. Terms were clustered into 5 modules based on the pairwise overlap between terms.
B.  Enrichment scores are shown for each GO module identified for each timepoint, as described in Fig 5.
C.  Top upregulated genes are shown for each GO module as described in Fig 5.

```{r "EXPANDED FIGURES", fig.width = 12, fig.height = 19, results = "asis"}
# Split GO objects by cell type
go_type <- go %>%
  imap(~ {
    obj  <- .x
    typs <- unique(obj@compareClusterResult$Cluster)
    base <- str_remove(.y, "(?<=-).+")
    nms  <- str_c(base, c("all", as.character(typs)))
    
    l <- map(typs, ~ filter(obj, Cluster == .x))
    l <- append(list(obj), l)
    
    names(l) <- nms
    
    l
  }) %>%
  flatten()

# Create expanded GO figures
create_go_summary_figures <- function(go_in, sample_name, n_clsts = 5,
                                      n_terms = 6, n_genes = 4) {
  
  # Cluster GO terms
  ovlp    <- ifelse(grepl(so_8_re, sample_name), 3, 10)
  shrd    <- ifelse(grepl("-all$", sample_name), 2, 1)
  typ_plt <- !grepl("-all$", sample_name)
  
  clsts <- go_in %>%
    get_clusters(
      k         = n_clsts,
      n_overlap = ovlp,
      n_shared  = 1
    )
  
  if (is.null(clsts)) return(NULL)
  
  obj    <- str_remove(sample_name, "-.+$")
  obj    <- str_c(obj, "-up")
  go_typ <- go[[obj]]  # use objects containing all cell types for plotting
  
  # Create tree
  clst_ids <- as.character(unique(sort(clsts$clusters$cluster)))
  
  clst_clrs <- set_names(
    unname(type_cols)[1:n_distinct(clst_ids)],
    clst_ids
  )
  
  cl <- split(
    names(clsts$clusters_object),
    clsts$clusters_object
  )
  
  tr <- ggtree(clsts$object, linewidth = 1)
  
  clades <- cl %>%
    map_int(~ MRCA(tr, .x))
  
  tr <- groupClade(tr, clades, group_name = "cluster") +
    aes(color = cluster) +
    scale_color_manual(values = clst_clrs) +
    geom_tiplab(angle = 90, hjust = 1, nudge_x = -0.1) +
    layout_dendrogram() +
    theme(
      legend.position = "none",
      plot.margin = margin(6, 6, 250, 6)
    )
  
  # Create heatmaps
  heat <- clsts$clusters %>%
    create_go_heatmap(
      go_in      = go_typ,
      n_overlap  = ovlp,
      n_clusters = n_clsts,
      n_terms    = n_terms,
      n_col      = 1,
      free_y     = FALSE,
      clrs       = clst_clrs
    )
  
  heat$heatmap <- heat$heatmap +
    theme(axis.text = element_text(size = 7))
  
  # Select genes to plot
  # tot_n_terms <- clsts$clusters %>%
  #   group_by(cluster) %>%
  #   dplyr::slice(1:n_terms) %>%
  #   nrow
  n_gns <- seq_len(n_genes)
  go_gn <- go_typ
  
  if (typ_plt) go_gn <- go_in
  
  # Example genes to plot
  gns <- go_gn@compareClusterResult %>%
    as_tibble() %>%
    right_join(heat$terms, by = "Description") %>%
    mutate(geneID = str_split(geneID, "/")) %>%
    unnest(geneID) %>%
    group_by(geneID, cluster) %>%
    summarize(n = n_distinct(Cluster), .groups = "drop") %>%
    distinct(geneID, .keep_all = TRUE) %>%
    arrange(cluster, desc(n))
  
  top_sig <- degs[[obj]] %>%
    filter(gene %in% gns$geneID) %>%
    group_by(gene) %>%
    summarize(pval = min(max_pval), .groups = "drop")
  
  gns <- gns %>%
    left_join(top_sig, by = c(geneID = "gene")) %>%
    arrange(desc(n), pval) %>%
    group_by(cluster) %>%
    dplyr::slice(n_gns) %>%
    ungroup()
  
  gns <- set_names(as.character(gns$cluster), gns$geneID)

  # gns <- go_gn@compareClusterResult %>%
  #   as_tibble() %>%
  #   right_join(heat$terms, by = "Description") %>%
  #   mutate(geneID = str_split(geneID, "/")) %>%
  #   unnest(geneID) %>%
  #   group_by(geneID, cluster) %>%
  #   summarize(n = n_distinct(Cluster), .groups = "drop") %>%
  #   distinct(geneID, .keep_all = TRUE) %>%
  #   arrange(cluster, desc(n)) %>%
  #   group_by(cluster) %>%
  #   dplyr::slice(n_gns) %>%
  #   ungroup()
  # 
  # gns <- set_names(
  #   as.character(gns$cluster),
  #   gns$geneID
  # )
  
  # Create gene plots
  gn_plts <- create_gene_plots(
    exp_data   = list("8hpi" = so_8, "24hpi" = so_merge),
    deg_data   = list("8hpi" = degs$`so_8-up`, "24hpi" = degs$`so_merge-up`),
    gns        = gns,
    cell_types = 8,
    clrs       = clst_clrs
  ) +
    theme(
      plot.margin = margin(6, 40, 6, 40, unit = "pt"),
      axis.text   = element_text(size = 7),
      strip.text  = element_text(size = 8)
    )
  
  # Create final figure
  bot <- plot_grid(
    heat$heatmap + theme(plot.margin = margin(6, 40, 6, 40, unit = "pt")),
    gn_plts,
    nrow = 1,
    labels = c("B", "C"),
    rel_widths = c(0.9, 1),
    align = "h",
    axis  = "tb"
  )
  
  res <- plot_grid(
    tr, bot,
    ncol = 1,
    rel_heights = c(0.3, 1),
    labels = "A"
  )
  
  res
}

go_type[grepl("-all$", names(go_type))] %>%
  iwalk(~ {
    ttl <- str_remove(.y, "^so_")
    ttl <- str_replace(ttl, "^merge", "24hpi-8hpi")
    
    cat("\n\n#### ", ttl, "\n\n")
    
    plt <- create_go_summary_figures(
      go_in = .x,
      sample_name = .y
    )
    
    if (is.null(plt)) {
      plt <- ggplot() +
        geom_blank()
    }
    
    print(plt)
    cat("\n\n---\n\n<br>\n\n<br>\n\n")
  })
```



```{r "GO module scores", eval = FALSE}

# Object to use for calculating scores
obj <- so_merge

# Top terms
mod_terms <- clusters$`so_8-up`$clusters %>%
  filter(cluster == 1) %>%
  mutate(rank = row_number()) %>%
  dplyr::select(Description, ID, rank)

mod_terms <- clusters$`so_merge-up`$clusters %>%
  filter(cluster == 1) %>%
  head(10)
  # left_join(mod_terms, by = c("Description", "ID"))

mod_terms <- set_names(mod_terms$Description, mod_terms$ID)

# Pull genes for each term
mart <- biomaRt::useMart(
  biomart = "ensembl",
  dataset = "mmusculus_gene_ensembl"
)

term_gns <- unname(mod_terms) %>%
  set_names() %>%
  map(fetch_genes, mart = mart)

term_gns <- term_gns %>%
  map(~ {
    .x[.x %in% rownames(obj)]
  })

# Calculate module scores
clmn_nms <- names(term_gns) %>%
  str_replace_all("[- ]", "_")

clmn_nms <- set_names(
  str_c(clmn_nms, seq_along(clmn_nms)),
  clmn_nms
)
  
# so_merge <- so_merge %>%
obj <- obj %>%
  AddModuleScore(features = term_gns, name = names(clmn_nms))

obj <- obj %>%
  mutate_meta(~ {
    .x %>%
      dplyr::rename(!!!clmn_nms)
  })

# Create boxplot
# lvls <- c("mock", "8hpi")
lvls <- c("8hpi", "24hpi")

plt_dat <- obj@meta.data %>%
  as_tibble(rownames = ".cell_id") %>%
  pivot_longer(all_of(names(clmn_nms))) %>%
  dplyr::select(orig.ident, treatment, rep, subtype, name, value)

plt_dat %>%
  mutate(
    treatment = fct_relevel(treatment, lvls),
    subtype = fct_reorder(subtype, value, .desc = TRUE)
  ) %>%
  ggplot(aes(subtype, value, alpha = treatment, fill = subtype)) +
  geom_boxplot(outlier.size = 0.1, outlier.alpha = 1, position = position_dodge2(preserve = "single")) +
  facet_wrap(~ name, scales = "free_y") +
  scale_alpha_manual(values = c(0.5, 1)) +
  guides(fill = "none") +
  djvdj_theme() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )


```

```{r "GSEA MARKERS", eval = FALSE}
# Cell types to test
typs <- so_24 %>%
  get_cell_types("lec_type", "orig.ident", n_cells = 3)

# Find marker genes for each cell type
marks_path <- here(params$so_dir, "all_markers.tsv")

if (!file.exists(marks_path)) {
  Idents(so_24) <- so_24 %>%
    FetchData("treatment")
  
  marks <- typs %>%
    map_dfr(~ {
      so_24 %>%
        subset(subset = lec_type == .x) %>%
        find_conserved_markers(
          ident_1  = "CHIKV",
          grp_var  = "rep",
          p_max    = 1.1,
          fc_range = c(-Inf, Inf)
        ) %>%
        mutate(cell_type = .x)
    }) %>%
    arrange(desc(avg_log2FC))
  
  marks %>%
    write_tsv(marks_path)
  
} else {
  marks <- read_tsv(marks_path)
}

# Exclude ribosomal protein and mitochondrial genes
marks <- marks %>%
  filter(!grepl("^Rp[sl]|^mt-", gene))

```

```{r "H CLUSTERING", eval = FALSE}

# Marker stats columns
reps     <- unique(so_24$rep)
fc_clmns <- str_c(reps, "_avg_log2FC")
p_clmns  <- str_c(reps, "_p_val_adj")

# Format matrix
# Only include genes >1.25 fold change and <0.05 adj p-value
# This will cluster based only on fold changes for genes/cell types
# sinificantly upregulated, genes that are not upregulated are set as 0
sig_marks <- marks %>%
  filter(
    if_all(all_of(fc_clmns), ~ .x > log2(1.25)),
    if_all(all_of(p_clmns),  ~ .x < 0.05)
  ) %>%
  rowwise() %>%
  mutate(max_p = max(!!!syms(p_clmns))) %>%
  ungroup() %>%
  dplyr::select(gene, cell_type, avg_log2FC, max_p)
  
mat <- sig_marks %>%
  dplyr::select(-max_p) %>%
  pivot_wider(
    names_from  = cell_type,
    values_from = avg_log2FC,
    values_fill = 0
  ) %>%
  column_to_rownames("gene") %>%
  t() %>%
  scale() %>%
  t()

# Hierarchical clustering
clsts_path <- here(params$so_dir, "gene_clusters.tsv")

if (!file.exists(clsts_path)) {
  hcl <- mat %>%
    dist() %>%
    hclust(method = "ward.D")
  
  clsts <- cutree(hcl, k = 10)
  
  clsts <- tibble(
    gene    = names(clsts),
    cluster = as.character(unname(clsts))
  )
  
  clsts %>%
    write_tsv(clsts_path)
  
} else {
  clsts <- read_tsv(clsts_path, col_types = cols(cluster = col_character()))
}

# Summarize gene fold change for each cluster
# Calculate overall average fold change and p-value for each cell_type
# Use average fold change to identify the predominant cell types upregulated for
# each cluster
clst_dat <- marks %>%
  dplyr::select(gene, cell_type, avg_log2FC, max_pval) %>%
  right_join(clsts, by = "gene") %>%
  group_by(cluster, cell_type) %>%
  mutate(
    type_log2FC = mean(avg_log2FC),
    type_pval   = mean(max_pval),
  ) %>%
  ungroup()

# Only include cell type if meets FC and p threshold for the cluster
clst_dat <- clst_dat %>%
  group_by(cluster) %>%
  mutate(
    max_fc     = max(type_log2FC),
    max_fc_lim = max(type_log2FC[type_log2FC < unique(max_fc)]) * 1.5
  ) %>%
  filter(
    cell_type %in% cell_type[type_log2FC > log2(1.25) & type_pval < 0.05]
  )

# Further filter cell types for each cluster
# if one cell type is >1.5 fold higher than other cell types,
# remove other cell types
clst_dat <- clst_dat %>%
  filter(
    n_distinct(cell_type) == 1 |
    cell_type %in% cell_type[
      (type_log2FC == max_fc & max_fc > max_fc_lim) |
      all(type_log2FC <= max_fc_lim)
    ]
  ) %>%
  mutate(
    up_types = list(unique(cell_type)),
    n_types = n_distinct(cell_type)
  ) %>%
  ungroup() %>%
  mutate(shared = n_types >= 5)

# Merge clusters with >4 positive cell types
# Create data.frame with new cluster IDs
clst_dat <- clst_dat %>%
  mutate(cluster = ifelse(shared, max(cluster[shared]), cluster))

```

```{r "H CLUSTERING HEATMAP", eval = FALSE}

# Identify top 6 clusters
up_types <- clst_dat %>%
  distinct(cluster, gene, up_types, n_types) %>%
  group_by(cluster, up_types, n_types) %>%
  summarize(n = n_distinct(gene), .groups = "drop")

top_clsts <- up_types %>%
  group_by(cluster, n_types, n) %>%
  summarize(id = map_chr(up_types, str_c, collapse = "/"), .groups = "drop") %>%
  mutate(id = ifelse(n_types >= 5, "interferon response", id)) %>%
  group_by(cluster, id) %>%
  summarize(n = sum(n), .groups = "drop") %>%
  arrange(desc(n)) %>%
  mutate(
    rnk = row_number(),
    id  = str_replace(id, "_", " "),
    id = str_c(id, "\n", n, " genes")
  ) 

clst_lvls <- set_names(top_clsts$id, top_clsts$cluster)

top_clsts <- head(top_clsts, 6)
  
# Format scaled data for plotting
# Create new table with revised cluster IDs
# Want to show fold changes for all genes/cell types when creating heatmaps,
# not just upregulated genes
clsts <- clst_dat %>%
  distinct(gene, cluster) %>%
  filter(cluster %in% top_clsts$cluster)

plt_dat <- marks %>%
  filter(
    gene %in% unique(sig_marks$gene),
    cell_type %in% colnames(mat)
  ) %>%
  
  dplyr::select(gene, cell_type, avg_log2FC) %>%
  pivot_wider(
    names_from  = cell_type,
    values_from = avg_log2FC,
    values_fill = 0
  ) %>%
  column_to_rownames("gene") %>%
  t() %>%
  scale() %>%
  t() %>%

  as_tibble(rownames = "gene") %>%
  left_join(clsts, by = "gene") %>%
  filter(!is.na(cluster)) %>%
  pivot_longer(-c(gene, cluster), names_to = "cell_type") %>%
  mutate(
    cell_type = as.factor(cell_type),
    cluster = fct_relevel(cluster, top_clsts$cluster)
  ) %>%
  arrange(cluster, cell_type)
  
# ORIGINAL VERSION
# plt_dat <- mat %>%
#   as_tibble(rownames = "gene") %>%
#   left_join(clsts, by = "gene") %>%
#   filter(!is.na(cluster)) %>%  # NAs are genes not found in any cluster
#   pivot_longer(-c(gene, cluster), names_to = "cell_type") %>%
#   mutate(
#     cluster = fct_relevel(cluster, top_clsts$cluster)
#   ) %>%
#   arrange(cluster, cell_type)

# Format data for drawing heatmap boxes
type_lvls <- levels(plt_dat$cell_type)
type_lvls <- set_names(seq_along(type_lvls), type_lvls)

bx_dat <- up_types %>%
  filter(n_types < 3) %>%
  unnest(up_types) %>%
  group_by(cluster, up_types) %>%
  mutate(
    x = type_lvls[up_types],
    x = list(c(x - 0.5, x + 0.5))
  ) %>%
  ungroup() %>%
  unnest(x) %>%
  filter(cluster %in% plt_dat$cluster) %>%
  mutate(cluster = fct_relevel(cluster, levels(plt_dat$cluster)))

# Create heatmaps
clst_clrs <- c(
  "3" = lec_type_cols[["unassigned-LEC"]],
  "8" = lec_type_cols[["BEC"]],
  "5" = lec_type_cols[["PvC"]],
  "2" = lec_type_cols[["Macrophages"]],
  "4" = lec_type_cols[["Marco_LEC"]],
  "9" = lec_type_cols[["FRC"]]
)

h_heat <- plt_dat %>%
  # ggplot(aes(cell_type, gene, fill = value)) +
  # scale_fill_gradient2(low = "grey85", mid = "white", high = "#D7301F") +
  # scale_fill_gradient2(low = "#56B4E9", mid = "white", high = "#D7301F") +
  # guides(fill = guide_colorbar(
  #   ticks = FALSE,
  #   title.position = "bottom",
  #   barwidth = unit(150, "pt"), barheight = unit(10, "pt")
  # )) +
  
  ggplot(aes(cell_type, gene, fill = cluster, alpha = value)) +
  scale_alpha_continuous(range = c(0.01, 1)) +
  scale_fill_manual(values = clst_clrs) +
  guides(
    fill = "none",
    alpha = guide_legend(
      label.position = "bottom",
      keyheight = unit(7, "pt"),
      title = "z-score",
      title.position = "top"
    )
  ) +
  geom_vline(data = bx_dat, aes(xintercept = x)) +
  geom_tile() +
  facet_wrap(
    ~ cluster,
    scales         = "free_y",
    strip.position = "left",
    labeller       = as_labeller(clst_lvls),
    ncol = 1
  ) +
  scale_x_discrete(position = "top") +
  djvdj_theme() +
  theme(
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.x  = element_text(angle = 90, hjust = 0, vjust = 0.5),
    axis.title   = element_blank(),
    legend.position = "bottom",
    legend.title    = element_text(size = txt_pt1, hjust = 0.5),
    strip.clip = "off"
  )

```

```{r "H CLUSTERING GO", eval = FALSE}

# Format genes for GO analysis
go_gns <- clsts %>%
  split(as.character(.$cluster)) %>%
  map(pull, gene)

# Identify GO terms
go_file <- file.path(params$so_dir, "gene_clusters_go.tsv")

if (!file.exists(go_file)) {
  go_res <- go_gns %>%
    gost(
      organism = "mmusculus",
      ordered_query = FALSE,
      evcodes = TRUE
    ) %>%
    .$result %>%
    filter(
      source %in% c("GO:BP", "GO:MF", "KEGG"),
      p_value < 0.05,
      term_size < 500
    ) %>%
    arrange(p_value)
  
  go_res %>%
    write_tsv(go_file)

} else {
  go_res <- read_tsv(go_file, col_types = cols(query = col_character()))
}

# Create GO bargraphs
lab_fn <- function(x) {
  x %>%
    str_remove("^[0-9]+-") %>%
    str_trunc(80) %>%
    str_wrap(45)
}

go_bars <- go_res %>%
  group_by(query) %>%
  dplyr::slice(1:6) %>%
  ungroup() %>%
  dplyr::select(-parents) %>%
  mutate(
    term_name = str_c(query, "-", term_name),
    term_name = fct_reorder(term_name, p_value, .desc = TRUE),
    query     = fct_relevel(query, names(clst_lvls))
  ) %>%
  ggplot(aes(-log10(p_value), term_name, fill = query)) +
  geom_col() +
  labs(x = "-log10(p-value)") +
  facet_wrap(~ query, scales = "free_y", strip.position = "right", ncol = 1) +
  scale_fill_manual(values = clst_clrs) +
  scale_y_discrete(labels = lab_fn) +
  djvdj_theme() +
  theme(
    axis.title.y = element_blank(),
    axis.title.x = element_text(size = txt_pt1),
    legend.position = "none",
    strip.text = element_blank()
  )

```

```{r "H CLUSTERING TOP GENES", eval = FALSE}

# gns <- c("Cd74", "H2-Ab1", "Lgmn", "Angpt2", "Pik3r1", "Gja1", "Ywhag")    # BEC
# gns <- c("Vcam1", "Akt3", "Cdh5", "Ccl5", "F11r", "Olr1", "Dst", "Nlgn2")  # Marco
# gns <- c("Cxcl9", "Cxcl10", "Ccl2", "Ccl7", "Ccl4", "Il1b", "Il6", "Tnf")  # All
# gns <- c("Nod1", "Tlr3")                                                   # FRC/PvC
# gns <- c("Oas2", "Oas3", "Fgl2", "Irf1", "Cxcl10")                         # Mac

gns <- c("Irf7", "Ccl2", "Cxcl9", "Oas3", "Vcam1", "Tlr3")

# Format plotting data
dat <- so_24 %>%
  FetchData(c("treatment", "orig.ident", "lec_type", gns)) %>%
  rownames_to_column("cell_id") %>%
  pivot_longer(all_of(gns), names_to = "gene") %>%
  filter(lec_type %in% colnames(mat)) %>%
  mutate(
    treatment = fct_relevel(treatment, treats),
    gene = fct_relevel(gene, gns)
  )
  
# Format data for p-value labels
p_dat <- sig_marks %>%
  mutate(p_lab = format_pvalue(max_p)) %>%
  dplyr::rename(lec_type = cell_type) %>%
  filter(gene %in% gns) %>%
  mutate(gene = fct_relevel(gene, gns))

# Create boxplots
bx_fn <- function(x) str_c(x, "\nexpression")

gn_bxs <- dat %>%
  ggplot(aes(lec_type, value, alpha = treatment, fill = lec_type, color = lec_type)) +
  
  geom_boxplot(
    outlier.size = 0.001,
    position = position_dodge2(preserve = "single"),
    key_glyph = draw_key_point
  ) +

  geom_richtext(
    aes(lec_type, Inf, label = p_lab),
    data = p_dat,
    alpha = 1,
    size  = 5 / .pt,
    color = "black",
    fill  = NA,
    label.color = NA,
    vjust = "inward"
  ) +
    
  facet_wrap(
    ~ gene,
    scales = "free_y",
    ncol = 1,
    strip.position = "left",
    labeller = as_labeller(bx_fn)
  ) +
  guides(
    fill = "none",
    color = "none",
    alpha = guide_legend(override.aes = list(shape = 15, alpha = c(0.5, 1), size = 4))
  ) +
  scale_y_continuous(expand = expansion(c(0.05, 0.2))) +
  scale_alpha_manual(values = c(0.1, 0.6)) +
  scale_fill_manual(values = lec_type_cols) +
  scale_color_manual(values = lec_type_cols) +
  djvdj_theme() +
  theme(
    axis.title      = element_blank(),
    axis.text.x     = element_text(angle = 45, hjust = 1),
    legend.title    = element_blank(),
    legend.position = "top",
    strip.placement = "outside"
    # plot.margin = margin(15, 15, 15, 30),
  )

```

```{r "H FIGURE", fig.height = 10, fig.width = 10, eval = FALSE}

plot_grid(
  h_heat, go_bars, gn_bxs,
  align = "h",
  axis  = "tb",
  nrow  = 1,
  rel_widths = c(0.75, 1, 1),
  labels = c("A", "B", "C"),
  label_size = ttl_pt2 * 1.5
)

```

```{r "H SUPP", eval = FALSE}

# Format cluster labels
tab_labs <- clst_lvls %>%
  map_chr(str_remove, "\n.+") %>%
  map_chr(str_replace, "[/ ]", "_")

# Format table for gene clusters
tab_dat <- clst_dat %>%
  group_by(gene, cluster) %>%
  summarize(
    avg_log2FC = mean(avg_log2FC),
    # pval       = mean(max_pval),
    .groups    = "drop"
  ) %>%
  mutate(cluster = tab_labs[cluster]) %>%
  group_by(cluster) %>%
  mutate(n_genes = n_distinct(gene)) %>%
  ungroup() %>%
  arrange(desc(n_genes), desc(avg_log2FC)) %>%
  as.data.frame()

# Write excel file
tab_labs %>%
  walk(~ {
    tab_dat %>%
      filter(cluster == .x) %>%
      xlsx::write.xlsx(
        file      = file.path(params$so_dir, "gene_clusters.xlsx"),
        sheetName = .x,
        append    = TRUE,
        col.names = TRUE,
        row.names = FALSE
      )
  })

```

```{r "CLUSTERING IFN GENES", eval = FALSE}

# Cluster IFN genes
# EXCLUDE CD45+ CELL TYPES
cd45_typs <- c("T cells", "B cells", "Macrophages", "unassigned")

ifn_clst <- top_clsts %>%
  filter(grepl("interferon", id)) %>% 
  pull(cluster)

ifn_gns <- clsts %>%
  filter(cluster == ifn_clst) %>%
  pull(gene)

ifn_mat <- mat[ifn_gns, !colnames(mat) %in% cd45_typs]

hcl <- ifn_mat %>%
  dist() %>%
  hclust(method = "ward.D")

ifn_clsts <- cutree(hcl, k = 10)

ifn_clsts <- tibble(
  gene    = names(ifn_clsts),
  cluster = as.character(unname(ifn_clsts))
)

# Format data for heatmaps
# Summarize gene fold change for each cluster
# Calculate overall average fold change and p-value for each cell_type
# Use average fold change to identify the predominant cell types upregulated for
# each cluster
clst_dat <- marks %>%
  dplyr::select(gene, cell_type, avg_log2FC, max_pval) %>%
  right_join(ifn_clsts, by = "gene") %>%
  group_by(cluster, cell_type) %>%
  mutate(
    type_log2FC = mean(avg_log2FC),
    type_pval   = mean(max_pval),
  ) %>%
  ungroup()

# Only include cell type if meets FC and p threshold for the cluster
# EXCLUDE CD45+ CELL TYPES
clst_dat <- clst_dat %>%
  group_by(cluster) %>%
  mutate(
    max_fc     = max(type_log2FC),
    max_fc_lim = max(type_log2FC[type_log2FC < unique(max_fc)]) * 1.5
  ) %>%
  filter(
    cell_type %in% cell_type[type_log2FC > log2(1.25) & type_pval < 0.05],
    !cell_type %in% cd45_typs
  )

# Further filter cell types for each cluster
# if one cell type is >1.5 fold higher than other cell types,
# remove other cell types
clst_dat <- clst_dat %>%
  filter(
    n_distinct(cell_type) == 1 |
    cell_type %in% cell_type[
      (type_log2FC == max_fc & max_fc > max_fc_lim) |
      all(type_log2FC <= max_fc_lim)
    ]
  ) %>%
  mutate(
    up_types = list(unique(cell_type)),
    n_types = n_distinct(cell_type)
  ) %>%
  ungroup() %>%
  mutate(shared = n_types >= 5)

# Merge clusters with >4 positive cell types
# Create data.frame with new cluster IDs
# clst_dat <- clst_dat %>%
#   mutate(cluster = ifelse(shared, max(cluster[shared]), cluster))

```

```{r "IFN HEATMAPS", eval = FALSE}

# Identify top 6 clusters
up_types <- clst_dat %>%
  distinct(cluster, gene, up_types, n_types) %>%
  group_by(cluster, up_types, n_types) %>%
  summarize(n = n_distinct(gene), .groups = "drop")

top_clsts <- up_types %>%
  group_by(cluster, n_types, n) %>%
  summarize(id = map_chr(up_types, str_c, collapse = "/"), .groups = "drop") %>%
  mutate(id = ifelse(n_types >= 5, "interferon response", id)) %>%
  group_by(cluster, id) %>%
  summarize(n = sum(n), .groups = "drop") %>%
  arrange(desc(n)) %>%
  mutate(
    rnk = row_number(),
    id  = str_replace(id, "_", " "),
    id = str_c(id, "\n", n, " genes")
  ) 

clst_lvls <- set_names(top_clsts$id, top_clsts$cluster)

top_clsts <- head(top_clsts, 6)
  
# Format scaled data for plotting
# Create new table with revised cluster IDs
# Want to show fold changes for all genes/cell types when creating heatmaps,
# not just upregulated genes
clsts <- clst_dat %>%
  distinct(gene, cluster) %>%
  filter(cluster %in% top_clsts$cluster)

plt_dat <- marks %>%
  filter(
    gene %in% unique(sig_marks$gene),
    cell_type %in% colnames(ifn_mat)
  ) %>%
  
  dplyr::select(gene, cell_type, avg_log2FC) %>%
  pivot_wider(
    names_from  = cell_type,
    values_from = avg_log2FC,
    values_fill = 0
  ) %>%
  column_to_rownames("gene") %>%
  t() %>%
  scale() %>%
  t() %>%

  as_tibble(rownames = "gene") %>%
  left_join(clsts, by = "gene") %>%
  filter(!is.na(cluster)) %>%
  pivot_longer(-c(gene, cluster), names_to = "cell_type") %>%
  mutate(
    cell_type = as.factor(cell_type),
    cluster = fct_relevel(cluster, top_clsts$cluster)
  ) %>%
  arrange(cluster, cell_type)

# Format data for drawing heatmap boxes
type_lvls <- levels(plt_dat$cell_type)
type_lvls <- set_names(seq_along(type_lvls), type_lvls)

bx_dat <- up_types %>%
  filter(n_types < 3) %>%
  unnest(up_types) %>%
  group_by(cluster, up_types) %>%
  mutate(
    x = type_lvls[up_types],
    x = list(c(x - 0.5, x + 0.5))
  ) %>%
  ungroup() %>%
  unnest(x) %>%
  filter(cluster %in% plt_dat$cluster) %>%
  mutate(cluster = fct_relevel(cluster, levels(plt_dat$cluster)))

# Create heatmaps
clst_clrs <- c(
  "3" = lec_type_cols[["unassigned-LEC"]],
  "8" = lec_type_cols[["BEC"]],
  "5" = lec_type_cols[["PvC"]],
  "2" = lec_type_cols[["Macrophages"]],
  "4" = lec_type_cols[["Marco_LEC"]],
  "9" = lec_type_cols[["FRC"]]
)

h_heat <- plt_dat %>%
  ggplot(aes(cell_type, gene, fill = cluster, alpha = value)) +
  scale_alpha_continuous(range = c(0.01, 1)) +
  scale_fill_manual(values = clst_clrs) +
  guides(
    fill = "none",
    alpha = guide_legend(
      label.position = "bottom",
      keyheight = unit(7, "pt"),
      title = "z-score",
      title.position = "top"
    )
  ) +
  geom_vline(data = bx_dat, aes(xintercept = x)) +
  geom_tile() +
  facet_wrap(
    ~ cluster,
    scales         = "free_y",
    strip.position = "left",
    labeller       = as_labeller(clst_lvls),
    ncol = 1
  ) +
  scale_x_discrete(position = "top") +
  djvdj_theme() +
  theme(
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.x  = element_text(angle = 90, hjust = 0, vjust = 0.5),
    axis.title   = element_blank(),
    legend.position = "bottom",
    legend.title    = element_text(size = txt_pt1, hjust = 0.5),
    strip.clip = "off"
  )

```

# P01 figures

## Figure 1

```{r "8hpi type 24hpi chikv counts"}
# 8 hpi cell types
type_8 <- so_8 %>%
  plot_scatter(
    "lec_type",
    plot_colors = lec_type_cols,
    plot_lvls   = NULL,
    size = 0.2,
    label_params = list(size = txt_pt2)
  ) +
  umap_theme +
  theme(
    aspect.ratio = 0.9,
    legend.title = element_blank(), legend.key.height = unit(30, "pt")
  )

# 24 hpi CHIKV counts
pseudo <- so_24$pct_CHIKV
pseudo <- min(pseudo[pseudo > 0]) / 2

chikv_24 <- so_24@meta.data %>%
  arrange(pct_CHIKV) %>%
  ggplot(aes(UMAP_1, UMAP_2, fill = pct_CHIKV + pseudo)) +
  geom_point_trace(
    color = "grey",
    trace_position = "bottom",
    size = 0.2
  ) +
  scale_fill_gradientn(colours = c("white", "#D7301F"), labels = scales::label_number()) +
  guides(fill = guide_colorbar(title.position = "top", ticks = FALSE, title = "% CHIKV\ncounts")) +
  umap_theme +
  theme(
    aspect.ratio         = 0.9,
    legend.position      = "top",
    legend.title         = element_text(hjust = 0.5, size = ttl_pt2 * 1.5),
    legend.text          = element_text(angle = 45, hjust = 1), 
    legend.direction     = "horizontal",
    legend.justification = 0.2,
    legend.key.height    = unit(30, "pt"),
    legend.key.width     = unit(5, "pt")
  )

# 24 hpi Marco expression
marco_24 <- so_24 %>%
  create_gene_boxplot(
    "Marco", "Marco_LEC",
    clr = "#D7301F",
    pval_y = 5.8
  ) +
  theme(axis.text.x = element_text(hjust = c(0.95, 0.5, 0.05)))
```

```{r "P01 figure", fig.height = 20, fig.width = 18}
# Adjust fraction bargraphs
frac_24 <- frac_24 +
  theme(
    aspect.ratio = 0.2,
    plot.margin  = margin(5, 5, 5, 25),
    axis.text.x  = element_text(size = txt_pt2)
  )

frac_8 <- frac_8 +
  theme(
    aspect.ratio = 0.2,
    plot.margin  = margin(5, 5, 5, 25),
    axis.text.x  = element_text(size = txt_pt2)
  )

# Adjust CHIKV count UMAPs
A <- A +
  guides(fill = guide_colorbar(title.position = "top", ticks = FALSE, title = "% CHIKV\ncounts")) +
  theme(
    legend.position = "right",
    legend.title = element_text(size = ttl_pt1, angle = 0),
    legend.text  = element_text(size = txt_pt1, angle = 0),
    legend.direction = "vertical",
    legend.key.height    = unit(30, "pt"),
    legend.key.width     = unit(5, "pt")
  )

chikv_24 <- chikv_24 +
  theme(
    legend.position = "right",
    legend.title = element_text(size = ttl_pt1, angle = 0),
    legend.text  = element_text(size = txt_pt1, angle = 0),
    legend.direction = "vertical"
  )

# Adjust cell type UMAPs
type_8 <- type_8 +
  ggtitle("8 hpi") +
  theme(plot.title = element_text(size = ttl_pt2 * 1.5, hjust = 0.5))

type_umap <- type_umap +
  ggtitle("24 hpi") +
  theme(plot.title = element_text(size = ttl_pt2 * 1.5, hjust = 0.5))
  
# Combine 8 hpi plots
bot <- plot_grid(
  marco_bxs, madcam_bxs,
  nrow  = 1,
  align = "h",
  axis  = "tb"
)

hpi8 <- plot_grid(
  type_8, A, frac_8, bot,
  labels     = c("A", "C", "E", "G"),
  label_size = ttl_pt2 * 1.5,
  ncol  = 1,
  align = "v",
  axis  = "rl",
  rel_heights = c(1, 1, 0.45, 0.7)
)

# Combine 24 hpi plots
bot <- plot_grid(
  marco_24, NULL,
  nrow  = 1,
  align = "h",
  axis  = "tb"
)

hpi24 <- plot_grid(
  type_umap, chikv_24, frac_24, bot,
  labels     = c("B", "D", "F", "H"),
  label_size = ttl_pt2 * 1.5,
  ncol  = 1,
  align = "v",
  axis  = "rl",
  rel_heights = c(1, 1, 0.45, 0.7)
)

# Create final figure
plot_grid(
  hpi8, hpi24,
  nrow  = 1,
  align = "h",
  axis  = "tb"
)
```

<br>

## Figure 2

A.  MARCO expression is shown for LEC and FRC subtypes for the 8 hpi and 24 hpi timepoints.
B.  Mxra8 expression is shown as described in A.

```{r, fig.height = 9, fig.width = 6}
# Format data for boxplots
bx_plt_dat <- typ_bx_dat %>%
  mutate(
    cell_type     = ifelse(lec_type %in% c("FRC", "PvC"), lec_type, cell_type),
    new_cell_type = ifelse(lec_type == "BEC", lec_type, cell_type),
    new_cell_type = ifelse(new_cell_type %in% lec_cell_types, "LEC", new_cell_type),
    new_lec_type  = ifelse(cell_type %in% lec_cell_types, lec_type, "other"),
    new_fib_type  = ifelse(cell_type %in% c(fib_cell_types, "FRC"), fib_type, "other")
  )

# Plot Marco and Mxra8 expression
gns <- c("Marco", "Mxra8")
  
lec_fig <- bx_plt_dat %>%
  filter(new_lec_type != "other") %>%
  create_example_gene_fig(
    gns    = gns,
    x_clmn = "new_lec_type",
    ttl    = "LEC subsets",
    clrs   = subtype_cols
  )

fib_fig <- bx_plt_dat %>%
  filter(new_fib_type != "other") %>%
  create_example_gene_fig(
    gns    = gns,
    x_clmn = "new_fib_type",
    ttl    = "FRC subsets",
    clrs   = subtype_cols
  ) %>%
  map(~ {
    .x + theme(axis.title.y = element_blank()) +
      plot_layout(tag_level = "new")
  })

# Create final figure
append(lec_fig, fib_fig) %>%
  wrap_plots(guides = "collect", ncol = 2, byrow = FALSE) +
  plot_annotation(tag_levels = "A") &
  theme(aspect.ratio = 0.25, plot.tag = element_text(size = ttl_pt2 * 1.5))
```

<br>

## Figure 3

* Using scRNAseq, we found that during WT CHIKV infection, expression of CCL21
  (attracts CCR7+ cells) and IL-7 (supports T cell proliferation and survival)
  were reduced in both LECs and FRCs
* In addition, expression of CXCL13, which recruits CXCR5 expressing B cells and
  Tfh cells to B cell follicles and GCs, was specifically reduced in FDCs.
* Moreover, MRCs that are positioned at the edge of B cell follicles adjacent
  to the SCS, and are also an important source of CXCL13, were undetectable by
  scRNAseq in the LNs of mice infected with WT CHIKV at 24 hpi.
  MRCs were detected in LNs of mock-infected mice and CHIKV-infected mice at 8
  hpi, suggesting these cells are lost or damaged by 24 h after CHIKV infection.
  
A.  CCL21 and IL7 expression is shown for mock and CHIKV-infected samples from the 24 hpi timepoint. * p < 0.01, ** p < 0.001, *** p < 0.0001.
B.  CXCL13 expression is shown for FRC subsets from mock and CHIKV-infected samples from the 24 hpi timepoint.
C.  The proportion of FRCs belonging to different subsets is shown for the 8 hpi and 24 hpi timepoints.
D.  The proportion of FRCs belonging to different subsets is shown for mock and CHIKV-infected samples from the 24 hpi timepoint. The height of each bar graph shows the mean for 3 biological replicates, error bars show the standard deviation. p-values were calculated using a two-sample t-test, p-values < 0.05 are shown above each set of bar graphs.

```{r, fig.width = 12, fig.height = 6}
# Adjust colors
type_cols["LEC"] <- type_cols[[lec_cell_types]]
type_cols["BEC"] <- lec_type_cols[["Valve"]]

# Calculate p-values
bx_dat <- bx_plt_dat %>%
  filter(tm == "24hpi")

# Create boxplots
gns <- c("Ccl21a", "Il7")

gn_fig1 <- bx_dat %>%
  create_example_gene_fig2(
    gns,
    x_clmn    = "new_cell_type",
    al_clmn   = "treatment",
    plot_lvls = c("FRC", "PvC", "LEC"),
    clrs      = type_cols
  )

gn_fig1[[2]] <- (gn_fig1[[2]] + plot_layout(tag_level = "new"))

gn_fig1 <- gn_fig1 %>%
  wrap_plots(nrow = 1, guides = "collect") &
  theme(
    strip.text = element_blank(),
    legend.position = "top"
  )

gn_fig2 <- bx_dat %>%
  filter(new_fib_type != "other") %>%
  create_example_gene_fig2(
    gns     = "Cxcl13",
    x_clmn  = "new_fib_type",
    al_clmn = "treatment",
    clrs    = subtype_cols
  )

fig_top <- wrap_plots(
  gn_fig1, plot_spacer(), gn_fig2[[1]],
  nrow = 1, widths = c(1, 0.05, 0.5)
) +
  plot_annotation(tag_levels = "A") &
  theme(strip.text = element_blank())

# FRC abundance
abun_dat <- bx_plt_dat %>%
  filter(new_fib_type != "other")

frc_stack <- abun_dat %>%
  mutate(
    tm_treat = str_c(tm, "-", treatment),
    tm_treat = fct_relevel(tm_treat, c("8hpi-mock", "8hpi-CHIKV", "24hpi-mock", "24hpi-CHIKV"))
  ) %>%
  plot_frequency(
    "new_fib_type", "tm_treat",
    plot_colors = subtype_cols,
    stack = TRUE
  ) +
  facet_wrap(~ tm, scales = "free_x") +
  theme(legend.title = element_blank())
  
mrc_bars <- abun_dat %>%
  filter(tm == "24hpi") %>%
  mutate(treatment = fct_relevel(treatment, treats)) %>%
  plot_frequency(
    "new_fib_type", "orig.ident", "treatment",
    p_method = "t",
    plot_colors = c(mock = "#F7AF34", CHIKV = "#A1342D")
  ) +
  coord_cartesian(ylim = c(0, 100)) +
  theme(
    legend.title = element_blank()
  )

fig_bot <- wrap_plots(
  frc_stack, mrc_bars, plot_spacer(),
  nrow = 1, widths = c(0.5, 1, 0.7)
)

# Create final figure
final_fig <- (fig_top / fig_bot) +
  plot_annotation(tag_levels = "A") &
  theme(plot.tag = element_text(size = ttl_pt2 * 1.5))

final_fig


# # FRC markers
# # PDPN+TNFSF11+MADCAM1+VCAM1+ICAM1+BST1+RELB+
# # CXCL13+ LN stroma (Katakai et al., 2008). One cluster ex-
# # pressed almost all of these markers and was enriched for
# # Tnfsf11 and Cxcl13 expression, suggesting that the constituent
# # cells are MRCs
# gns <- c(
#   "Ccl19", "Ccl21a", "Cxcl13",
#   "Ch25h",  # MRC
# )
# 
# so_24 %>%
#   plot_violin(
#     "Cxcl13", "fib_type", "treatment",
#     method = "boxplot"
#   )
# 
# so_24 %>%
#   plot_scatter(
#     "fib_type", group_col = "treatment",
#     size = 0.5
#   )
# 
# so_24 %>%
#   plot_scatter(
#     "Ch25h", group_col = "treatment", size = 0.5,
#     plot_colors = c("white", "red"), outline = TRUE
#   )
# 
# so_24 %>%
#   plot_violin(
#     "Tnfsf11", "fib_type", "treatment",
#     method = "boxplot"
#   )
# 
# abun_dat %>%
#   filter(tm == "8hpi") %>%
#   plot_frequency(
#     "new_fib_type", "orig.ident", stack = TRUE,
#     plot_colors = subtype_cols
#   ) 
# 
# bx_plt_dat %>%
#   filter(tm == "24hpi", new_fib_type != "other") %>%
#   plot_frequency(
#     "new_fib_type", "treatment",
#     p_label = "none"
#   )
```

---

<br>

<br>

```{r "LEC integration", eval = FALSE}

# Use original broad cell types based on clustering resolution 5
# remove parenthesis from 8 hpi so format matches 24 hpi
# add tm column to 24 hpi
so_8  <- read_rds(file.path(params$orig_so_dir, "2021-07-16/sobjs/so.rds"))
so_24 <- read_rds(file.path(params$orig_so_dir, "2021-01-08/sobjs/so.rds"))

so_8 <- so_8 %>%
  mutate_meta(
    mutate,
    cell_type = str_remove(cell_type, " \\(.+\\)$")
  )

so_24 <- so_24 %>%
  mutate_meta(mutate, tm = "24hpi")

# Create LEC objects
# integrate treatments separately for timepoints
so_lec <- list(`8hpi` = so_8, `24hpi` = so_24) %>%
  map(subset, cell_type %in% lec_cell_types)

so_lec <- so_lec %>%
  map(~ {
    .x %>%
      mutate_meta(~ dplyr::select, -starts_with("UMAP_")) %>%
      FindVariableFeatures(nfeatures = 2000) %>%
      ScaleData() %>%
      RunPCA() %>%
      RunHarmony("treatment", plot_convergence = TRUE) %>%
      RunUMAP(reduction = "harmony", dims = 1:40)
  })

so_lec <- so_lec %>%
  map(~ {
    dat <- .x %>%
      FindNeighbors(reduction = "harmony", dims = 1:40) %>% 
      FindClusters(resolution = c(1, 2, 4, 5))
    
    typs <- dat %>%
      subset(treatment == "mock") %>%
      clustify(
        ref_mat     = ref_lec,
        cluster_col = "RNA_snn_res.2",
        n_genes     = 2000,
        threshold   = 0.6
      )
    
    typs <- typs@meta.data %>%
      distinct(RNA_snn_res.2, type)
    
    typs <- set_names(typs$type, as.character(typs$RNA_snn_res.2))
    
    dat %>%
      mutate_meta(mutate, lec_type = typs[as.character(RNA_snn_res.2)])
  })

# Combine integrated objects
so_lec_merge <- merge(so_lec[[1]], so_lec[-1]) %>%
  FindVariableFeatures(nfeatures = 2000) %>%
  ScaleData() %>%
  RunPCA() %>%
  RunUMAP(reduction = "pca", dims = 1:40)

so_lec_merge %>%
  plot_scatter(
    "subtype",
    size = 0.5
  ) +
  facet_grid(tm ~ treatment)

so_lec_merge %>%
  plot_scatter(
    "subtype",
    size = 0.5,
    group_col = "treatment"
  )

so_lec_merge %>%
  plot_scatter(
    "Marco",
    size = 0.5,
    group_col = "treatment",
    plot_colors = c("lightblue", "red")
  )

so_lec_merge %>%
  plot_scatter(
    "Lyve1",
    size = 0.5,
    group_col = "treatment",
    plot_colors = c("lightblue", "red")
  )

so_lec_merge %>%
  plot_scatter(
    "Madcam1",
    size = 0.5,
    group_col = "treatment",
    plot_colors = c("lightblue", "red")
  )

so_lec$`24hpi` %>%
  plot_scatter(
    "lec_type",
    size = 0.5
  ) +
  facet_grid(tm ~ treatment)

so_lec$`24hpi` %>%
  plot_scatter(
    "Madcam1",
    plot_colors = c("lightblue", "red"),
    size = 0.5
  ) +
  facet_grid(tm ~ treatment)

so_lec$`24hpi`@meta.data %>%
  filter(!is.na(lec_type)) %>%
  subset(lec_type != "BEC") %>%
  plot_frequency("lec_type", "orig.ident", "treatment", p_method = "edgeR", p_label = "all")







so_lec_merge %>%
  plot_violin(cluster_col = "type", method = "boxplot", data_col = "Ptx3") +
  facet_grid(tm ~ treatment)

so_lec_merge %>%
  plot_violin(cluster_col = "type", method = "boxplot", data_col = "Ackr4") +
  facet_grid(tm ~ treatment)

so_lec_merge %>%
  plot_violin(cluster_col = "type", method = "boxplot", data_col = "Cd36") +
  facet_grid(tm ~ treatment)





so_lec_merge %>%
  plot_scatter("lec_type", size = 0.5) +
  facet_grid(tm ~ treatment)

so_lec_merge %>%
  subset(treatment == "CHIKV" & tm == "24hpi") %>%
  plot_violin(cluster_col = "chikv_grp", method = "boxplot", data_col = "Marco") +
  facet_grid(~ type)



so_lec_merge %>%
  plot_scatter("chikv_grp", size = 0.5, plot_lvls = "CHIKV-high") +
  facet_grid(tm ~ treatment)

so_lec_merge %>%
  plot_scatter("Marco", size = 0.5, plot_colors = c("lightblue", "red")) +
  facet_grid(tm ~ treatment)

so_lec_merge %>%
  plot_scatter("Pecam1", size = 0.5, plot_colors = c("lightblue", "red")) +
  facet_grid(tm ~ treatment)

so_lec_merge %>%
  plot_scatter("Prox1", size = 0.5, plot_colors = c("lightblue", "red")) +
  facet_grid(tm ~ treatment)

so_lec_merge %>%
  plot_scatter("Lyve1", size = 0.5, plot_colors = c("lightblue", "red")) +
  facet_grid(tm ~ treatment)




so_lec_merge %>%
  subset(tm == "24hpi") %>%
  plot_scatter("type", size = 0.2, group_col = "treatment")

so_lec_merge %>%
  subset(tm == "8hpi") %>%
  plot_scatter("type", size = 0.2, group_col = "treatment")

so_lec_merge %>%
  subset(tm == "24hpi") %>%
  plot_scatter("Madcam1", size = 0.2, group_col = "treatment", plot_colors = c("white", "red"), outline = T)

so_lec_merge %>%
  subset(tm == "24hpi") %>%
  plot_scatter("Marco", size = 0.2, group_col = "treatment", plot_colors = c("white", "red"), outline = T)

so_lec_merge %>%
  subset(tm == "24hpi") %>%
  plot_violin("Marco", "type", group_col = "treatment", method = "boxplot")

so_lec_merge %>%
  subset(tm == "24hpi") %>%
  subset(treatment == "CHIKV") %>%
  plot_violin("Marco", "type", group_col = "chikv_grp", method = "boxplot")

so_lec_merge %>%
  subset(tm == "24hpi") %>%
  subset(treatment == "CHIKV") %>%
  plot_violin("Madcam1", "type", group_col = "chikv_grp", method = "boxplot")

```

```{r "LEC ANNOTATIONS PARAMS", eval = FALSE}

# Use original broad cell types based on clustering resolution 5
# remove parenthesis from 8 hpi so format matches 24 hpi
# add tm column to 24 hpi
so_8  <- read_rds(file.path(params$orig_so_dir, "2021-07-16/sobjs/so.rds"))
so_24 <- read_rds(file.path(params$orig_so_dir, "2021-01-08/sobjs/so.rds"))

so_8 <- so_8 %>%
  mutate_meta(
    mutate,
    cell_type = str_remove(cell_type, " \\(.+\\)$"),
    chikv_grp = ifelse(tot_nCount_CHIKV > 0, "CHIKV-high", "CHIKV-low")
  )

so_24 <- so_24 %>%
  mutate_meta(mutate, tm = "24hpi")

# Create LEC objects
# integrate treatments separately for timepoints
so_lec <- list(`8hpi` = so_8, `24hpi` = so_24) %>%
  map(subset, cell_type %in% lec_cell_types)

so_lec_merge <- merge(so_lec[[1]], so_lec[-1]) %>%
  mutate_meta(mutate, tm_grp = ifelse(tm == "24hpi" & treatment == "CHIKV", "late", "early")) %>%
  FindVariableFeatures(nfeatures = 2000) %>%
  ScaleData() %>%
  RunPCA() %>%
  RunHarmony(c("rep", "tm_grp"), dims = 1:40, plot_convergence = TRUE) %>%
  RunUMAP(reduction = "harmony", dims = 1:40)

# Parameters to test
resolutions <- seq(3, 15, 0.5)
n_genes     <- seq(500, 2000, 500)
obj         <- "all"
met         <- "spearman"
bulk        <- "mean"
clst_params <- as.list(expand_grid(resolutions, n_genes, obj, met, bulk))

so_lec_merge <- so_lec_merge %>%
  FindNeighbors(reduction = "harmony", dims = 1:40) %>%
  FindClusters(resolution = resolutions)

so_mock <- so_lec_merge %>%
  mutate_meta(dplyr::select, -any_of(c("type", "r", "UMAP_1", "UMAP_2"))) %>%
  subset(treatment == "mock")

# Annotate LEC subsets
param_results <- clst_params %>%
  pmap_dfr(~ {
    args  <- list(...)
    rsln  <- args$resolutions
    n_gns <- args$n_genes
    
    # Annotate cell types
    clmn <- str_c("RNA_snn_res.", rsln)
    
    if (args$obj == "mock") obj <- so_mock
    else                    obj <- so_lec_merge
    
    typs <- obj %>%
      clustify(
        ref_mat     = ref_lec,
        cluster_col = clmn,
        n_genes     = n_gns,
        threshold   = 0.55,
        # threshold   = 0.6,
        compute_method    = args$met,
        pseudobulk_method = args$bulk
      )
    
    typs <- typs@meta.data %>%
      distinct(!!sym(clmn), type)
    
    typs <- set_names(typs$type, as.character(pull(typs, clmn)))
    
    so_lec_merge <- so_lec_merge %>%
      mutate_meta(mutate, type = typs[as.character(!!sym(clmn))])
    
    # Calculate stats
    res <- so_lec_merge %>%
      FetchData(c("type", "tm", "treatment", "chikv_grp", "Marco", "Madcam1", clmn)) %>%
      as_tibble(rownames = ".cell_id")
    
    frac_few <- table(res[[clmn]])
    frac_few <- frac_few[frac_few < 100]
    n_few    <- sum(frac_few)
    frac_few <- n_few / nrow(res)
    
    typ <- res %>%
      group_by(tm, treatment, type) %>%
      summarize(n_type = n(), .groups = "drop") %>%
      group_by(tm, treatment) %>%
      mutate(frac_type = n_type / sum(n_type)) %>%
      ungroup()
    
    chikv <- res %>%
      filter(tm == "24hpi", treatment == "CHIKV", chikv_grp == "CHIKV-high") %>%
      group_by(type) %>%
      summarize(n_chikv = n(), .groups = "drop") %>%
      mutate(frac_chikv = n_chikv / sum(n_chikv)) %>%
      ungroup()
    
    marks <- res %>%
      group_by(tm, treatment, type) %>%
      summarize(
        Marco_mn    = mean(Marco),
        Marco_med   = median(Marco),
        Madcam1_mn  = mean(Madcam1),
        Madcam1_med = median(Madcam1),
        .groups = "drop"
      ) %>%
      group_by(tm, treatment) %>%
      summarize(
        Marco_mn    = type[Marco_mn == max(Marco_mn)],
        Marco_med   = type[Marco_med == max(Marco_med)],
        Madcam1_mn  = type[Madcam1_mn == max(Madcam1_mn)],
        Madcam1_med = type[Madcam1_med == max(Madcam1_med)],
        .groups = "drop"
      )
    
    typ_diff <- so_lec_merge@meta.data %>%
      group_by(tm, treatment, lec_type) %>%
      summarize(n_old_type = n(), .groups = "drop")

    res <- typ %>%
      full_join(chikv, by = "type") %>%
      full_join(marks, by = c("tm", "treatment")) %>%
      full_join(typ_diff, by = c("tm", "treatment", c(type = "lec_type"))) %>%
      mutate(
        rsln     = clmn,
        n_genes  = args$n_genes,
        obj      = args$obj,
        type_key = list(typs),
        n_small_clusters    = n_few,
        frac_small_clusters = frac_few
      ) %>%
      rowwise() %>%
      mutate(
        frac_old_diff = abs(diff(c(n_type, n_old_type))) / n_old_type
      ) %>%
      ungroup()
    
    res
  })

# Filter results
test_res <- param_results %>%
  # filter(n_genes == 1000, obj == "all") %>%    # 18 is closest to consensus
  # filter(n_genes == 2000, obj == "all") %>%    # 17 is closest to consensus
  
  filter(n_genes == 1500, rsln == "RNA_snn_res.9.5", obj == "all") %>%      # cluster 7
  # filter(n_genes == 2000, rsln == "RNA_snn_res.9", obj == "all") %>%      # cluster 9
  
  distinct(n_genes, obj, rsln, .keep_all = TRUE)

  # filter(rsln == "RNA_snn_res.15") %>%
  # group_by(rsln, n_genes, obj) %>%
  # filter(
  #   # (Marco_mn == "Marco_LEC" | Marco_med == "Marco_LEC"),
  #   # all(Marco_mn[treatment == "mock"] == "Marco_LEC" | is.na(Marco_mn[treatment == "mock"])),
  #   all(Madcam1_mn == "fLEC" | is.na(Madcam1_mn)),
  #   type == "Marco_LEC",
  #   n_chikv > 200
  # ) %>%
  # ungroup()

# Example plots
# plot selected examples
test_plts <- ann_clst_res %>%
  pmap(~ {
    args <- list(...)
    
    type_key  <- args$type_key
    clst_clmn <- args$rsln
    
    so_ann <- so_lec_merge %>%
      mutate_meta(mutate, type = type_key[as.character(!!sym(clst_clmn))])
    
    umap <- so_ann %>%
      plot_scatter(
        "type", size = 0.5,
        plot_colors = c(Marco_LEC = "red", fLEC = "black")
      ) +
      facet_grid(tm ~ treatment)
    
    bx1 <- so_ann %>%
      plot_violin(
        cluster_col = "type", method = "boxplot", data_col = "Marco",
        plot_colors = c(Marco_LEC = "red", fLEC = "black")
      ) +
      facet_grid(tm ~ treatment)
    
    bx2 <- so_ann %>%
      plot_violin(
        cluster_col = "type", method = "boxplot", data_col = "Madcam1",
        plot_colors = c(Marco_LEC = "red", fLEC = "black")
      ) +
      facet_grid(tm ~ treatment)
    
    bx3 <- so_ann %>%
      subset(treatment == "CHIKV") %>%
      plot_violin("Marco", "chikv_grp", method = "boxplot") +
      facet_grid(tm ~ type)
    
    res <- plot_grid(bx1, bx2, ncol = 1)
    res <- plot_grid(umap, res, nrow = 1)
    res <- plot_grid(res, bx3, ncol = 1, rel_heights = c(1, 0.7))
    
    res
  })

# Determine consensus annotations
# determine which annotations are most consistent for each cell
# calculate stats for annotations
ann_key <- param_results %>%
  distinct(type_key, rsln, n_genes, obj) %>%
  mutate(id = row_number()) %>%
  filter(obj == "all")

ann_df <- so_lec_merge@meta.data %>%
  as_tibble(rownames = ".cell_id") %>%
  dplyr::select(.cell_id, starts_with("RNA_snn_res."), "tm", "orig.ident", "treatment", "lec_type")

ann_key %>%
  pwalk(~ {
    args <- list(...)
    
    new_clmn <- str_c("type-", args$rsln, "-", args$n_genes)
    
    ann_df <<- ann_df %>%
      mutate(!!sym(new_clmn) := args$type_key[as.character(!!sym(args$rsln))])
  })

ann_stats <- ann_df %>%
  dplyr::select(.cell_id, starts_with("type-")) %>%
  pivot_longer(starts_with("type-")) %>%
  
  group_by(.cell_id) %>%
  summarize(
    count = list(table(value)),
    n = n(),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    top_ann  = names(head(sort(count, decreasing = TRUE), 1)),
    sec_ann  = names(tail(head(sort(count, decreasing = TRUE), 2), 1)),
    top_n    = max(count),
    top_frac = top_n / n,
    ann_n    = length(count)
  ) %>%
  ungroup()

top_typs <- set_names(ann_stats$top_ann, ann_stats$.cell_id)
sec_typs <- set_names(ann_stats$sec_ann, ann_stats$.cell_id)
top_frac <- set_names(ann_stats$top_frac, ann_stats$.cell_id)

so_lec_merge <- so_lec_merge %>%
  AddMetaData(top_typs, col.name = "top_type") %>%
  AddMetaData(sec_typs, col.name = "sec_type") %>%
  AddMetaData(top_frac, col.name = "top_frac")

# Cluster cell type annotations
# want to identify primary annotation schemes
ann_mat <- ann_df %>%
  dplyr::select(.cell_id, starts_with("type-"))

ann_typs <- ann_mat %>%
  dplyr::select(starts_with("type-")) %>%
  as.matrix() %>%
  as.factor() %>%
  levels()

ann_mat <- ann_mat %>%
  mutate(across(starts_with("type-"), ~ as.numeric(factor(.x, ann_typs)))) %>%
  column_to_rownames(".cell_id") %>%
  as.matrix() %>%
  t()

ann_clsts <- kmeans(ann_mat, centers = 10)

ann_clst_res <- tibble(
  key = names(ann_clsts$cluster),
  id  = unname(ann_clsts$cluster),
  type = "all"
) %>%
  separate(key, into = c("blank", "rsln", "n_genes"), sep = "-") %>%
  dplyr::select(-blank) %>%
  group_by(id) %>%
  dplyr::slice(1) %>%
  ungroup()

```

```{r}

# Use clustifyr params identified above
# 2000 genes, resolution 11
so_lec_merge <- so_lec_merge %>%
  clustify(
    ref_mat     = ref_lec,
    cluster_col = "RNA_snn_res.11",
    n_genes     = 2000,
    threshold   = 0.55,
    compute_method    = "spearman",
    pseudobulk_method = "mean"
  )

so_lec_merge %>%
  plot_scatter("type", size = 0.5) +
  facet_grid(tm ~ treatment)

# Adjust clusters based on Marco expression
top_marco <- c("20", "104", "26", "78", "100", "69", "7")

so_lec_merge %>%
  plot_scatter("RNA_snn_res.11", size = 0.5, top = top_marco) +
  facet_grid(tm ~ treatment)

so_lec_merge <- so_lec_merge %>%
  mutate_meta(
    mutate,
    new_type = ifelse(RNA_snn_res.11 %in% top_marco, "Marco_LEC", type)
  )

so_lec_merge %>%
  plot_scatter("new_type", size = 0.5) +
  facet_grid(tm ~ treatment)

# Plot marker expression
marks <- c("Marco", "Madcam1", "Ptx3", "Ackr4", "Cd36", "Icam1")

plts <- marks %>%
  map(~ {
    u <- so_lec_merge %>%
      plot_scatter(.x, size = 0.5, plot_colors = c("lightblue", "red")) +
      facet_grid(tm ~ treatment)
    
    b <- so_lec_merge %>%
      plot_violin(.x, "new_type", method = "boxplot") +
      facet_grid(tm ~ treatment)
    
    plot_grid(u, b, ncol = 1)
  })







so_lec_merge %>%
  plot_scatter("top_type", size = 0.5) +
  facet_grid(tm ~ treatment)

so_lec_merge %>%
  plot_scatter("sec_type", size = 0.5) +
  facet_grid(tm ~ treatment)

so_lec_merge %>%
  plot_scatter("Madcam1", size = 0.5) +
  facet_grid(tm ~ treatment)

so_lec_merge %>%
  plot_scatter("lec_type", size = 0.5) +
  facet_grid(tm ~ treatment)

so_lec_merge %>%
  subset(tm == "24hpi" & top_type != "BEC") %>%
  plot_frequency("top_type", "orig.ident", "treatment")






# Refine annotations
# 11, 1500, all
# so_lec_merge <- so_lec_merge %>%
so_lec_merge %>%
  plot_scatter("lec_type", size = 0.5) +
  facet_grid(tm ~ treatment)

new_types <- test_res %>%
  tail(1) %>%
  pull(type_key) %>%
  unlist()

clmn <- test_res %>%
  tail(1) %>%
  pull(rsln)

so_lec_merge <- so_lec_merge %>%
  mutate_meta(mutate, new_type = new_types[as.character(!!sym(clmn))])

so_lec_merge@meta.data %>%
  filter(tm == "24hpi" & !is.na(new_type)) %>%
  # subset(new_type != "BEC" & tm == "24hpi") %>%
  plot_frequency("new_type", "orig.ident", "treatment", p_method = "edgeR")

so_lec_merge %>%
  subset(tm == "24hpi") %>%
  plot_scatter("nFeature_RNA", group_col = "treatment")

so_lec_merge %>%
  subset(tm == "24hpi") %>%
  plot_scatter("Marco", group_col = "treatment", plot_colors = c("lightblue", "red"))

VariableFeatures(so_lec_merge)

so_24 %>%
  mutate_meta(mutate, new_type = ifelse(new_type == "BEC", new_type, "LEC")) %>%
  plot_scatter(
    "cell_type",
    "Pecam1", "Pdpn",
    group_col = "treatment"
  )

so_lec_merge %>%
  mutate_meta(mutate, new_type = ifelse(new_type == "BEC", new_type, "LEC")) %>%
  subset(tm == "24hpi" & new_type != "BEC" & treatment == "CHIKV" & lec_subtype != "unassigned") %>%
  plot_scatter(
    "chikv_grp",
    "pct_CHIKV", "Marco",
    group_col = "treatment"
  )

# so_lec_merge %>%
#   plot_scatter(clst_clmn, size = 0.5, top = Inf) +
#   facet_grid(tm ~ treatment) +
#   theme(legend.position = "none")

```





```{r "EARLY GENES", eval = FALSE}

gn <- "Bst2"
gn <- "Irf7"
gn <- "Cxcl10"
gn <- "Ifi44"

dat <- list(so_8, so_24) %>%
  map_dfr(~ {
    .x %>%
      FetchData(c("treatment", "lec_subtype", gn, "orig.ident", "chikv_grp", "tm"))
  })

dat <- dat %>%
  mutate(
    tm        = ifelse(is.na(tm), "24hpi", tm),
    tm_treat  = ifelse(treatment == "CHIKV", tm, treatment),
    tm_treat  = fct_relevel(tm_treat, c("mock", "8hpi", "24hpi")),
    treatment = fct_relevel(treatment, c("mock", "CHIKV")),
    tm        = fct_relevel(tm, c("8hpi", "24hpi"))
  )

dat %>%
  ggplot(aes(tm_treat, !!sym(gn), fill = tm_treat, alpha = tm)) +
  geom_boxplot(
    position = position_dodge2(preserve = "single"),
    outlier.alpha = 1,
    outlier.size = 0.5
  ) +
  facet_wrap(~ lec_subtype) +
  scale_alpha_manual(values = c(`8hpi` = 0.25, `24hpi` = 0.75)) +
  djvdj_theme()
  

# dat %>%
#   mutate(treatment = fct_relevel(treatment, c("mock", "CHIKV"))) %>%
#   ggplot(aes(lec_subtype, !!sym(gn), fill = lec_subtype, alpha = treatment)) +
#   geom_boxplot() +
#   facet_wrap(~ tm) +
#   scale_alpha_manual(values = c(mock = 0.25, CHIKV = 0.75)) +
#   djvdj_theme()

```

```{r "GSEA RESULTS", eval = FALSE}

# Gene sets to use
m_db <- msigdbr(species = "Mus musculus")

to_query <- c("H", "C2", "C3", "C5")

gene_set <- m_db %>%
  filter(gs_cat %in% to_query) %>%
  dplyr::select(gs_name, gene_symbol)

# Turn off BiocParallel multi-threading
# Memory usage exceeds 32G when using 6 threads
options(MulticoreParam = BiocParallel::MulticoreParam(workers = 1))

# Run GSEA
gsea_path <- here(params$so_dir, "all_gsea.tsv")

if (!file.exists(gsea_path)) {
  gsea_res <- set_names(typs) %>%
    map_dfr(~ {
      gene_lst <- filter(marks, cell_type == .x)
      gene_lst <- set_names(gene_lst$avg_log2FC, gene_lst$gene)
      
      set.seed(42)
      
      gene_lst %>%
        GSEA(
          TERM2GENE    = gene_set,
          pvalueCutoff = 0.05,
          eps          = 1e-50
        ) %>%
        as_tibble() %>%
        mutate(cell_type = .x)
    })
  
  gsea_res %>%
    write_tsv(here(params$so_dir, "gsea.tsv"))
  
} else {
  gsea_res <- read_tsv(gsea_path)
}

# Focus on enriched pathway terms
gsea_res <- gsea_res %>%
  filter(
    enrichmentScore > 0,
    grepl("^(HALLMARK|WP|KEGG)_", ID)
  )

```

```{r "GSEA PLOTS", eval = FALSE}

k_dat <- gsea_res %>%
  group_by(cell_type) %>%
  dplyr::slice(1:30) %>%
  dplyr::select(ID, enrichmentScore, cell_type) %>%
  pivot_wider(
    names_from  = cell_type,
    values_from = enrichmentScore,
    values_fill = 0
  ) %>%
  column_to_rownames("ID")

k_res <- k_dat %>%
  kmeans(6)

# Bar graphs
plt_dat <- gsea_res %>%
  mutate(ID = fct_reorder(ID, -log10(p.adjust), mean))
  
plt_dat %>%
  # group_by(cell_type) %>%
  # dplyr::slice(1:10) %>%
  # ungroup() %>%
  filter(grepl("^(HALLMARK)_", ID)) %>%
  ggplot(aes(-log10(p.adjust), ID, fill = cell_type)) +
  geom_col() +
  facet_wrap(~ cell_type, ncol = 1, scales = "free_y") +
  scale_fill_manual(values = lec_type_cols) +
  djvdj_theme()

# Heatmaps
plt_dat %>%
  # group_by(cell_type) %>%
  # dplyr::slice(1:20) %>%
  # ungroup() %>%
  filter(grepl("^(HALLMARK|KEGG)_", ID)) %>%
  ggplot(aes(cell_type, ID, fill = -log10(p.adjust))) +
  geom_tile() +
  scale_fill_gradientn(colours = c("lightblue", "red")) +
  djvdj_theme() +
  scale_x_discrete(position = "top") +
  theme(
    axis.title.x = element_blank(),
    axis.text.x  = element_text(angle = 45, hjust = 0)
  )

```

```{r "GSEA MARKER HEATMAP", eval = FALSE}

# Fold changes for every gene
fc_dat <- marks %>%
  left_join(m_db, by = c("gene" = "gene_symbol")) %>%
  dplyr::select(gs_cat, gs_name, gene, avg_log2FC, cell_type) %>%
  filter(grepl("^(HALLMARK|KEGG)_", gs_name))

# Format GSEA data
terms <- gsea_res %>%
  filter(grepl("^(HALLMARK|KEGG)_", ID)) %>%
  group_by(cell_type) %>%
  dplyr::slice(1:10) %>%
  ungroup() %>%
  separate_rows(core_enrichment, sep = "/")

# Identify top genes
gns <- terms %>%
  group_by(cell_type, core_enrichment) %>%
  summarize(n = n(), .groups = "drop") %>%
  group_by(cell_type) %>%
  slice_max(n, n = 5)

# Identify top terms
# Overall top terms
# top_terms <- terms %>%
#   distinct(ID, cell_type, p.adjust) %>%
#   group_by(ID) %>%
#   summarize(
#     p.adjust = mean(p.adjust),
#     n = n_distinct(cell_type)
#   ) %>%
#   arrange(desc(n)) %>%
#   pull(ID)
top_terms <- terms %>%
  distinct(cell_type, ID)

# Format plot data
plt_dat <- fc_dat %>%
  filter(
    # gs_name %in% top_terms,
    gene %in% gns$core_enrichment
  ) %>%
  semi_join(top_terms, by = c(gs_name = "ID", "cell_type"))

# Add GSEA p-values
plt_dat <- terms %>%
  distinct(ID, p.adjust, cell_type) %>%
  right_join(plt_dat, by = c(ID = "gs_name", "cell_type"))

plt_dat %>%
  mutate(
    # ID   = fct_relevel(ID, rev(top_terms)),
    ID   = fct_reorder(ID, p.adjust, .desc = TRUE),
    gene = fct_reorder(gene, avg_log2FC, .desc = TRUE)
  ) %>%

# plt_dat %>%
#   filter(core_enrichment %in% unique(gns$core_enrichment)) %>%
#   group_by(core_enrichment) %>%
#   mutate(n = n_distinct(ID)) %>%
#   ungroup() %>%
#   mutate(core_enrichment = fct_reorder(core_enrichment, n, .desc = TRUE)) %>%
  
  ggplot(aes(gene, ID, fill = avg_log2FC)) +
  geom_tile() +
  facet_wrap(~ cell_type, ncol = 2, scales = "free_y") +
  scale_fill_gradient2(low = "blue", mid = "grey90", high = "red") +
  djvdj_theme() +
  theme(
    axis.title = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

```

```{r "K CLUSTERING DEGs", eval = FALSE}

reps     <- unique(so_24$rep)
fc_clmns <- str_c(reps, "_avg_log2FC")
p_clmns  <- str_c(reps, "_p_val_adj")

# Cluster genes based on FC for each cell type
# degs <- marks %>%
#   filter(
#     if_all(all_of(fc_clmns), ~ .x > 0),
#     if_all(all_of(p_clmns),  ~ .x < 0.05)
#   ) %>%
#   pull(gene) %>%
#   unique()

k_dat <- marks %>%
  filter(
    if_all(all_of(fc_clmns), ~ .x > 0),
    if_all(all_of(p_clmns),  ~ .x < 0.05)
  ) %>%
  # filter(gene %in% degs) %>%
  dplyr::select(gene, avg_log2FC, cell_type) %>%
  pivot_wider(
    names_from  = cell_type,
    values_from = avg_log2FC,
    values_fill = 0
  ) %>%
  column_to_rownames("gene") %>%
  t() %>%
  scale() %>%
  t()

k_res <- k_dat %>%
  kmeans(20)

k_res <- tibble(
  gene    = names(k_res$cluster),
  cluster = unname(k_res$cluster)
)

# Format plot data
clsts <- unique(k_res$cluster)

clsts %>%
  map(~ {
    # marks %>%
    k_dat %>%
      as.data.frame() %>%
      rownames_to_column("gene") %>%
      pivot_longer(-gene, names_to = "cell_type", values_to = "avg_log2FC") %>%
      inner_join(k_res, by = "gene") %>%
      filter(cluster == .x) %>%
      
      group_by(gene) %>%
      mutate(avg_log2FC = as.numeric(scale(avg_log2FC))) %>%
      ungroup() %>%
      
      ggplot(aes(cell_type, gene, fill = avg_log2FC)) +
      geom_tile() +
      scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
      facet_wrap(~ cluster, scales = "free") +
      djvdj_theme() +
      theme(
        axis.text.y  = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x  = element_text(angle = 45, hjust = 1),
        axis.title   = element_blank()
      )
  }) %>%
  plot_grid(plotlist = .)

```

```{r "Cell type CellChat", eval = FALSE}

# Create CellChat objects
prfx     <- "all_"
typ_clmn <- "cell_type"
clmns    <- c("orig.ident", "treatment", "rep", typ_clmn)

typ_cc <- so_24 %>%
  run_cellchat(
    group_col    = "treatment",
    cell_col     = typ_clmn,
    include_cols = clmns,
    pos_group    = "CHIKV",
    prefix       = prfx,
    object_dir   = params$so_dir
  )

# Table of differential pathways
typ_net <- typ_cc$cellchat %>%
  netMappingDEG(
    features.name = "CHIKV",
    thresh = 1
  )

typ_net_up <- typ_cc$cellchat %>%
  subsetCommunication(
    net            = typ_net,
    datasets       = "CHIKV",
    ligand.logFC   = 0.2,
    receptor.logFC = NULL
  ) %>%
  filter(pval < 0.05)
  # filter(ligand.pvalues < 0.05)

```

```{r "LEC CellChat", eval = FALSE}

# Cell types to includes
# only include ones with >30 cells for mock and CHIKV
prfx     <- "lec_"
typ_clmn <- str_c(prfx, "type")
clmns    <- c("orig.ident", "treatment", "rep", "cell_type", typ_clmn)

typs <- so_24@meta.data %>%
  group_by(treatment, !!sym(typ_clmn)) %>%
  summarize(n = n(), .groups = "drop") %>%
  filter(n > 30) %>%
  group_by(!!sym(typ_clmn)) %>%
  filter(all(treats %in% treatment)) %>%
  ungroup() %>%
  pull(lec_type) %>%
  unique()

# Create CellChat objects
lec_cc <- so_24 %>%
  subset(!!sym(typ_clmn) %in% typs) %>%
  run_cellchat(
    group_col    = "treatment",
    cell_col     = typ_clmn,
    include_cols = clmns,
    pos_group    = "CHIKV",
    prefix       = prfx,
    object_dir   = params$so_dir
  )

# Table of differential pathways
lec_net <- lec_cc$cellchat %>%
  netMappingDEG(
    features.name = "CHIKV",
    thresh = 1
  )

lec_net_up <- lec_cc$cellchat %>%
  subsetCommunication(
    net            = lec_net,
    datasets       = "CHIKV",
    ligand.logFC   = 0.2,
    receptor.logFC = NULL
  ) %>%
  filter(
    ligand.pvalues < 0.05,
    ligand.logFC > 0.5,
    receptor.logFC > 0
  )

```

```{r "CHIKV TOTAL INTERACTIONS HEATMAP", fig.width = 6, fig.height = 5, eval = FALSE}

# All cell types
file.path(params$so_dir, "all_chikv_heat.png") %>%
  png(res = 300, width = 6, height = 5, units = "in")

typ_cc$cc_objs$CHIKV %>%
  netVisual_heatmap(color.heatmap = "Reds", measure = "weight")

dev.off()

# LEC types
file.path(params$so_dir, "lec_chikv_heat.png") %>%
  png(res = 300, width = 6, height = 5, units = "in")

lec_cc$cc_objs$CHIKV %>%
  netVisual_heatmap(color.heatmap = "Reds", measure = "weight")

dev.off()

```

```{r "DIFF INTERACTIONS HEATMAP", fig.width = 6, fig.height = 5, eval = FALSE}

# All cell types
file.path(params$so_dir, "all_diff_heat.png") %>%
  png(res = 300, width = 6, height = 5, units = "in")

typ_cc$cellchat %>%
  netVisual_heatmap(measure = "weight")

dev.off()

# LEC types
file.path(params$so_dir, "lec_diff_heat.png") %>%
  png(res = 300, width = 6, height = 5, units = "in")

lec_cc$cellchat %>%
  netVisual_heatmap(measure = "weight")

dev.off()

```

```{r "OLD GO", eval = FALSE}

# Find marker genes
Idents(so_24) <- so_24$treatment

marks <- typs %>%
  map_dfr(~ {
    so_24 %>%
      subset(lec_type == .x) %>%
      FindConservedMarkers(
        ident.1 = "CHIKV",
        ident.2 = "mock",
        grouping.var = "rep",
        only.pos = TRUE
      ) %>%
      as_tibble(rownames = "gene") %>%
      mutate(cell_type = .x)
  })

# Filter markers
reps <- unique(so_24$rep)

fc_clmns   <- str_c(reps, "_avg_log2FC")
p_clmns    <- str_c(reps, "_p_val_adj")
pct1_clmns <- str_c(reps, "_pct.1")
pct2_clmns <- str_c(reps, "_pct.2")

up <- marks %>%
  filter(
    if_all(all_of(fc_clmns),   ~ .x > log2(1.25)),
    if_all(all_of(p_clmns),    ~ .x < 0.05),
    if_all(all_of(pct1_clmns), ~ .x > 0.3),
    if_all(all_of(pct2_clmns), ~ .x < 0.5)
  )

# Identify GO terms
go <- up %>%
  split(.$cell_type) %>%
  imap_dfr(~ {
    bg <- so_24 %>%
      subset(lec_type == .y) %>%
      subset(treatment == treats[1])
    
    bg <- bg@assays$RNA@data %>%
      rowMeans() %>%
      sort(decreasing = TRUE) %>%
      head(5000) %>%
      names()
    
    res <- gost(
      query        = .x$gene,
      organism     = "mmusculus",
      domain_scope = "custom",
      custom_bg    = bg,
      evcodes      = TRUE,
      significant  = TRUE
    ) %>%
      .$result
    
    if (is_empty(res)) return(NULL)
    
    res %>%
      as_tibble() %>%
      mutate(query = .y) %>%
      dplyr::select(-evidence_codes, -parents)
  })

# Plot top GO terms
top_go <- go %>%
  filter(
    term_size > 10, term_size < 400,
    intersection_size > 5,
    source %in% c("GO:BP", "HP", "KEGG", "WP")
  ) %>%
  rowwise() %>%
  mutate(
    intersection = list(str_split(intersection, ",")[[1]]),
    frac_term = intersection_size / term_size
  ) %>%
  ungroup() %>%
  arrange(query, p_value)

top_go %>%
  group_by(query) %>%
  slice(1:10) %>%
  
  ggplot(aes(-log10(p_value), term_name, size = frac_term, color = query)) +
  geom_point() +
  facet_wrap(~ query) +
  scale_color_manual(values = lec_type_cols) +
  djvdj_theme()
  
```

```{r "GSEA", eval = FALSE}


```





