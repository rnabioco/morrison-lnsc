---
title: "CHIKV LNSC figures"
author: "Ryan Sheridan"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc:       true
    toc_float: true
    toc_depth: 2
    theme:     cosmo
    highlight: kate
params:
  template_dir: "src"
  so_dir:       "~/Dropbox/Ryan/Projects/morrison-lnsc/results/sobjs"
  orig_so_dir:  "~/Dropbox/Ryan/Projects/morrison-scRNA-seq/results"
editor_options: 
  chunk_output_type: inline
---

<br>

```{r "chunk opts", echo = FALSE}
# Default chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo    = FALSE,
  dpi     = 500
)
```

```{r "packages"}
# plotting
library(scales)
library(ggrepel)
library(ggtrace)
library(patchwork)
library(cowplot)
library(colorblindr)
library(ggtext)

# analysis
library(Seurat)
library(clustifyr)
library(clustifyrdata)
library(DoubletFinder)
library(M3Drop)
library(CellChat)
library(djvdj)
library(presto)
library(gprofiler2)
library(qs)

library(clusterProfiler)
library(enrichplot)
library(msigdbr)
library(org.Mm.eg.db)
library(GOSemSim)
library(biomaRt)
library(ggtree)

# tidyverse
library(tidyverse)
library(here)
library(knitr)
library(broom)

source(here(params$template_dir, "funs.R"))

chikv_grps <- c("CHIKV-low", "CHIKV-high")
```

```{r "functions"}
type_lab_fn <- function(x) str_replace(x, "_", " ")

plot_example_gene <- function(so_in, feat, grp, box_colors = NULL,
                              umap_colors = c("#56B4E9", "white", "#D7301F")) {
  
  dat <- so_in %>%
    FetchData(c(feat, grp, "UMAP_1", "UMAP_2"))
  
  u <- dat %>%
    arrange(!!sym(feat)) %>%
    ggplot(aes(UMAP_1, UMAP_2, fill = !!sym(feat))) +
    geom_point_trace(size = 0.25, stroke = 0.65) +
    scale_fill_gradientn(colours = umap_colors) +
    guides(fill = guide_colorbar(
      ticks          = FALSE,
      barheight      = unit(10, "pt"),
      barwidth       = unit(140, "pt"),
      title.position = "top"
    )) +
    umap_theme +
    theme(
      legend.position      = "top",
      legend.title         = element_text(hjust = 0.5),
      legend.justification = 0.5,
      panel.border         = element_rect(fill = NA, color = "grey85")
    )
  
  
  lvls <- dat %>%
    group_by(!!sym(grp)) %>%
    summarize(
      med   = median(!!sym(feat)),
      stats = list(boxplot.stats(!!sym(feat))),
      q3    = map_dbl(stats, ~ .x$stats[4]),
      q4    = map_dbl(stats, ~ .x$stats[5]),
      max   = max(!!sym(feat)),
      .groups = "drop"
    ) %>%
    arrange(med, q3, q4, max) %>%
    pull(grp) %>%
    rev()
  
  b <- dat %>%
    plot_violin(
      feat, grp,
      plot_colors   = box_colors,
      plot_lvls     = lvls,
      method        = "boxplot",
      outlier.size  = 0.25,
      outlier.alpha = 1
    ) +
    theme(
      legend.position = "none",
      aspect.ratio = 0.21,
      axis.text.x  = element_text(angle = 45, hjust = 1),
      axis.line.y  = element_line(size = 0.5, color = "grey85"),
      axis.ticks.x = element_blank(),
      panel.border = element_blank(),
      axis.title.x = element_blank()
    )
  
  plot_grid(
    u, b,
    ncol        = 1,
    rel_heights = c(1, 0.5),
    align       = "v",
    axis        = "rl"
  )
}

create_cor_heatmap <- function(df_in, ttl, lec_labs = NULL, ln_clr = fade_0) {
  
  # # Cell type labels
  # lec_labs <- df_in %>%
  #   format_labels(
  #     lab_clmn = "lec_type",
  #     char_vec = new_cell_labs,
  #     expr_vec = marco_expr
  #   )
  # 
  # ref_labs <- c(
  #   Valve      = "Valve LEC",
  #   Collecting = "Collecting LEC",
  #   Ptx3_LEC   = "Ptx3 LEC",
  #   Marco_LEC  = parse(text = marco_expr)
  # )
  
  if (!is.null(lec_labs)) {
    df_in <- df_in %>%
      filter(assigned_type %in% names(lec_labs()))
  }
  
  # Data for tile labels
  lab_df <- df_in %>%
    group_by(assigned_type) %>%
    slice_max(r, n = 1) %>%
    ungroup()
  
  # Create heatmaps
  res <- df_in %>%
    ggplot(aes(ref_type, assigned_type, fill = r)) +
    geom_tile(color = ln_clr, size = 0.2) +
    
    geom_text(
      aes(label = round(r, 2)),
      data  = lab_df,
      color = "black",
      size  = txt_pt1 / .pt
    ) +
    
    guides(fill = bar_gd()) +
    
    scale_fill_gradientn(colors = c(fade_0, "#E69F00")) +
    # scale_x_discrete(labels = ref_labs) +
    # scale_y_discrete(labels = lec_labs) +
    
    labs(title = ttl, x = "reference", y = "assigned type") +
    
    base_theme +
    theme(
      legend.text = element_text(size = txt_pt1),
      axis.line.x = element_blank(),
      axis.line.y = element_blank(),
      axis.text.x = element_text(hjust = 1, angle = 45, size = txt_pt1),
      axis.text.y = element_text(hjust = 1, size = txt_pt1),
      axis.title  = element_text(size = txt_pt2),
      plot.title  = element_text(size = ttl_pt1)
    )
  
  if (!is.null(lec_labs)) {
    res <- res +
      scale_y_discrete(labels = lec_labs)
  }
  
  res
}

create_gene_boxplot <- function(input, GENE, TYPE, clr = lec_type_cols[[TYPE]],
                                pval_y = 5) {
  
  # Format plot data
  dat <- input %>%
    FetchData(c("lec_type", "treatment", "rep", "orig.ident", "chikv_grp", GENE)) %>%
    filter(lec_type == TYPE) %>%
    mutate(chikv_grp = ifelse(treatment == "mock", treatment, chikv_grp))
  
  clrs <- set_names(
    c("grey", rep(clr, 2)),
    unique(dat$chikv_grp)
  )
  
  # Calculate p-values
  p_vals <- dat %>%
    calc_p_vals(
      data_column = GENE,
      type_column = "chikv_grp"
    )
  
  comps <- names(clrs) %>%
    combn(2, simplify = FALSE)
  
  comps <- list(
    x    = map_chr(comps, pluck, 1),
    xend = map_chr(comps, pluck, 2),
    y    = c(pval_y, pval_y + pval_y * 0.12, pval_y)
  )
  
  # Create boxplots
  res <- dat %>%
    plot_violin(
      GENE, "chikv_grp",
      method        = "boxplot",
      plot_colors   = clrs,
      plot_lvls     = names(clrs),
      alpha         = c(0.5, 0.1, 0.5),
      size          = 1,
      outlier.size  = 1.5,
      outlier.alpha = 1,
      width         = 0.6
    ) +
    labs(title = TYPE, y = str_c(GENE, " expression")) +
    base_theme +
    theme(
      legend.position = "none",
      aspect.ratio = 1.5,
      plot.title   = element_text(size = ttl_pt2 * 1.5),
      axis.title.y = element_text(size = ttl_pt2),
      axis.title.x = element_blank(),
      axis.text.x  = element_text(size = ttl_pt2, hjust = c(0.75, 0.5, 0.25)),
      plot.margin  = margin(5, 10, 5, 5)
    )
  
  # Add p-values to plot
  comps %>%
    pwalk(~ {
      v_args <- list(...)[c("x", "xend")]
      
      p <- p_vals %>%
        filter(`Cell type 1` %in% v_args & `Cell type 2` %in% v_args) %>%
        pull(p_adj)
      
      res <<- res %>%
        add_pvals(
          ...,
          p_val    = p,
          size     = txt_pt2 / .pt,
          line_col = "grey75"
        )
    })
  
  res
}

create_example_gene_fig <- function(df_in, gns, x_clmn, clrs = lec_type_cols,
                                    ttl = NULL) {
  res <- gns %>%
    imap(~ {
      lvls <- df_in %>%
        group_by(!!sym(x_clmn), tm_treat) %>%
        summarize(
          n     = n(),
          stats = list(boxplot.stats(!!sym(.x))),
          med   = map_dbl(stats, ~ .x$stats[3]),
          q3    = map_dbl(stats, ~ .x$stats[4]),
          q4    = map_dbl(stats, ~ .x$stats[5]),
          mx    = max(!!sym(.x)),
          .groups = "drop"
        ) %>%
        group_by(!!sym(x_clmn)) %>%
        summarize(across(c(med, q3, q4, mx), mean)) %>%
        arrange(med, q3, q4, mx) %>%
        pull(x_clmn) %>%
        rev()
      
      plt <- df_in %>%
        mutate(
          x_type    = fct_relevel(!!sym(x_clmn), lvls),
          chikv_grp = fct_relevel(chikv_grp, chikv_grps)
        ) %>%
        ggplot(
          # aes(x_type, !!sym(.x), color = x_type, fill = x_type, alpha = chikv_grp)
          aes(x_type, !!sym(.x), color = x_type, fill = x_type)
        ) +
        geom_boxplot(
          linewidth = 0.5, alpha = 0.5,  # color = "black",
          outlier.size = 0.01, outlier.alpha = 0.1,
          position = position_dodge2(preserve = "single"),
          key_glyph = draw_key_point,
        ) +
        scale_color_manual(values = clrs) +
        scale_fill_manual(values = clrs) +
        scale_alpha_manual(values = c(`CHIKV-low` = 0.5, `CHIKV-high` = 1)) +
        scale_x_discrete(labels = type_lab_fn) +
        facet_wrap(~ tm_treat, ncol = 1) +
        labs(y = str_c(.x, " expression")) +
        guides(
          fill = "none", color = "none",
          alpha = guide_legend(
            override.aes = list(shape = 15, fill = "black", size = 4)
          )
        ) +
        # base_theme +
        djvdj_theme() +
        theme(
          aspect.ratio    = 0.15,
          plot.title      = element_text(hjust = 0.5),
          legend.position = "top",
          legend.title    = element_blank(),
          # legend.text     = element_text(size = txt_pt1),
          axis.title.x    = element_blank(),
          axis.text.x     = element_text(angle = 45, hjust = 1),
          # axis.text.y     = element_text(size = txt_pt1 * 0.75),
          # strip.text      = element_text(size = txt_pt2)
        )
      
      if (.y == 1 && !is.null(ttl)) {
        plt <- plt + ggtitle(ttl)
      }
      
      plt
    })
  
  res
}

.format_pvalue <- function(p, digits = 1, cutoffs = NULL) {

  # Set p label based on vector of cutoffs
  if (!is.finite(p)) return(as.character(NA))

  if (!is.null(cutoffs)) {
    if (any(duplicated(cutoffs))) {
      cli::cli_abort("Cutoff values for p_label must be unique.")
    }

    # Set default labels when not provided by user
    if (is.null(names(cutoffs))) {
      cutoffs <- sort(cutoffs, decreasing = TRUE)

      names(cutoffs) <- purrr::imap_chr(
        cutoffs, ~ paste0(rep("*", .y), collapse = "")
      )
    }

    cutoffs <- sort(cutoffs)
    p_label <- as.character(NA)

    for (val in names(cutoffs)) {
      if (p < cutoffs[val]) {
        p_label <- val

        break()
      }
    }

    # Treat "value" as a keyword that will allow user to display actual
    # p-value for a certain cutoff
    # All custom labels need to be wrapped in quotes for parsing
    if (!identical(p_label, "value")) {
      if (!is.na(p_label)) p_label <- paste0("\'", p_label, "\'")

      return(p_label)
    }
  }

  # Format p-value label
  if (p >= 0.1)    return(as.character(round(p, 1)))
  else if (p == 0) return(as.character(p))

  p <- scales::label_scientific(digits = digits)(p)

  ex <- str_extract_all(p, "[+\\-][0-9]+$")

  p <- sub(paste0("\\", ex, "$"), "", p)

  ex <- as.numeric(ex)
  ex <- as.character(ex)

  p <- sub("e", "*x*10^", p)
  p <- paste0(p, ex)

  p
}

create_example_gene_fig2 <- function(df_in, gns, x_clmn, al_clmn,
                                     plot_lvls = NULL, clrs = lec_type_cols,
                                     ttl = NULL) {
  
  vars <- unique(df_in[[al_clmn]])
  
  p_cuts <- c(0.01, 0.001, 0.0001)
  
  res <- gns %>%
    imap(~ {
      # Calculate p-values
      # ONLY SHOW <0.01
      p_dat <- df_in %>%
        mutate(x_type = !!sym(x_clmn)) %>%
        group_by(x_type) %>%
        filter(n_distinct(!!sym(al_clmn)) == 2) %>%
        summarize(
          p = wilcox.test(
            (!!sym(.x))[!!sym(al_clmn) == vars[1]],
            (!!sym(.x))[!!sym(al_clmn) == vars[2]]
          )$p.value,
          .groups = "drop"
        ) %>%
        filter(!is.na(p)) %>%
        mutate(p_adj = p.adjust(p)) %>%
        rowwise() %>%
        mutate(p_lab = .format_pvalue(p_adj, cutoffs = p_cuts)) %>%
        ungroup()
        # filter(p_adj < 0.01)
      
      # Set plot levels
      lvls <- df_in %>%
        group_by(!!sym(x_clmn), tm_treat) %>%
        summarize(
          n     = n(),
          stats = list(boxplot.stats(!!sym(.x))),
          med   = map_dbl(stats, ~ .x$stats[3]),
          q3    = map_dbl(stats, ~ .x$stats[4]),
          q4    = map_dbl(stats, ~ .x$stats[5]),
          mx    = max(!!sym(.x)),
          .groups = "drop"
        ) %>%
        group_by(!!sym(x_clmn)) %>%
        summarize(across(c(med, q3, q4, mx), mean)) %>%
        arrange(med, q3, q4, mx) %>%
        pull(x_clmn) %>%
        rev()
      
      lvls <- unique(c(plot_lvls, lvls))
      
      # Create boxplots
      plt <- df_in %>%
        mutate(
          x_type    = fct_relevel(!!sym(x_clmn), lvls),
          chikv_grp = fct_relevel(chikv_grp, chikv_grps),
          treatment = fct_relevel(treatment, treats)
        ) %>%
        ggplot(
          aes(x_type, !!sym(.x), color = x_type, fill = x_type, alpha = !!sym(al_clmn))
        ) +
        geom_boxplot(
          linewidth = 0.5,
          outlier.size = 0.2, outlier.alpha = 0.1,
          position = position_dodge2(preserve = "single"),
          key_glyph = draw_key_point,
        ) +
        scale_color_manual(values = clrs) +
        scale_fill_manual(values = clrs) +
        scale_alpha_manual(values = c(mock = 0.25, CHIKV = 0.75)) +
        scale_x_discrete(labels = type_lab_fn) +
        facet_wrap(~ tm, ncol = 1) +
        labs(y = str_c(.x, " expression")) +
        guides(
          fill = "none", color = "none",
          alpha = guide_legend(
            override.aes = list(shape = 15, fill = "black", size = 4)
          )
        ) +
        djvdj_theme() +
        theme(
          # aspect.ratio    = 0.25,
          plot.title      = element_text(hjust = 0.5),
          legend.position = "top",
          legend.title    = element_blank(),
          # legend.text     = element_text(size = txt_pt1),
          axis.title.x    = element_blank(),
          axis.text.x     = element_text(angle = 45, hjust = 1),
          # axis.text.y     = element_text(size = txt_pt1 * 0.75),
          strip.text      = element_text(size = txt_pt2)
        )
      
      # Add p-values
      plt <- plt +
        geom_text(
          aes(y = Inf, fill = NULL, label = p_lab),
          data  = p_dat,
          vjust = 1.5,
          color = "black",
          alpha = 1,
          parse = TRUE,
          size  = 16 / .pt
        ) +
        scale_y_continuous(expand = expansion(c(0.05, 0.15)))
      
      if (.y == 1 && !is.null(ttl)) {
        plt <- plt + ggtitle(ttl)
      }
      
      plt
    })
  
  res
}

#' Fill the upper triangular matrix completely
#' 
#' FROM ENRICHPLOT
#'
#' @param x termsim similarity matrix
#' @param keep GO terms to keep
#' @return a data.frame
#' @noRd
fill_termsim <- function(x, keep = NULL) {
  if (!is.null(keep)) termsim <- x[keep, keep]
  else                termsim <- x
  
  termsim[which(is.na(termsim))] <- 0
  
  termsim2 <- termsim + t(termsim)
  
  for ( i in seq_len(nrow(termsim2))) termsim2[i, i] <- 1
  
  termsim2
}

#' Fetch genes for the provided annotations
fetch_genes <- function(terms, mart) {
  att  <- c("ensembl_gene_id", "external_gene_name")
  names(terms) <- names(terms) %||% rep("go_parent_name", length(terms))
  names(terms)[names(terms) == ""] <- "go_parent_name"

  res <- terms %>%
    imap(~ {
      biomaRt::getBM(
        attributes = att,
        filters    = .y,
        values     = .x,
        mart       = mart
      ) %>%
        pull(external_gene_name)
    }) %>%
    reduce(c) %>%
    unique()

  res
}

#' Identify DEGs
#' 
#' @param so_in Seurat object to use for identifying DEGs
#' @param ident_1 Cell label to use for comparing gene expression
#' @param ident_2 Cell label to compare with ident_1
#' @param pval p-value cutoff for filtering DEGs
#' @param log_fc Vector containing upper and lower fold change cutoffs to use
#' for filtering DEGs
#' @param type_clmn Column in object containing cell types, DEGs will be
#' identified separately for each cell type
#' @param treat_clmn Column in object containing ident_1 and ident_2 labels
#' @param rep_clmn Column in object containing replicate IDs
#' @param exclude_types Vector containing cell types to exclude from analysis
#' @param file Path to output file to use for saving results
get_degs <- function(so_in, ident_1 = "CHIKV", ident_2 = "mock",
                     pval = 0.05, log_fc = c(0.15, Inf),
                     type_clmn = "subtype", treat_clmn = "treatment",
                     rep_clmn = "rep", exclude_types = c("other", "unassigned"),
                     file = NULL) {
  
  Idents(so_in) <- unlist(so_in[[treat_clmn]], use.names = FALSE)
  
  so_in <- so_in %>%
    mutate_meta(mutate, treat_rep = str_c(!!sym(treat_clmn), !!sym(rep_clmn)))
  
  typs <- get_cell_types(so_in, "subtype", "treat_rep")
  typs <- typs[!typs %in% exclude_types]
  
  if (!is.null(file) && file.exists(file)) {
    cli::cli_alert("Loading file {.file {file}}")
    
    return(read_tsv(file))
  }
  
  degs <- typs %>%
    map_dfr(~ {
      so_in %>%
        subset(subtype == .x) %>%
        FindConservedMarkers(
          ident.1         = ident_1,
          ident.2         = ident_2,
          grouping.var    = rep_clmn,
          logfc.threshold = min(abs(log_fc)),
          min.cells.group = 3
        ) %>%
        mutate(subtype = .x) %>%
        as_tibble(rownames = "gene")
    })
  
  reps     <- unique(unlist(so_in[[rep_clmn]], use.names = FALSE))
  fc_clmns <- str_c(reps, "_avg_log2FC")
  
  # Filter DEGs
  degs <- degs %>%
    filter(
      if_all(all_of(fc_clmns), ~ .x > log_fc[1] & .x < log_fc[2]),
      max_pval < pval
    ) %>%
    arrange(max_pval)

  if (!is.null(file)) {
    write_tsv(degs, file)
  }
  
  degs
}

#' Identify GO terms
#' 
#' By default all expressed genes are used as background for the cell type
#' This will include results for all terms regardless of significance, need
#' all terms for creating heatmaps
#' 
#' @param gns Named list of differentially expressed genes for each cell type
#' @param so_in Seurat object so use for determining background gene set
#' @param type_clmn Column in Seurat object containing cell types, these should
#' match the cell types provided by gns
#' @param max_term_size Maximum term size to include in results
#' @param min_term_size Minimum term size to include in results
#' @param db GO database to use, specify 'ALL' to use all three
#' @param simplify_terms Should GO terms be simplified to removed redundant
#' results, this has a significant effect on performance
#' @param n_bkgd Number of top expressed genes to include for the background
#' gene set
#' @param exclude_genes Regular expression to use for removing genes before
#' performing GO analysis
#' @param sim_data Similarity data to use for simplifying GO terms, generated
#' using [clusterProfiler::godata()]
#' @param file Path to output file for saving results
get_go <- function(gns, so_in, type_clmn = "subtype", max_term_size = 750,
                   min_term_size = 10, db = "BP", simplify_terms = TRUE,
                   n_bkgd = Inf, exclude_genes = "^(Rp[sl]|mt-)",
                   sim_data = go_sim_data, file = NULL) {

  # Check for save GO file
  obj_file <- str_c(file, ".qs")
  tbl_file <- str_c(file, ".tsv")
  
  if (!is.null(file) && file.exists(obj_file)) {
    cli::cli_alert("Loading file {.file {obj_file}}")
    
    return(qread(obj_file))
  }
  
  # Identify background gene set for each cell type
  bkgd <- gns %>%
    imap(~ {
      bkgd <- NULL
      
      if (!is.null(so_in)) {
        if (is.character(.y)) bkgd <- subset(so_in, !!sym(type_clmn) == .y)
        else                  bkgd <- so_in
        
        bkgd <- bkgd@assays$RNA@data %>%
          rowMeans() %>%
          sort(decreasing = TRUE) %>%
          head(n_bkgd)
        
        bkgd <- names(bkgd[bkgd > 0])
      }
      
      bkgd
    })
  
  # Identify GO terms for each gene list
  # exclude specified genes
  go <- gns %>%
    imap(~ {
      .x <- .x[!grepl(exclude_genes, .x)]
      
      g <- .x %>%
        enrichGO(
          keyType      = "SYMBOL",
          OrgDb        = org.Mm.eg.db,
          universe     = bkgd[[.y]],
          maxGSSize    = max_term_size,
          minGSSize    = min_term_size,
          pvalueCutoff = 1.1,
          qvalueCutoff = 1.1,
          ont          = db
        )
      
      # Add background genes for each term to object
      # need this to calculate overall fold enrichment for GO clusters
      bkgd_gns <- g@result$ID %>%
        bitr(
          fromType = "GOALL", toType = "SYMBOL",
          OrgDb = org.Mm.eg.db
        ) %>%
        filter(SYMBOL %in% bkgd[[.y]]) %>%
        split(.$GOALL)
      
      bkgd_gns <- bkgd_gns %>%
        map_chr(~ {
          .x$SYMBOL %>%
            unique() %>%
            str_c(collapse = "/")
        })
      
      g %>%
        mutate(bkgdID = bkgd_gns[ID])
    })
  
  # Merge GO objects  
  if (!is.null(names(go))) {
    go <- merge_result(go)
    
    go@fun <- "enrichGO"
    
  } else if (length(go) == 1) {
    go <- go[[1]]
  }
  
  # Simplify terms
  # this collapses terms that are very similar
  if (simplify_terms) {
    go <- go %>%
      clusterProfiler::simplify(semData = sim_data)
  }
  
  # Save results
  if (!is.null(file)) {
    qsave(go, obj_file)
    
    go@compareClusterResult %>%
      write_tsv(tbl_file)
  }
  
  go
}

#' Cluster GO terms
#' 
#' @param go_in Object containing GO results
#' @param k Number of clusters to identify
#' @param pval Cutoff for filtering terms based on adjusted p-value, only
#' significant terms are used for clustering
#' @param qval Cutoff for filtering terms based on q-value
#' @param n_overlap Minimum number of genes needed to overlap term for it to be
#' included for clustering
#' @param n_shared Minimum number of cell types that term has to be shared with
#' for it to be included for clustering
#' @param sim_data Similarity data to use for clustering GO terms, generated
#' using [clusterProfiler::godata()]
get_clusters <- function(go_in, k = 3, pval = 0.05, qval = 0.2, n_overlap = 3,
                         n_shared = 2, sim_data = go_sim_data) {
  
  # Filter GO terms
  # calculate summary stats for each term
  # sort by number of cell types that share the term
  go_in <- go_in %>%
    filter(p.adjust < pval, qvalue < qval, Count >= n_overlap)
  
  top_terms <- go_in@compareClusterResult %>%
    separate(GeneRatio, into = c("n_ovlp", "tot_genes"), sep = "/", convert = TRUE) %>%
    separate(BgRatio, into = c("n_bg_ovlp", "tot_bg_genes"), sep = "/", convert = TRUE) %>%
    mutate(
      GeneRatio  = n_ovlp / tot_genes,
      BgRatio    = n_bg_ovlp / tot_bg_genes,
      enrichment = GeneRatio / BgRatio
    ) %>%
    
    group_by(Description, ID) %>%
    summarize(
      n          = n_distinct(Cluster),  # number of cell types with term
      enrichment = mean(enrichment),      
      p.adjust   = mean(p.adjust),       # mean p-value across cell types
      qvalue     = mean(qvalue),         # mean q-value across cell types
      .groups    = "drop"          
    ) %>%
    arrange(desc(n), p.adjust) %>%
    dplyr::filter(n >= n_shared)

  # Set number of clusters
  # must average > 2 terms per cluster
  if (nrow(top_terms) < 2) return(NULL)
  
  k <- min(k, floor(nrow(top_terms) / 2))
  
  # Calculate similarity metric for top terms
  # fill in upper triangle of matrix and filter terms
  # only include significant terms shared with at least two cell types
  go_dist <- go_in %>%
    pairwise_termsim(semData = sim_data) %>%
    .@termsim %>%
    fill_termsim(keep = top_terms$Description)
  
  # Cluster terms
  # use ward.D method to avoid overlapping ancestor nodes of each group
  hc <- stats::hclust(
    stats::as.dist(1 - go_dist),
    method = "ward.D"
  )
  
  clst_obj <- stats::cutree(hc, k)
  
  clsts <- tibble(
    Description = names(clst_obj),
    cluster     = unname(clst_obj)
  )
  
  # Format output object
  res <- clsts %>%
    left_join(top_terms, by = "Description") %>%
  
    arrange(cluster, desc(n), p.adjust) %>%
    group_by(cluster) %>%
    mutate(
      cluster_n_terms = n_distinct(Description),
      cluster_mean_p  = mean(p.adjust)
    ) %>%
    ungroup() %>%
    arrange(cluster, desc(n), p.adjust)
  
  res <- list(
    clusters = res,
    object   = hc,
    clusters_object = clst_obj
  )
  
  res
}

#' Create heatmaps summarizing GO clusters for each cell type
#' 
#' @param df_in data.frame containing clustering results generated with
#' get_clusters(), this provides the terms and cluster assignments to plot
#' @param go_in Object containing GO results, this is used to plot p-values and
#' GeneRatio for each cell type
#' @param n_clusters Number of top GO clusters to plot, clusters are sorted by
#' number of terms, with the top clusters having the most terms
#' @param n_terms The number of top terms to show for each cluster, terms are
#' sorted by the number of cell types that share the term and the overall mean
#' p-value for the term (averaged across all cell types)
#' @param pval Adjusted p-value cutoff for marking significant terms, this
#' cutoff should match the cutoff used for clustering GO terms
#' @param qval q-value cutoff for marking significant terms
#' @param n_overlap Minimum number of genes needed to overlap the term for it to
#' be marked as significant
#' @param n_genes Minimum number of DEGs for cell type to be included on plot
#' @param clrs Colors to use for each cluster
#' @param n_col Number of columns to use for organizing facets (each cluster is
#' plotted as a separate facet)
#' @param cluster_labels Vector containing descriptive labels for each cluster
create_go_heatmap <- function(df_in, go_in, n_clusters = 2, n_terms = 5,
                              pval = 0.05, qval = 0.2, n_overlap = 3, n_genes = 3,
                              clrs = c("orange", "lightblue", "red"), n_col = 1,
                              include_overall_score = FALSE, free_y = FALSE,
                              cluster_labels = NULL) {
  
  # Top GO terms to plot
  # df_in includes combined GO terms identified across all cell types
  # sort to show shared terms at the top, sort by mean adjusted p-value for term
  top_clusters <- df_in$cluster %>%
    table() %>%
    sort(decreasing = TRUE) %>%
    head(n_clusters) %>%
    names()
  
  n_seq <- seq_len(n_terms)
  
  terms <- df_in %>%
    dplyr::filter(cluster %in% top_clusters) %>%
    mutate(shared = n > 1) %>%
    arrange(cluster, desc(n), desc(enrichment)) %>%
    # arrange(cluster, desc(n), p.adjust) %>%
    # arrange(cluster, desc(shared), p.adjust) %>%
    group_by(cluster) %>%
    dplyr::slice(n_seq) %>%
    ungroup()
  
  n_terms <- terms %>%
    group_by(cluster) %>%
    summarize(n = n_distinct(Description), .groups = "drop") %>%
    pull(n) %>%
    max()
  
  # Data for heatmap
  cluster_ids <- df_in %>%
    dplyr::select(Description, cluster)
  
  agg_lab <- "Overall Enrichment"
  lvls    <- c(agg_lab, rev(terms$Description))
  
  dat <- go_in@compareClusterResult %>%
    as_tibble() %>%
    left_join(cluster_ids, by = "Description") %>%
    filter(cluster %in% top_clusters) %>%
    separate(GeneRatio, into = c("n_ovlp", "tot_genes"), sep = "/", convert = TRUE) %>%
    separate(BgRatio, into = c("n_bg_ovlp", "tot_bg_genes"), sep = "/", convert = TRUE) %>%
    mutate(
      GeneRatio  = n_ovlp / tot_genes,
      BgRatio    = n_bg_ovlp / tot_bg_genes,
      enrichment = GeneRatio / BgRatio
    )
  
  # Calculate aggregated fraction overlap
  # only show cell types with >= 10 overlapping genes
  agg_dat <- dat
  
  if (!include_overall_score) {
    agg_dat <- agg_dat %>%
      filter(Description %in% terms$Description)
  }
  
  agg_dat <- agg_dat %>%
    mutate(
      geneID = str_split(geneID, "/"),
      bkgdID = str_split(bkgdID, "/")
    ) %>%
    group_by(Cluster, cluster, tot_genes, tot_bg_genes) %>%
    summarize(
      tot_ovlp    = n_distinct(reduce(geneID, c)),
      tot_bg_ovlp = n_distinct(reduce(bkgdID, c)),
      .groups     = "drop"
    ) %>%
    mutate(
      GeneRatio   = tot_ovlp / tot_genes,
      BgRatio     = tot_bg_ovlp / tot_bg_genes,
      enrichment  = GeneRatio / BgRatio,
      Description = agg_lab
    ) %>%
    filter(tot_genes >= n_genes)
  
  # If not including overall score sort based on terms shown
  typ_lvls <- agg_dat %>%
    arrange(desc(enrichment)) %>%
    mutate(Cluster = fct_inorder(as.character(Cluster))) %>%
    pull(Cluster) %>%
    levels() 
  
  dat <- dat %>%
    filter(
      Description %in% terms$Description,
      Cluster %in% typ_lvls
    )
  
  if (include_overall_score) {
    dat <- dat %>%
      bind_rows(agg_dat)
  }
  
  dat <- dat %>%
    mutate(Description = fct_relevel(Description, lvls)) %>%
    arrange(Description) %>%
    mutate(
      Description = str_trunc(as.character(Description), width = 70, side = "right"),
      Description = str_wrap(Description, width = 40),
      Description = fct_inorder(Description),
      Cluster     = fct_relevel(Cluster, typ_lvls)
    )
  
  ## THIS COULD BE USED TO CALCULATE COMBINED SIGNIFICANCE
  # Fill in missing values
  # these are terms with 0 overlapping genes for the cell type
  # assign p-value of 1 and gene ratio of 0
  # dat <- dat %>%
  #   complete(
  #     crossing(Description, Cluster),
  #     fill = list(GeneRatio = 0, p.adjust = 1)
  #   )
  # 
  # dat %>%
  #   group_by(Cluster) %>%
  #   summarize(
  #     n = length(p.adjust[p.adjust < 0.05]),
  #     frac = n / n(),
  #     
  #     GeneRatio = mean(GeneRatio),
  #     meanp     = (metap::meanp(p.adjust))$p,
  #     fisher    = (metap::sumlog(p.adjust))$p,
  #     wilk      = (metap::maximump(p.adjust))$p,
  #     p.adjust  = mean(p.adjust)
  #   )
    
  # Data for significant terms for each cell type
  # this differs from df_in, since df_in does not contain p-values for each
  # cell type, just mean p-values summarizing overall significance across
  # all cell types
  p_dat <- dat %>%
    dplyr::filter(p.adjust < pval, qvalue < qval, Count >= n_overlap) %>%
    mutate(enriched = "Significant")
  
  # Create heatmap
  # ggplot(aes(Cluster, Description, fill = as.character(cluster), alpha = -log10(p.adjust))) +
  agg_fn <- function(x) {
    new_agg <- str_replace_all(agg_lab, " ", "~")
    new_agg <- str_c("bold(", new_agg, ")")
    
    x[x == agg_lab] <- parse(text = new_agg)
    x
  }
  
  if (!include_overall_score) agg_fn <- ggplot2::waiver()
  
  res <- dat %>%
    ggplot(aes(Cluster, Description, fill = as.character(cluster), alpha = enrichment)) +
    geom_tile() +
    geom_point(
      aes(color = enriched, fill = NULL),
      data   = p_dat,
      alpha  = 1,
      shape  = 5,
      size   = 2,
      stroke = 0.75
    ) +
    scale_alpha_continuous(range = c(0, 1), n.breaks = 6) +
    scale_color_manual(values = "black") +
    scale_fill_manual(values = clrs) +
    scale_y_discrete(labels = agg_fn) +
    guides(
      alpha = guide_legend(
        keyheight      = unit(7, "pt"),
        label.position = "bottom",
        order          = 1,
        title          = "Enrichment Score",
        title.position = "top",
        nrow           = 1
      ),
      color = guide_legend(
        title = NULL,
        label.position = "top",
        label.theme = element_text(size = 11),
        override.aes = list(size = 3, stroke = 1)
      ),
      fill = "none"
    ) +
    djvdj_theme() +
    theme(
      legend.position = "bottom",
      legend.title    = element_text(hjust = 0.5),
      axis.title      = element_blank(),
      axis.text.x     = element_text(angle = 45, hjust = 1),
      strip.clip      = "off"
    )
  
  if (include_overall_score) {
    res <- res +
      geom_hline(yintercept = 1.5, size = 1.5, color = "white")
  }
  
  if (free_y) {
    res <- res +
      facet_grid(
        rows = "cluster",
        scales = "free_y", space = "free_y",
        labeller = cluster_labels %||% "label_value"
      )
  } else {
    res <- res +
      facet_wrap(
        ~ cluster, ncol = n_col, scales = "free_y",
        labeller = cluster_labels %||% "label_value"
      ) +
      theme(aspect.ratio = n_terms / n_distinct(dat$Cluster))
  }
  
  res <- list(
    heatmap = res,
    terms = terms
  )
  
  res
}

#' Create line graphs plotting mean expression of upregulated genes
#' 
#' @param exp_data Named list of Seurat objects containing expression data to
#' plot
#' @param deg_data Named list of data.frames containing DEGs, this is used to
#' determine which genes are upregulated for each cell type and timepoint, the
#' names need to match the names provided for exp_data
#' @param gns Named vector specifying genes to plot, the names should be the
#' gene symbol and the values should be the cluster ID. Genes can be colored
#' based on cluster ID
#' @param clrs Colors to use for each cluster
#' @param cell_types The number of top cell types to include, cell types with
#' the most upregulated genes will be included. Alternatively a vector of cell
#' types to include can be provided.
#' @param lvls Levels to use for ordering values in treatment column
#' @param n_cells Number of cells that must be present for each replicate of
#' each treatment group for the cell type to be included
create_gene_plots <- function(exp_data = list("8hpi" = so_8, "24hpi" = so_merge),
                              deg_data =  list("8hpi" = degs$`so_8-up`, "24hpi" = degs$`so_merge-up`),
                              gns,
                              clrs = c(`1` = "orange"), cell_types = 8,
                              lvls = c("mock", "8hpi", "24hpi"), n_cells = 10) {
  
  # Genes to plot
  genes <- names(gns)
  
  # Format gene expression input data
  exp_data <- exp_data %>%
    imap_dfr(~ {
      .x %>%
        FetchData(c("subtype", "orig.ident", "treatment", "rep", genes)) %>%
        as_tibble(rownames = ".cell_id") %>%
        mutate(tm = .y) %>%
        pivot_longer(all_of(names(gns)))
    }) %>%
                                                     # only use mock data and 8hpi data from 8hpi object
    filter(treatment != "8hpi" | tm != "24hpi") %>%  # exclude 8hpi CHIKV data from 24hpi objects (e.g. so_merge)
    filter(tm == "8hpi" | treatment != "mock") %>%   # exclude mock data from 24hpi objects (e.g. so_24)
                                                     # redefine treatment as mock or tm
    mutate(treatment = ifelse(treatment %in% lvls, treatment, tm))
    
  # Only include samples with >10 cells for each replicate
  exp_data <- exp_data %>%
    group_by(subtype, treatment) %>%
    mutate(reps = list(unique(rep))) %>%
    group_by(subtype, treatment, rep) %>%
    filter(n_distinct(.cell_id) >= n_cells) %>%
    
    group_by(subtype, treatment) %>%
    filter(all(unique(unlist(reps)) %in% rep)) %>%
    group_by(subtype, name) %>%
    filter(n_distinct(treatment) > 1) %>%
    ungroup()
  
  # Format DEG input data
  deg_data <- deg_data %>%
    imap_dfr(~ {
      .x %>%
        dplyr::filter(gene %in% genes) %>%
        dplyr::mutate(treatment = .y) %>%
        dplyr::select(gene, treatment, subtype, max_pval)
    })
  
  # Filter for top cell types to plot
  if (!is.null(cell_types)) {
    if (is.numeric(cell_types)) {
      cell_types <- deg_data %>%
        group_by(subtype) %>%
        summarize(n_genes = n(), .groups = "drop") %>%
        arrange(desc(n_genes)) %>%
        head(cell_types) %>%
        pull(subtype)
    }
    
    exp_data <- exp_data %>%
      dplyr::filter(subtype %in% cell_types)
  }
  
  # Format data for plotting points
  plt_dat <- exp_data %>%
    group_by(subtype, treatment, name) %>%
    summarize(
      n       = n(),
      q3      = quantile(value, 0.75),
      q1      = quantile(value, 0.25),
      value   = median(value),
      .groups = "drop"
      # sd      = sd(value),
      # err     = qt(0.975, df = n - 1) * (sd / sqrt(n)),  # 95% CI
    ) %>%
    mutate(
      x_end     = match(treatment, lvls),
      x         = x_end - 1,
      treatment = fct_relevel(treatment, lvls),
      cluster   = gns[name],
      name      = fct_relevel(name, genes)
    )
  
  # Format data for plotting lines
  # only plot cell types with at least one gene upregulated
  # plot as segments so linetype can be varied based on significance
  # need to pull table of DEGs to determine which timepoints/genes are signif
  # pull median expression to use for the start and end of each segment
  exp_dat <- plt_dat %>%
    dplyr::select(name, treatment, subtype, value)
  
  ln_dat <- plt_dat %>%
    left_join(deg_data, by = c(name = "gene", "treatment", "subtype")) %>%
    
    dplyr::filter(x > 0) %>%  # remove rows that start at 0 (occurs for mock)
    
    # need to set columns with treatment labels for segment start/end so
    # correct expression values can be pulled
    mutate(trt_end = lvls[x_end], trt_start = lvls[x]) %>%
    
    dplyr::select(
      name, treatment, subtype, cluster,
      x, x_end, trt_start, trt_end,
      max_pval
    ) %>%
    
    left_join(exp_dat, by = c("name", trt_start = "treatment", "subtype")) %>%
    dplyr::rename(y = value) %>%
    
    left_join(exp_dat, by = c("name", trt_end = "treatment", "subtype")) %>%
    dplyr::rename(y_end = value) %>%
    
    mutate(
      Upregulated = as.character(!is.na(max_pval)),
      Upregulated = fct_relevel(Upregulated, c("TRUE", "FALSE")),
      name        = fct_relevel(name, genes)
    ) %>%
    group_by(subtype) %>%
    filter(any(Upregulated == "TRUE")) %>%
    ungroup()
  
  # Create plots
  aspect <- length(genes) / n_distinct(plt_dat$name) * 0.9
  
  res <- plt_dat %>%
    filter(subtype %in% unique(ln_dat$subtype)) %>%
    ggplot(aes(treatment, value, color = cluster)) +
    
    geom_errorbar(
      aes(x = treatment, ymin = q1, ymax = q3),
      color = "grey90",
      # color = "grey85",
      width = 0,
      # linewidth = 0.25
      linewidth = 1.5
    ) +
    geom_point(size = 1.5) +
    geom_segment(
      aes(
        x = x, xend = x_end, y = y, yend = y_end,
        linetype = Upregulated
      ),
      linewidth = 0.75,
      data  = ln_dat
    ) +
    facet_grid(name ~ subtype, switch = "y", scales = "free_y") +
    
    scale_linetype_manual(values = c("TRUE" = 1, "FALSE" = 3)) +
    scale_color_manual(values = clrs) +
    scale_y_continuous(
      breaks = (function(x) return(c(0, floor(max(x))))),
      expand = expansion(c(0.2, 0.05))
    ) +
    scale_x_discrete(labels = c(mock = "m", `8hpi` = "8h", `24hpi` = "24h")) +
    guides(
      color = "none",
      linetype = guide_legend(title.position = "top", title.hjust = 0.5)
    ) +
    
    djvdj_theme() +
    theme(
      aspect.ratio    = aspect,
      legend.position = "bottom",
      legend.title    = element_text(hjust = 0.5),
      strip.clip      = "off",
      strip.placement = "outside",
      axis.title      = element_blank()
    )
  
  res
}
```

```{r "load objects"}
# Directories to save modified objects
so_8_dir  <- here(params$so_dir, "so_8.qs")
so_24_dir <- here(params$so_dir, "so_24.qs")

lec_cell_types <- "Endothelial cells"
fib_cell_types <- c("Fibroblasts", "Stromal cells")

# Replace this with setup.Rmd that has code used to process each sample
if (!file.exists(so_8_dir) || !file.exists(so_24_dir)) {
  so_8  <- read_rds(file.path(params$orig_so_dir, "2021-07-16/sobjs/so.rds"))
  so_24 <- read_rds(file.path(params$orig_so_dir, "2021-01-08/sobjs/so.rds"))
  
  # Adjust 24 hpi
  # Add PvCs to cell types
  # This is based on clustifyr results using ref_lymphnodestromal, and Pecam1,
  # Pdpn, Itga7, and Acta2 expression
  so_24 <- so_24 %>%
    mutate_meta(
      mutate,
      cell_type   = case_when(
        fib_type == "PvC"             ~ fib_type,
        cell_type %in% fib_cell_types ~ "FRC",
        TRUE                          ~ cell_type
      )
    )
  
  so_24 <- so_24 %>%
    mutate_meta(
      mutate,
      lec_type = case_when(
        lec_subtype == "unassigned"   ~ "unassigned-LEC",
        cell_type %in% lec_cell_types ~ lec_subtype,
        TRUE                          ~ cell_type
      )
    )
  
  so_24 <- so_24 %>%
    mutate_meta(
      mutate,
      subtype = ifelse(lec_subtype == "other", fib_subtype, lec_subtype)
    )
  
  so_24 <- so_24 %>%
    mutate_meta(
      mutate,
      chikv_type = if_else(chikv_grp == chikv_grps[2], lec_type, chikv_grp)
    )
  
  # Adjust 8 hpi
  # Cluster 27 appears to be FRCs based on Pdpn, Pecam1, and Pdgfra
  # Adjust subtype column
  so_8 <- so_8 %>%
    mutate_meta(
      mutate, 
      orig.ident = str_c(treatment, "-", rep),
      lec_type = recode(
        lec_type,
        `unassigned-LEC`     = "unassigned",
        Fibroblasts          = "FRC",
        `Stromal cells (DN)` = "PvC"
      ),
      chikv_grp = ifelse(tot_nCount_CHIKV > 0, chikv_grps[2], chikv_grps[1])
    )
  
  so_8 <- so_8 %>%
    mutate_meta(
      mutate,
      subtype = ifelse(lec_subtype == "other", fib_subtype, lec_subtype)
    )
  
  ### NEED TO UPDATE THIS FOR SUBTYPES ###
  so_8 <- so_8 %>%
    mutate_meta(
      mutate,
      lec_type = ifelse(RNA_snn_res.5 == "27", "FRC", lec_type)
    )
  
  # Save objects
  qsave(so_8, so_8_dir)
  qsave(so_24, so_24_dir)
  
  rm(so_8, so_24)
}

# # Merged objects
# so_merge_dir <- file.path(params$so_dir, "so_merge.qs")
# 
# if (!file.exists(so_merge_dir)) {
#   so_8  <- qread(so_8_dir)
#   so_24 <- qread(so_24_dir)
#   
#   so_merge <- merge(so_8, so_24)
#   
#   rm(so_8, so_24)
#   gc()
#   
#   so_merge <- so_merge %>%
#     ScaleData(block.size = 200)
#   
#   so_merge <- so_merge %>%
#     FindVariableFeatures(nFeatures = 2000) %>%
#     RunPCA() %>%
#     RunUMAP(dims = 1:40)
#   
#   qsave(so_merge, file.path(params$so_dir, "so_merge.qs"))
#  
# } else {
#   so_merge <- qread(so_merge)
# }

so_8  <- qread(so_8_dir)
so_24 <- qread(so_24_dir)

so_merge_df <- bind_rows(so_8@meta.data, so_24@meta.data)

# Load LEC objects
so_lec_8  <- read_rds(file.path(params$orig_so_dir, "2021-07-16/sobjs/so_lec.rds"))
so_lec_24 <- read_rds(file.path(params$orig_so_dir, "2021-01-08/sobjs/so_lec.rds"))

# Set levels
sam_lvls   <- unique(so_24$orig.ident)
treats     <- unique(so_24$treatment)
```

```{r "references"}
# LEC reference
ref_lec <- ref_immgen[, grepl("^Endothelial cells", colnames(ref_immgen))]
ref_lec <- ref_lec[rownames(ref_lec) %in% rownames(ref_LEC_xiang), ]

colnames(ref_lec) <- colnames(ref_lec) %>%
  str_replace("Endothelial cells \\(BEC\\)", "BEC")

ref_LEC_xiang <- ref_LEC_xiang[rownames(ref_lec), ]

if (!identical(rownames(ref_LEC_xiang), rownames(ref_lec))) {
  stop("LEC reference rownames do not match.")
}

ref_lec <- cbind(ref_LEC_xiang, ref_lec)
ref_lec <- ref_lec[, !grepl("^Endothelial cells", colnames(ref_lec))]

# Fibroblast/stromal cell reference
ref_fib <- ref_immgen[, grepl("^Fibroblast", colnames(ref_immgen))]
ref_fib <- ref_fib[rownames(ref_fib) %in% rownames(ref_lymphnodestromal), ]

ref_lymphnodestromal <- ref_lymphnodestromal[rownames(ref_fib), ]

if (!identical(rownames(ref_lymphnodestromal), rownames(ref_fib))) {
  stop("Fibroblast/stromal reference rownames do not match.")
}

ref_fib <- cbind(ref_lymphnodestromal, ref_fib)
```

```{r "theme"}
# ggplot2 themes
txt_pt1  <- 10
txt_pt2  <- 12
ttl_pt1  <- 14
ttl_pt2  <- 16
ln_pt    <- 0.5
ln_col   <- "grey85"
cir_size <- 3.5
sqr_size <- 4

txt_theme_1 <- theme(
  strip.text  = element_text(size = ttl_pt2),
  legend.text = element_text(size = txt_pt2),
  axis.title  = element_text(size = ttl_pt2),
  axis.text   = element_text(size = txt_pt2)
)

line_theme <- theme(
  axis.line.x  = element_line(linewidth = ln_pt, color = ln_col),
  axis.line.y  = element_line(linewidth = ln_pt, color = ln_col),
  axis.ticks.x = element_line(linewidth = ln_pt, color = ln_col),
  axis.ticks.y = element_line(linewidth = ln_pt, color = ln_col)
)

base_theme <- djvdj_theme() +
  theme(
    plot.title       = element_text(face = "plain", size = ttl_pt2),
    strip.background = element_blank(),
    strip.text       = element_text(face = "plain")
  ) +
  txt_theme_1

umap_theme <- base_theme +
  theme(
    panel.border = element_rect(color = NA, fill = NA),
    axis.title   = element_blank(),
    axis.line.x  = element_blank(),
    axis.line.y  = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text    = element_blank()
  )

fade_0 <- "#FAFAFA"
fade_1 <- "#F0F0F0"
fade_2 <- "#D9D9D9"

hist_y_lab <- "number of cells"

# alpha for plots
al <- 0.7

# Okabe Ito color palettes
ito_cols <- c(
  palette_OkabeIto[c(1:3, 5)], "#D7301F",
  palette_OkabeIto[c(4, 6)],   "#6A51A3",
  palette_OkabeIto[7],         "#875C04",
  "#065D43", "#F7AF34", "#00446E"
)

ito_cols <- ito_cols[3:length(ito_cols)] %>%
  darken(0.2) %>%
  c(ito_cols, ., "#686868", "#000000")

# Set sample colors
get_cols <- create_col_fun(ito_cols)

sam_cols <- c(
  # "#F03B20", "#FD8D3C",
  "#BD0026", "#FECC5C", "#FFFFB2",
  # "#0072B2", "#56B4E9",
  "#00446E", "#035B8F", "#2A8FBF"
)

names(sam_cols) <- sam_lvls

# CHIKV treatment groups
chikv_infctd <- so_merge_df %>%
  group_by(treatment) %>%
  summarize(mn = mean(nCount_CHIKV), .groups = "drop") %>%
  filter(mn == max(mn)) %>%
  pull(treatment)

# Cell type colors
type_cols <- unique(so_merge_df$cell_type)
type_cols <- set_names(ito_cols[seq_along(type_cols)], type_cols)

type_cols["unassigned"] <- "#999999"

subtype_cols <- c(colnames(ref_lec), colnames(ref_fib))
subtype_cols <- set_names(ito_cols[seq_along(subtype_cols)], subtype_cols)
subtype_cols["unassigned"] <- "#999999"
subtype_cols["other"]      <- fade_0
subtype_cols["CD34+ SC"]   <- "#534379"

lec_type_cols <- c(subtype_cols, type_cols[names(type_cols) != "unassigned"])
lec_type_cols["CHIKV-low"]      <- "white"
lec_type_cols["T cells"]        <- "black"
lec_type_cols["B cells"]        <- "#875C04"
lec_type_cols["FRC"]            <- "#00375B"
lec_type_cols["PvC"]            <- "#065D43"
lec_type_cols["unassigned-LEC"] <- "#676767"


lec_type_cols <- so_merge_df %>%
  pull(lec_type) %>%
  table() %>%
  sort(decreasing = TRUE) %>%
  names()

lec_type_cols <- lec_type_cols[lec_type_cols != "unassigned"]

lec_type_cols <- set_names(
  ito_cols[seq_along(lec_type_cols)],
  lec_type_cols
)

lec_type_cols["unassigned"] <- "grey70"

old_cols <- lec_type_cols

lec_type_cols["FRC"]   <- old_cols["Valve"]
lec_type_cols["Valve"] <- old_cols["fLEC"]
lec_type_cols["fLEC"]  <- old_cols["FRC"]

# CHIKV clusters colors
grp_cols <- set_names(
  c("#56B4E9", "#0072B2"),
  chikv_grps
)

n_reps <- n_distinct(so_merge_df$rep)

grp_rep_cols <- grp_cols %>% 
  imap(~ set_names(
    rep(.x, n_reps),
    str_c(.y, "-", 1:n_reps)
  )) %>%
  flatten_chr()

# Vectors to modify cell type labels for plotting
new_cell_labs <- c(
  Valve      = "Valve LEC",
  Collecting = "Collecting LEC",
  Ptx3_LEC   = "Ptx3 LEC"
)

marco_expr <- c(Marco_LEC = "\"Marco\"^\"+\"*\" LEC\"")
```

# Lucas et al. figures

## Figure 1

Chikungunya virus is found in MARCO-expressing floor lymphatic endothelial cells
in the draining lymph node at 8 hpi

A.  UMAP projection shows the fraction of counts aligning to the CHIKV genome for the 8 hpi timepoint.
B.  UMAP projection shows CHIKV+ cells (>0 CHIKV counts) for the 8 hpi timepoint.
C.  CHIKV counts are shown for cell types with >50 cells for the 8 hpi CHIKV-infected sample.
D.  The fraction of cells identified as CHIKV+ is shown for each cell type for the 8 hpi timepoint.
E.  MARCO expression is shown for fLECs for mock-infected cells and CHIKV-infected cells classified as either CHIKV low or CHIKV high. P values were calculated using a two-sided Wilcoxon rank-sum test with Bonferroni correction. In the boxplot, the central lines, the box limits, and the whiskers represent medians, the interquartile range (IQR), and min/max values that are not outliers, respectively. Outliers are shown as points and include any values that are more than 1.5Ã— IQR away from the box.
F.  Madcam1 expression is shown for fLECs as described in E.

```{r "fig 1A", fig.width = 10, fig.height = 10}
# Format plot data
dat <- so_8@meta.data %>%
  arrange(tot_pct_CHIKV)

# Create UMAP
pseudo <- dat$tot_pct_CHIKV
pseudo <- min(pseudo[pseudo > 0]) / 2

A <- dat %>%
  ggplot(aes(UMAP_1, UMAP_2, fill = tot_pct_CHIKV + pseudo)) +
  geom_point_trace(
    color = "grey",
    trace_position = "bottom"
  ) +
  scale_fill_gradientn(colours = c("white", "#D7301F"), trans = "log10", labels = scales::label_number()) +
  guides(fill = guide_colorbar(title.position = "top", ticks = FALSE, title = "% CHIKV counts")) +
  umap_theme +
  theme(
    aspect.ratio         = 0.9,
    legend.position      = "top",
    legend.title         = element_text(hjust = 0.5, size = ttl_pt2 * 1.5),
    legend.text          = element_text(angle = 45, hjust = 1), 
    legend.direction     = "horizontal",
    legend.justification = 0.2,
    legend.key.width     = unit(30, "pt"),
    legend.key.height    = unit(5, "pt")
  )
```

```{r "CHIKV-high cell types", fig.width = 10, fig.height = 10}
# Format plot data
dat <- so_8@meta.data %>%
  filter(chikv_grp == chikv_grps[2])

plt_labs <- get_nlab_fun(dat, "lec_type", l = "\n", r = "")
plt_labs <- plt_labs()
plt_labs <- map_chr(plt_labs, type_lab_fn)

dat <- dat %>%
  mutate(lec_type = fct_relevel(lec_type, names(plt_labs)))

# Create UMAP
chikv_typs_u <- so_8@meta.data %>%
  mutate(lec_type = fct_relevel(lec_type, names(plt_labs))) %>%
  ggplot(aes(UMAP_1, UMAP_2)) +
  geom_point_trace(
    color = "grey",
    fill  = "white",
    trace_position = "bottom"
  ) +
  geom_point(aes(color = lec_type), data = dat) +
  scale_color_manual(values = lec_type_cols, labels = plt_labs) +
  scale_y_discrete(labels = type_lab_fn) +
  guides(color = guide_legend(override.aes = list(size = 4))) +
  labs(title = "CHIKV+ cell types") +
  umap_theme +
  theme(
    aspect.ratio         = 0.9,
    plot.title           = element_text(size = ttl_pt2 * 1.5, hjust = 0.2),
    legend.title         = element_blank(),
    legend.key.height    = unit(35, "pt"),
    legend.justification = "bottom",
    legend.text          = element_text(size = ttl_pt1)
  )
```

```{r "8hpi fraction CHIKV-high"}
# Format plot data
# ONLY PLOTTING ENRICHED COUNTS
dat <- so_8@meta.data %>%
  as_tibble(rownames = ".cell_id") %>%
  filter(treatment == "CHIKV") %>%
  group_by(lec_type) %>%
  filter(n() > 50) %>%
  ungroup() %>%
  mutate(
    counts = tot_nCount_CHIKV - nCount_CHIKV
    # counts = tot_nCount_CHIKV
    # enr = tot_nCount_CHIKV + 1
  )

# Fraction CHIKV-high cells
frac_dat <- dat %>%
  group_by(lec_type, rep) %>%
  summarize(
    n = length(chikv_grp[chikv_grp == chikv_grps[2]]),
    tot = n(),
    frac = n / tot,
    .groups = "drop"
  ) %>%
  group_by(lec_type) %>%
  mutate(tot = sum(tot)) %>%
  ungroup() %>%
  mutate(lec_type = fct_reorder(lec_type, frac, max, .desc = TRUE))

frac_lvls <- levels(frac_dat$lec_type)

n_lab <- get_nlab_fun(dat, "lec_type", l = "\n", r = "")

n_lab <- n_lab() %>%
  map_chr(str_replace, "_", " ")

frac_8 <- frac_dat %>%
  ggplot(aes(lec_type, frac, fill = lec_type, color = lec_type, alpha = rep)) +
  geom_col(position = position_dodge2(padding = 0.12), width = 0.8, size = 1) +
  scale_alpha_manual(values = c(0.3, 0.7)) +
  scale_fill_manual(values = lec_type_cols) +
  scale_color_manual(values = lec_type_cols) +
  scale_x_discrete(labels = n_lab) +
  labs(y = "Fraction\nCHIKV+ cells") +
  base_theme +
  theme(
    # aspect.ratio = 0.2
    # plot.margin = margin(25, 5, 5, 15)
    axis.text.y = element_text(size = txt_pt1),
    axis.text.x = element_text(size = ttl_pt2, angle = 45, hjust = 1),
    axis.title.x = element_blank(),
    legend.position = "none",
  )
```

```{r "fig 1B", fig.width = 10, fig.height = 5}
# Create boxplots
count_bxs <- dat %>%
  mutate(lec_type = fct_relevel(lec_type, frac_lvls)) %>%
  ggplot(
    aes(lec_type, counts + 1, fill = lec_type, color = lec_type, alpha = rep)
  ) +
  geom_boxplot(size = 1, outlier.size = 1.5, outlier.alpha = 1, position = position_dodge2(padding = 0.12), width = 0.8) +
  scale_y_log10() +
  scale_x_discrete(labels = plt_labs)+
  scale_fill_manual(values = lec_type_cols) +
  scale_color_manual(values = lec_type_cols) +
  scale_alpha_manual(values = c(0.3, 0.7)) +
  labs(y = "CHIKV\ncounts + 1") +
  base_theme +
  theme(
    # axis.text.x     = element_text(size = ttl_pt2, angle = 90, vjust = 0.5, hjust = 1)
    # aspect.ratio = 0.2,
    plot.margin     = margin(35, 5, 5, 25),
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.title.y    = element_text(size = ttl_pt2),
    axis.text.x     = element_blank(),
    axis.ticks.x    = element_blank()
  )

count_bxs <- plot_grid(
  count_bxs, frac_8,
  labels = c("C", "D"), label_size = ttl_pt2 * 1.5,
  align = "v", axis = "rl",
  ncol = 1,
  rel_heights = c(1, 1)
)
```

```{r "fig1 examples", fig.width = 3, fig.height = 5}
plt_dat <- so_8 %>%
  mutate_meta(
    mutate,
    chikv_grp = recode(
      chikv_grp,
      `CHIKV-low` = "CHIKV-",
      `CHIKV-high` = "CHIKV+"
    )
  )

marco_bxs <- plt_dat %>%
  create_gene_boxplot("Marco", "fLEC", clr = "#D7301F")

madcam_bxs <- plt_dat %>%
  create_gene_boxplot("Madcam1", "fLEC", clr = "#E69F00")


# # CHECK FOR CONTAMINATING fLEC CLUSTERS
# # filter 24hpi Marco_LEC clusters to remove Madcam1+ cells
# # removal of Madcam1+ clusters does not affect overall result
# # i.e. CHIKV-high still shows higher Marco expression than CHIKV-low
# test_dat <- so_lec_24 %>%
#   mutate_meta(
#     mutate,
#     chikv_grp = ifelse(treatment == "mock", treatment, chikv_grp)
#   ) %>%
#   subset(lec_type == "Marco_LEC") %>%
#   FetchData(c(
#     "Madcam1", "Marco",
#     "seurat_clusters", "orig.ident", "treatment", "rep",
#     "chikv_grp"
#   ))
# 
# clsts <- test_dat %>%
#   group_by(seurat_clusters) %>%
#   summarize(sig = mean(Madcam1), n = n()) %>%
#   as.data.frame() %>%
#   arrange(desc(sig)) %>%
#   filter(sig <= 0.4) %>%
#   pull(seurat_clusters)
# 
# plt_dat <- so_lec_24 %>%
#   subset(seurat_clusters %in% clsts)
# 
# plt_dat %>%
#   create_gene_boxplot("Madcam1", "Marco_LEC")
# 
# plt_dat %>%
#   create_gene_boxplot("Marco", "Marco_LEC")
```

```{r "fig 1", fig.width = 15, fig.height = 12}
top <- plot_grid(
  A, chikv_typs_u,
  labels = c("A", "B"), label_size = ttl_pt2 * 1.5,
  nrow   = 1,
  align  = "h",
  axis   = "tb"
)

bot <- plot_grid(
  count_bxs, NULL, marco_bxs, NULL, madcam_bxs,
  labels = c("", "", "E", "", "F"), label_size = ttl_pt2 * 1.5,
  nrow   = 1,
  rel_widths = c(1, 0.05, 0.36, 0.05, 0.36)
)

plot_grid(
  top, NULL, bot,
  ncol = 1,
  rel_heights = c(1, 0.05, 0.7)
)

# l <- plot_grid(
#   A, C,
#   labels = c("A", "C"), label_size = ttl_pt2 * 1.5,
#   ncol   = 1,
#   align  = "v",
#   axis   = "rl"
# )
# 
# r <- plot_grid(
#   B, D,
#   labels = c("B", "D"), label_size = ttl_pt2 * 1.5,
#   ncol   = 1,
#   align  = "v",
#   axis   = "rl"
# )
# 
# plot_grid(l, r, nrow = 1, rel_widths = c(1, 0.5))
```

<br>

## Figure S1

CHIKV may target MARCO-expressing LECs for infection

```{r "UMAPs", fig.width = 10, fig.height = 10}
# Pseudo count for pct_mito
pseudo <- so_24$pct_mito
pseudo <- min(pseudo[pseudo > 0]) / 2

# Format data
dat <- so_24@meta.data %>%
  as_tibble(rownames = "cell_id") %>%
  mutate(pct_mito = pct_mito + pseudo) %>%
  arrange(CHIKV_sgRNA_fc)

chikv_dat <- dat %>%
  filter(chikv_grp == chikv_grps[2])

# Cell type UMAP
type_umap <- dat %>%
  plot_scatter(
    "lec_type",
    plot_colors  = lec_type_cols,
    plot_lvls    = NULL,
    size         = 0.2,
    label_params = list(size = txt_pt2)
  ) +
  umap_theme +
  theme(
    aspect.ratio = 0.9,
    legend.title = element_blank(), legend.key.height = unit(30, "pt")
  )
  
# sgRNA ratio UMAP
sgRNA_umap <- dat %>%
  ggplot(aes(UMAP_1, UMAP_2, fill = CHIKV_sgRNA_fc)) +
  geom_point_trace(
    color = "grey",
    trace_position = "bottom",
    size = 0.5
  ) +
  scale_fill_gradientn(colours = c("white", "#0072B2", "#002037"), labels = scales::label_number()) +
  guides(fill = guide_colorbar(title.position = "top", ticks = FALSE, title = "CHIKV sgRNA ratio")) +
  umap_theme +
  theme(
    aspect.ratio         = 0.9,
    legend.position      = "top",
    legend.title         = element_text(hjust = 0.5, size = ttl_pt2),
    legend.direction     = "horizontal",
    legend.justification = 0.5,
    legend.key.width     = unit(30, "pt"),
    legend.key.height    = unit(5, "pt")
  )
```

```{r "scatter plots", fig.width = 10, fig.height = 7}
# ONLY PLOT CHIKV-HIGH CELLS
# Shouldn't include any CHIKV-low cells, since they have been filtered
# stringently based on QC and CHIKV-high cells have not. This would influence
# correlations

# Stats to plot
y_vars <- c(
  "# mouse genes\nexpressed" = "nFeature_RNA",
  "% mitochondrial\nreads" = "pct_mito"
)

x_var <- "CHIKV_sgRNA_fc"
typs  <- c("Marco_LEC", "BEC", "PvC", "unassigned-LEC")

# Scatter plots
plt_dat <- chikv_dat %>%
  filter(lec_type %in% typs) %>%
  mutate(lec_type = fct_relevel(lec_type, typs)) %>%
  dplyr::rename(!!!syms(y_vars)) %>%
  pivot_longer(all_of(names(y_vars))) %>%
  group_by(lec_type, name) %>%
  mutate(
    cor = cor(log10(!!sym(x_var)), log10(value)),
    cor = str_c("r = ", round(cor, 2))
  ) %>%
  ungroup()

scatter <- plt_dat %>%
  split(.$lec_type) %>%
  unname() %>%
  imap(~ {
    clmn <- .y
    
    .x <- .x %>%
      split(.$name)
    
    top <- names(.x)[1]
    
    .x %>%
      imap(~ {
        if (clmn == 1) y_ttl <- .y
        else           y_ttl <- NULL
        
        ttl <- NULL
        sub <- NULL
        x_ttl <- NULL
        
        if (.y == top) {
          ttl   <- type_lab_fn(unique(.x$lec_type))
          sub   <- str_c("n = ", nrow(.x))
        }
        
        .x %>%
          ggplot(aes(!!sym(x_var), value, color = lec_type)) +
          geom_point() +
          geom_smooth(
            method = "lm", formula = y ~ x,
            color = "black", linewidth = 0.5, linetype = 2, alpha = 0.2) +
          geom_text(
            aes(Inf, Inf, label = cor),
            hjust = 1.2, vjust = 1.2,
            color = "black",
            check_overlap = TRUE
          ) +
          scale_color_manual(values = lec_type_cols) +
          scale_x_log10() +
          scale_y_log10(expand = expansion(c(0.05, 0.10))) +
          labs(title = ttl, subtitle = sub, x = x_ttl, y = y_ttl) +
          theme(aspect.ratio = 0.9) +
          base_theme +
          theme(
            legend.position = "none",
            axis.text.x = element_text(size = txt_pt1),
            axis.text.y = element_text(size = txt_pt1)
          )
      })
  }) %>%
  flatten()

# x-axis title
x_ttl <- scatter[[1]] +
  labs(title = "CHIKV sgRNA ratio") +
  theme(
    plot.title = element_text(hjust = 0.5, vjust = 1, size = ttl_pt2)
  )

x_ttl <- get_title(x_ttl)

# Create final figure
scatter <- scatter %>%
  wrap_plots(byrow = FALSE, nrow = 2)

scatter <- list(scatter, x_ttl) %>%
  wrap_plots(ncol = 1, heights = c(1, 0.1))
```

```{r "sgRNA signal"}
# Format plot data
# only include cell types with >10 cells
plt_dat <- dat %>%
  filter(treatment == treats[2])

typs <- plt_dat %>%
  filter(chikv_grp == chikv_grps[2]) %>%
  pull(lec_type) %>%
  table() %>%
  sort(decreasing = TRUE)

typs <- names(typs[typs > 10])

# Fraction CHIKV-high cells
frac_dat <- plt_dat %>%
  group_by(lec_type, rep) %>%
  summarize(
    n = length(chikv_grp[chikv_grp == chikv_grps[2]]),
    tot = n(),
    frac = n / tot,
    .groups = "drop"
  ) %>%
  group_by(lec_type) %>%
  mutate(tot = sum(tot)) %>%
  ungroup() %>%
  mutate(lec_type = fct_reorder(lec_type, frac, max, .desc = TRUE))

n_lab <- get_nlab_fun(plt_dat, "lec_type", l = "\n", r = "")

n_lab <- n_lab() %>%
  map_chr(str_replace, "_", " ")

frac_24 <- frac_dat %>%
  ggplot(aes(lec_type, frac, fill = lec_type, color = lec_type, alpha = rep)) +
  geom_col(position = "dodge") +
  scale_alpha_manual(values = c(0.1, 0.3, 0.6)) +
  scale_fill_manual(values = lec_type_cols) +
  scale_color_manual(values = lec_type_cols) +
  scale_x_discrete(labels = n_lab) +
  labs(y = "Fraction\nCHIKV-high cells") +
  base_theme +
  theme(
    axis.text.y = element_text(size = txt_pt1),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_blank(),
    legend.position = "none",
    aspect.ratio = 0.2,
    plot.margin = margin(25, 5, 5, 15)
  )

# sgRNA ratio
# Filter to include cells with >0 sgRNA counts and >0 5' counts
sgRNA_boxes <- plt_dat %>%
  filter(
    lec_type %in% typs,
    CHIKV_sgRNA > 0,
    CHIKV_5 > 0
  ) %>%
  plot_violin(
    "CHIKV_sgRNA_fc",
    cluster_col = "lec_type",
    plot_colors = lec_type_cols,
    plot_lvls   = NULL,
    trans       = "log10",
    scale       = "width",
    draw_quantiles = c(0.25, 0.75)
  ) +
  labs(y = "CHIKV sgRNA\nratio") +
  base_theme +
  theme(
    aspect.ratio    = 0.25,
    plot.margin     = margin(25, 5, 5, 15),
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.text.x     = element_text(angle = 45, hjust = 1),
    axis.text.y     = element_text(size = txt_pt1),
  )
```

```{r "type examples", fig.width = 10, fig.height = 6.5}
# Genes to plot
gns <- c(
  "Lyve1", "Marco",    # Marco LECs
  "Madcam1", "Vcam1",  # fLECs
  "Ptx3",              # Ptx3 LECs
  "Ackr4"              # cLECs
)

all_gns <- c(gns, c("Mxra8", "Ccl21a", "Il7", "Cxcl13", "Cxcl9"))

tms <- c("8hpi", "24hpi")

# Format data
typ_bx_dat <- list("8hpi" = so_8, "24hpi" = so_24) %>%
  imap_dfr(~ {
    if (identical(.y, "8hpi")) {
      .x <- .x %>%
        mutate_meta(mutate, fib_type = fib_subtype)
    }
    
    clmns <- c(
      "cell_type", "lec_type", "fib_type",
      "treatment", "orig.ident", "rep", "chikv_grp", all_gns
    )
    
    .x %>%
      FetchData(clmns) %>%
      as_tibble(rownames = "cell_id") %>%
      mutate(
        tm = .y,
        tm = fct_relevel(tm, tms),
        tm_treat = str_c(tm, "-", treatment),
        tm_treat = fct_relevel(tm_treat, unlist(map(tms, str_c, "-", treats)))
      )
  })

# Create boxplots
type_boxes <- gns %>%
  map(~ {
    lvls <- typ_bx_dat %>%
      group_by(lec_type) %>%
      summarize(
        stats = list(boxplot.stats(!!sym(.x))),
        med   = map_dbl(stats, ~ .x$stats[3]),
        q3    = map_dbl(stats, ~ .x$stats[4]),
        q4    = map_dbl(stats, ~ .x$stats[5]),
        mx    = max(!!sym(.x))
      ) %>%
      arrange(med, q3, q4, mx) %>%
      pull(lec_type) %>%
      rev()
      
    typ_bx_dat %>%
      mutate(lec_type = fct_relevel(lec_type, lvls)) %>%
      ggplot(aes(lec_type, !!sym(.x), color = lec_type, fill = lec_type)) +
      geom_boxplot(
        size = 0.5, alpha = 0.5,
        outlier.size = 0.1, outlier.alpha = 1,
        position = position_dodge2(preserve = "single")
      ) +
      scale_color_manual(values = lec_type_cols) +
      scale_fill_manual(values = lec_type_cols) +
      scale_x_discrete(labels = type_lab_fn) +
      facet_wrap(~ tm, ncol = 1) +
      labs(y = str_c(.x, " expression")) +
      base_theme +
      theme(
        aspect.ratio    = 0.16,
        legend.position = "none",
        axis.title.x    = element_blank(),
        axis.text.x     = element_text(angle = 45, hjust = 1),
        axis.text.y     = element_text(size = txt_pt1)
      )
  }) %>%
  plot_grid(
    plotlist = .,
    align = "vh",
    axis  = "trbl",
    nrow  = 2
  )
```

### CHIKV signal

A.  UMAP projection shows annotated cell types for the 24 hpi timepoint.
B.  UMAP projection shows CHIKV sgRNA ratio (sgRNA counts / 5' counts) for the 24 hpi timepoint.
C.  The fraction of cells identified as CHIKV-high is shown for each cell type for the 24 hpi timepoint.
D.  CHIKV sgRNA ratio is shown for cells with >0 sgRNA counts and >0 5' counts. Cell types with >10 cells are shown.
E.  The correlation between CHIKV sgRNA ratio and QC metrics is shown for CHIKV-high cells.

```{r "fig S1 v2", fig.width = 16, fig.height = 14}
top <- plot_grid(
  type_umap, sgRNA_umap,
  labels = c("A", "B"), label_size = ttl_pt2 * 1.5,
  align = "vh", axis = "trbl",
  nrow = 1
)

left <- plot_grid(
  frac_24, sgRNA_boxes,
  labels = c("C", "D"), label_size = ttl_pt2 * 1.5,
  align = "v", axis = "rl",
  ncol = 1
)

right <- plot_grid(
  NULL, scatter, NULL,
  rel_heights = c(0.15, 1, 0.15),
  ncol = 1
)

bot <- plot_grid(
  left, right,
  labels = c("", "E"), label_size = ttl_pt2 * 1.5,
  rel_widths = c(0.75, 1),
  nrow = 1
)

plot_grid(
  top, bot,
  rel_heights = c(1, 0.75),
  ncol = 1
)
```

<br>

### Cell type annotation

A.  The correlation between annotated LEC subsets and reference data is shown for the 8 hpi and 24 hpi timepoint.
B.  The expression of select marker genes is shown for the 8 hpi and 24 hpi timepoints.

```{r "cell type heatmaps", fig.width = 8, fig.height = 5}
# Format heatmap data
h_dat <- list("8hpi" = so_lec_8, "24hpi" = so_lec_24) %>%
  imap(~ {
    obj <- .x
    set_names(treats, str_c(.y, "-", treats)) %>%
      map(~ subset(obj, treatment == .x))
  }) %>%
  flatten() %>%
  map(~ {
    .x %>%
      mutate_meta(
        mutate,
        lec_type = recode(lec_type, unassigned = "unassigned-LEC")
      )
  })

rm(so_lec_8, so_lec_24)

h_mat <- h_dat %>%
  map(~ {
    .x %>%
      clustify(
        ref_mat        = ref_lec,
        cluster_col    = "lec_type",
        seurat_out     = FALSE,
        compute_method = "spearman",
        n_genes        = 2000
      ) %>%
      as_tibble(rownames = "assigned_type") %>%
      pivot_longer(
        cols      = -assigned_type,
        names_to  = "ref_type",
        values_to = "r"
      )
  })

# Format LEC types labels
lec_labs <- h_dat %>%
  map(~ {
    typs <- .x@meta.data %>%
      group_by(lec_type) %>%
      dplyr::filter(n() > 10) %>%
      pull(lec_type) %>%
      unique()
    
    .x %>%
      subset(lec_type %in% typs)
  }) %>%
  map(get_nlab_fun, "lec_type", l = "\n", r = "")
  
# Create heatmaps
heat_args <- list(
  df_in    = h_mat,
  ttl      = names(h_mat),
  lec_labs = lec_labs
)

type_heats <- heat_args %>%
  pmap(create_cor_heatmap, ln_clr = fade_0) %>%
  plot_grid(plotlist = .)
```

```{r "type examples extended", fig.width = 10, fig.height = 6.5}
# Create boxplots
type_boxes <- gns %>%
  map(~ {
    lvls <- typ_bx_dat %>%
      group_by(lec_type) %>%
      summarize(
        stats = list(boxplot.stats(!!sym(.x))),
        med   = map_dbl(stats, ~ .x$stats[3]),
        q3    = map_dbl(stats, ~ .x$stats[4]),
        q4    = map_dbl(stats, ~ .x$stats[5]),
        mx    = max(!!sym(.x))
      ) %>%
      arrange(med, q3, q4, mx) %>%
      pull(lec_type) %>%
      rev()
      
    typ_bx_dat %>%
      mutate(
        lec_type = fct_relevel(lec_type, lvls),
        chikv_grp = fct_relevel(chikv_grp, chikv_grps)
      ) %>%
      ggplot(aes(lec_type, !!sym(.x), color = lec_type, fill = lec_type, alpha = chikv_grp)) +
      geom_boxplot(
        size = 0.25, color = "black",
        outlier.size = 0.01, outlier.alpha = 0.1,
        position = position_dodge2(preserve = "single"),
        key_glyph = draw_key_point,
      ) +
      scale_color_manual(values = lec_type_cols) +
      scale_fill_manual(values = lec_type_cols) +
      scale_alpha_manual(values = c(`CHIKV-low` = 0.5, `CHIKV-high` = 1)) +
      scale_x_discrete(labels = type_lab_fn) +
      facet_wrap(~ tm_treat, ncol = 1) +
      labs(y = str_c(.x, " expression")) +
      guides(
        fill = "none", color = "none",
        alpha = guide_legend(
          override.aes = list(shape = 15, fill = "black", size = 4)
        )
      ) +
      base_theme +
      theme(
        aspect.ratio    = 0.15,
        legend.position = "top",
        legend.title    = element_blank(),
        legend.text     = element_text(size = txt_pt1),
        axis.title.x    = element_blank(),
        axis.text.x     = element_text(size = txt_pt2, angle = 90, hjust = 1, vjust = 0.5),
        axis.text.y     = element_text(size = txt_pt1 * 0.75),
        strip.text      = element_text(size = txt_pt2)
      )
  }) %>%
  plot_grid(
    plotlist = .,
    align = "vh",
    axis  = "trbl",
    nrow  = 2
  )
```

```{r "fig S1 v2 cell type", fig.width = 12, fig.height = 18}
plot_grid(
  type_heats, NULL, type_boxes,
  rel_heights = c(0.7, 0.04, 1),
  label_size  = ttl_pt2 * 1.5,
  labels      = c("A", "B"),
  ncol        = 1
)
```



```{r "INTEGRATION", eval = FALSE}
# Clustering resolutions
rslns <- c(1, 3, 5)

# Merge timepoints
so_merge <- merge(so_lec_8, so_lec_24) %>%
  run_m3drop(threshold = 0.001) %>%
  ScaleData(assay = "RNA") %>%
  cluster_RNA(
    resolution = rslns,
    dims       = 1:40
  ) %>%
  mutate_meta(
    mutate,
    tm = replace_na(tm, "24hpi"),
    sample = ifelse(is.na(sample), str_c(treatment, tm, rep, sep = "-"), sample)
  )

# Variables to regress out
vars_to_regress <- c("pct_mito", "nCount_RNA")

# Cluster each treatment separately
so_treats <- set_names(treats) %>%
  map(~ subset(so_merge, treatment == .x))

rm(so_merge)  

so_treats <- so_treats %>%
  map(~ {
    .x %>%
      subset_sobj(
        dims         = 1:40,
        rsln         = rslns,
        var_p        = 0.001,
        regress_vars = vars_to_regress
      )
  })

# Integration features
features <- SelectIntegrationFeatures(object.list = so_treats)

# Scale data using integration features
so_int <- so_treats %>%
  map(~ {
    .x %>%
      ScaleData(features = features) %>%
      RunPCA(features = features)
  })

rm(so_treats)

# Get integration anchors and integrate
int_anchors <- so_int %>%
  FindIntegrationAnchors(
    anchor.features = features,
    reduction = "rpca"
  )

so_int <- IntegrateData(
  anchorset = int_anchors,
  normalization.method = "LogNormalize"
)

rm(int_anchors)

# Scale and cluster integrated data
DefaultAssay(so_int) <- "integrated"

so_int <- so_int %>%
  ScaleData(vars.to.regress = vars_to_regress) %>%
  RunPCA() %>%
  RunUMAP(dims = 1:40, reduction.key = "intUMAP_") %>%
  FindNeighbors(dims = 1:40) %>%
  FindClusters(resolution = rslns)

so_int <- so_int %>%
  AddMetaData(FetchData(., str_c("intUMAP_", 1:2)))

DefaultAssay(so_int) <- "RNA"

so_int %>%
  qsave(here(params$so_dir, "so_int.qs"))
```

```{r "HARMONY INTEGRATION", eval = FALSE}

library(harmony)

# so_merge <- merge(so_8, so_24)
# 
# rm(so_8, so_24)
# 
# so_merge <- so_merge %>%
#   FindVariableFeatures() %>%
#   ScaleData() %>%
#   RunPCA() %>%
#   RunHarmony("treatment") %>%
#   RunUMAP(reduction = "harmony")

so_merge <- merge(so_lec_8, so_lec_24) %>%
  FindVariableFeatures() %>%
  ScaleData() %>%
  RunPCA() %>%
  RunHarmony("treatment")

so_merge <- so_merge %>%
  RunUMAP(reduction = "harmony", dims = 1:40)

```

```{r "cell type markers", fig.height = 21, fig.width = 20, eval = FALSE}
feats <- c(
  "Ptprc",           # hematopoietic cells
  "Pdpn", "Pecam1",  # LECs (+/+), BECs (-/+), FRCs (+/-)
  "Pdgfra",          # Fibroblasts
  "Acta2", "Itga7",  # PvCs
  "Cd14", "Fcgr3",   # macrophages/monocytes
  "Fcgr1",           # macrophages
  "Nkg7",            # NK cells
  "Cd3e",            # T cells
  "Cd19"             # B cells
)

feats %>%
  map(~ {
    so_8 %>%
      plot_example_gene(
        .x, "lec_type",
        box_colors  = lec_type_cols,
        umap_colors = c("white", "#D7301F")
      )
  }) %>%
  plot_grid(plotlist = ., ncol = 4)
```

```{r "lec type markers", fig.height = 28, fig.width = 20, eval = FALSE}
feats <- c(
  "Marco", "Lyve1", "Tspan7",        # Marco LECs
  "Madcam1", "Vcam1", "Clu", "Ltb",  # fLECs
  "Ptx3", "Stab2",                   # Ptx3 LECs
  "Cldn11", "Esam",                  # Valve LECs
  "Ackr4", "Foxc2",                  # cLECs
  "Ccl21a"                           # Collecting LECs
)

feats %>%
  map(~ {
    so_8 %>%
      plot_example_gene(
        .x, "lec_type",
        box_colors  = lec_type_cols,
        umap_colors = c("white", "#D7301F")
      )
  }) %>%
  plot_grid(plotlist = ., ncol = 4)
```

<br>

## Figure 5

Differentially expressed genes were identified for each cell type for mock vs 8 hpi and 8 hpi vs 24 hpi. Genes were considered upregulated if the log2 fold change was >0.15 for 8 hpi and >0.25 for 24 hpi for all replicates and the largest p-value for all replicates was <0.05.

Gene ontology terms (biological process) were then identified for upregulated genes for each cell type. Terms were filtered to only include those with an adjusted p-value <0.05 and at least 3 or 10 upregulated genes overlapping the term for the 8 hpi and 24 hpi timepoints, respectively. Terms identified for each cell type were combined and clustered into three modules based on the pairwise overlap between terms.

A.  UMAP projection shows cells from the 8 hpi and 24 hpi timepoints, cells are colored by sample.
B.  UMAP projection shows cells from the 8 hpi and 24 hpi timepoints, cells are colored by cell type.
C.  The 8 hpi timeopoint shows upregulation of genes associated with an innate immune response. Enrichment scores are shown for each cell type for the primary gene ontology module identified for genes upregulated at the 8 hpi timepoint. Enrichment score is the fraction of upregulated genes overlapping the term divided by the fraction of background genes overlapping the term. GO terms that are significantly enriched are marked by the diamond.
D.  A selection of top upregulated genes identified for the terms shown in A are plotted. Points show the median expression for the mock (m), 8 hpi (8h), and 24 hpi (24h) samples, grey bars show the interquartile range. A solid line indicates that the gene is significantly upregulated between the samples.
E.  Enrichment scores are shown for the primary GO modules identified for the 24 hpi timepoint, as described in C.
F.  Top upregulated genes identified for the terms shown in E are plotted as described in D.

```{r "DEGs"}
# Create object to compare CHIKV 24 hpi with 8 hpi
top_reps <- as.character(so_24$rep) %>%
  table() %>%
  sort() %>%
  tail(2) %>%
  names() %>%
  sort()

new_reps <- set_names(
  seq_along(top_reps), top_reps
)

so_merge <- so_24 %>%
  subset(treatment == "CHIKV") %>%
  subset(rep %in% names(new_reps)) %>%
  mutate_meta(~ {
    .x %>%
      mutate(
        rep = recode(rep, !!!new_reps),
        treatment = "24hpi"
      )
  })

so_merge <- so_8 %>%
  subset(treatment == "CHIKV") %>%
  mutate_meta(mutate, treatment = "8hpi") %>%
  merge(so_merge)

# Create objects to compare CHIKV-low/-high cells
so_8_chikv <- so_8 %>%
  subset(treatment == "CHIKV")

so_24_chikv <- so_24 %>%
  subset(treatment == "CHIKV")

# Identify up/down regulated genes
deg_args <- list(
  so_in      = c("so_8", "so_8", "so_24", "so_24", "so_merge", "so_merge", "so_8_chikv", "so_24_chikv"),
  treat_clmn = c(rep("treatment", 6), rep("chikv_grp", 2)),
  ident_1    = c(rep("CHIKV", 4), rep("24hpi", 2), rep("CHIKV-high", 2)),
  ident_2    = c(rep("mock", 4),  rep("8hpi", 2),  rep("CHIKV-low", 2)),
  log_fc     = list(
    c(0.15, Inf), c(-Inf, -0.15),  # 8 hpi up and down
    c(0.25, Inf), c(-Inf, -0.25),  # 24 hpi up and down
    c(0.25, Inf), c(-Inf, -0.25),  # merged up and down
    c(0.15, Inf), c(0.15, Inf)     # CHIKV-high up
  )
)

degs <- deg_args %>%
  pmap(~ {
    args <- list(...)

    if      (all(args$log_fc > 0)) typ <- "-up"
    else if (all(args$log_fc < 0)) typ <- "-down"
    else                           typ <- ""
    
    prfx <- str_remove(args$so_in, "^so_")
    file <- str_c(prfx, "_subtype_chikv", typ, "_markers.tsv")
    file <- here("results/tables", file)
    
    d <- eval(sym(args$so_in)) %>%
      get_degs(
        log_fc  = args$log_fc,
        file    = file,
        ident_1 = args$ident_1,
        ident_2 = args$ident_2,
        treat_clmn = args$treat_clmn
      ) %>%
      list()
    
    names(d) <- str_c(args$so_in, typ)
    
    d
  }) %>%
  flatten()

rm(so_8_chikv, so_24_chikv)
```

```{r "GO"}
# Prepare GO data to measure similarity
go_sim_data <- godata(
  OrgDb   = org.Mm.eg.db,
  keytype = "SYMBOL",
  ont     = "BP"
)

# Get GO terms
# only use top 200 DEGs
# go_degs <- degs[grepl("^so_(8|merge)-up$|_chikv-up$", names(degs))] %>%
go_degs <- degs[grepl("^so_(8|merge)-up$", names(degs))] %>%
  map(~ {
    .x %>%
      arrange(max_pval) %>%
      split(.$subtype) %>%
      map(pull, gene) %>%
      map(head, 200)
  })

go <- go_degs %>%
  imap(~ {
    typ   <- str_remove(.y, ".+(?=-)")
    so_in <- str_remove(.y, "-.+$")
    prfx  <- str_remove(so_in, "^so_")
    file  <- str_c(prfx, "_subtype_chikv", typ, "_go")
    file  <- here("results/tables", file)
    
    .x %>%
      get_go(
        so_in = eval(sym(so_in)),
        file  = file
      )
  })
```

```{r "GO clusters"}
# Only use terms with >= 3 overlapping genes for 8 hpi and 10 for 24 hpi
so_8_re <- "^(so_8-|so_[0-9]+_chikv)"

clusters <- go %>%
  imap(~ {
    ovlp <- ifelse(grepl(so_8_re, .y), 3, 10)
    
    get_clusters(.x, k = 3, n_overlap = ovlp, n_shared = 1)
  }) %>%
  discard(is.null)

# Calculate similarity between 8hpi and 24hpi terms
clusters_merged <- clusters$`so_merge-up`$clusters %>%
  mutate(cluster = str_c("24hpi-", cluster))

clusters_merged <- clusters$`so_8-up`$clusters %>%
  mutate(cluster = str_c("8hpi-", cluster)) %>%
  bind_rows(clusters_merged)

cluster_lvls <- unique(clusters_merged$cluster)

clusters_merged <- clusters_merged %>%
  split(.$cluster) %>%
  map(pull, ID)

comps <- names(clusters_merged) %>%
  expand.grid(names(clusters_merged)) %>%
  as.list()

cluster_sim <- map2_dfr(comps$Var1, comps$Var2, ~ {
  sim <- mgoSim(
    GO1 = clusters_merged[[.x]],
    GO2 = clusters_merged[[.y]],
    semData = go_sim_data
  )
  
  tibble(var1 = .x, var2 = .y, sim = sim)
})

# Create heatmap
sim_heatmap <- cluster_sim %>%
  mutate(
    var1 = fct_relevel(var1, cluster_lvls),
    var2 = fct_relevel(var2, rev(cluster_lvls))
  ) %>%
  ggplot(aes(var1, var2, fill = sim)) +
  geom_tile() +
  scale_fill_gradientn(colours = c("lightblue", "white", "red")) +
  djvdj_theme() +
  theme(
    aspect.ratio = 1,
    axis.title = element_blank()
  )
```

```{r "GO heatmaps"}
# # Cluster titles
# clst_matches <- cluster_sim %>%
#   filter(var1 != var2) %>%
#   group_by(var1) %>%
#   filter(
#     sim > 0.6,
#     sim == max(sim[sim < 1])
#   ) %>%
#   rowwise() %>%
#   mutate(matches = list(sort(as.character(c(var1, var2))))) %>%
#   pull(matches) %>%
#   unique()

ttls <- as_labeller(c(`1` = "Innate Immune Response", `2` = "Inflammatory Response"))

# Cluster colors
clrs_8  <- c(`1` = "#E69F00", `2` = "#56B4E9")
clrs_24 <- c(`1` = "#D7301F", `2` = "#6A51A3")

# Create heatmaps
# pval, qval, n_overlap cutoffs should match those used for clustering
go_heat <- clusters %>%
  imap(~ {
    go_in  <- go[[.y]]
    ovlp   <- ifelse(grepl(so_8_re, .y), 3, 10)
    n_clst <- ifelse(grepl(so_8_re, .y), 1, 2)
    n_gns  <- ifelse(grepl(so_8_re, .y), 10, 20)
    
    if (grepl("^so_8-", .y)) clrs <- clrs_8
    else                     clrs <- clrs_24
    
    .x$clusters %>%
      create_go_heatmap(
        go_in      = go_in,
        n_overlap  = ovlp,
        n_genes    = n_gns,
        n_clusters = n_clst,
        clrs       = clrs,
        cluster_labels = ttls
      )
  })

# # Calculate frequency of words for each GO cluster
# clusters %>%
#   map_dfr(~ {
#     .x$clusters %>%
#       split(.$cluster) %>%
#       map_dfr(~ {
#         .x %>%
#           filter(cluster == 1) %>%
#           pull(ID) %>%
#           simplifyEnrichment::keyword_enrichment_from_GO()
#       })
#   })
```

```{r "8hpi examples"}
# Example genes to plot
obj <- "so_8-up"

gns <- go[[obj]]@compareClusterResult %>%
  as_tibble() %>%
  right_join(go_heat[[obj]]$terms, by = "Description") %>%
  mutate(geneID = str_split(geneID, "/")) %>%
  unnest(geneID) %>%
  group_by(geneID, cluster) %>%
  summarize(n = n_distinct(Cluster), .groups = "drop") %>%
  distinct(geneID, .keep_all = TRUE) %>%
  arrange(cluster, desc(n))

top_sig <- degs[[obj]] %>%
  filter(gene %in% gns$geneID) %>%
  group_by(gene) %>%
  summarize(pval = min(max_pval), .groups = "drop")

gns <- gns %>%
  left_join(top_sig, by = c(geneID = "gene")) %>%
  arrange(desc(n), pval) %>%
  group_by(cluster) %>%
  dplyr::slice(1:3)

gns <- set_names(as.character(gns$cluster), gns$geneID)

# Create plots
examples_8 <- create_gene_plots(
  exp_data   = list("8hpi" = so_8, "24hpi" = so_merge),
  deg_data   = list("8hpi" = degs$`so_8-up`, "24hpi" = degs$`so_merge-up`),
  gns        = gns,
  cell_types = 8,
  clrs       = clrs_8
)
```

```{r "24hpi examples"}
# Example genes to plot
obj <- "so_merge-up"

gns <- go[[obj]]@compareClusterResult %>%
  as_tibble() %>%
  right_join(go_heat[[obj]]$terms, by = "Description") %>%
  mutate(geneID = str_split(geneID, "/")) %>%
  unnest(geneID) %>%
  group_by(geneID, cluster) %>%
  summarize(n = n_distinct(Cluster), .groups = "drop") %>%
  distinct(geneID, .keep_all = TRUE) %>%
  arrange(cluster, desc(n))

top_sig <- degs[[obj]] %>%
  filter(gene %in% gns$geneID) %>%
  group_by(gene) %>%
  summarize(pval = min(max_pval), .groups = "drop")

gns <- gns %>%
  left_join(top_sig, by = c(geneID = "gene")) %>%
  arrange(cluster, desc(n), pval) %>%
  filter(geneID %in% c("Cxcl9", "Cxcl10", "Isg15", "Ccl7", "Gbp2", "Gbp6"))

# gns %>%
#   filter(grepl("C[xc][clr]|I[fs][irg]", geneID))

gns <- set_names(as.character(gns$cluster), gns$geneID)

# Create plots
examples_24 <- create_gene_plots(
  exp_data   = list("8hpi" = so_8, "24hpi" = so_merge),
  deg_data   = list("8hpi" = degs$`so_8-up`, "24hpi" = degs$`so_merge-up`),
  gns        = gns,
  cell_types = 8,
  clrs       = clrs_24
)
```

```{r "GO figures", fig.width = 11.8, fig.height = 9}

# # Create final figure
# left <- plot_grid(
#   go_heat$`so_8-up`$heatmap,
#   go_heat$`so_merge-up`$heatmap,
#   labels = c("C", "E"),
#   label_size = ttl_pt2 * 1.5,
#   ncol   = 1,
#   align  = "v",
#   axis   = "r"
# )
# 
# right <- plot_grid(
#   examples_8, examples_24,
#   labels = c("D", "F"),
#   label_size = ttl_pt2 * 1.5,
#   ncol   = 1,
#   align  = "v",
#   axis   = "l"
# )
# 
# plot_grid(
#   left, right,
#   nrow = 1
# )

top <- plot_grid(
  go_heat$`so_8-up`$heatmap, examples_8,
  labels = c("C", "D"),
  label_size = ttl_pt2 * 1.5,
  hjust  = 0.01,
  vjust  = 0.98,
  nrow   = 1,
  align  = "h",
  axis   = "tb"
)

bot <- plot_grid(
  go_heat$`so_merge-up`$heatmap, examples_24,
  labels = c("E", "F"),
  label_size = ttl_pt2 * 1.5,
  hjust  = 0.01,
  nrow   = 1,
  align  = "h",
  axis   = "tb"
)

plot_grid(top, bot, ncol = 1, rel_heights = c(0.64, 1))

```

<br>

### Extended GO analysis {.tabset .tabset-pills}

A.  Dendrogram showing gene ontology modules. GO terms were identified for each cell type and filtered as described for Fig 5. Terms were clustered into 5 modules based on the pairwise overlap between terms.
B.  Enrichment scores are shown for each GO module identified for each timepoint, as described in Fig 5.
C.  Top upregulated genes are shown for each GO module as described in Fig 5.

```{r "EXPANDED FIGURES", fig.width = 12, fig.height = 19, results = "asis"}
# Split GO objects by cell type
go_type <- go %>%
  imap(~ {
    obj  <- .x
    typs <- unique(obj@compareClusterResult$Cluster)
    base <- str_remove(.y, "(?<=-).+")
    nms  <- str_c(base, c("all", as.character(typs)))
    
    l <- map(typs, ~ filter(obj, Cluster == .x))
    l <- append(list(obj), l)
    
    names(l) <- nms
    
    l
  }) %>%
  flatten()

# Create expanded GO figures
create_go_summary_figures <- function(go_in, sample_name, n_clsts = 5,
                                      n_terms = 6, n_genes = 4) {
  
  # Cluster GO terms
  ovlp    <- ifelse(grepl(so_8_re, sample_name), 3, 10)
  shrd    <- ifelse(grepl("-all$", sample_name), 2, 1)
  typ_plt <- !grepl("-all$", sample_name)
  
  clsts <- go_in %>%
    get_clusters(
      k         = n_clsts,
      n_overlap = ovlp,
      n_shared  = 1
    )
  
  if (is.null(clsts)) return(NULL)
  
  obj    <- str_remove(sample_name, "-.+$")
  obj    <- str_c(obj, "-up")
  go_typ <- go[[obj]]  # use objects containing all cell types for plotting
  
  # Create tree
  clst_ids <- as.character(unique(sort(clsts$clusters$cluster)))
  
  clst_clrs <- set_names(
    unname(type_cols)[1:n_distinct(clst_ids)],
    clst_ids
  )
  
  cl <- split(
    names(clsts$clusters_object),
    clsts$clusters_object
  )
  
  tr <- ggtree(clsts$object, linewidth = 1)
  
  clades <- cl %>%
    map_int(~ MRCA(tr, .x))
  
  tr <- groupClade(tr, clades, group_name = "cluster") +
    aes(color = cluster) +
    scale_color_manual(values = clst_clrs) +
    geom_tiplab(angle = 90, hjust = 1, nudge_x = -0.1) +
    layout_dendrogram() +
    theme(
      legend.position = "none",
      plot.margin = margin(6, 6, 250, 6)
    )
  
  # Create heatmaps
  heat <- clsts$clusters %>%
    create_go_heatmap(
      go_in      = go_typ,
      n_overlap  = ovlp,
      n_clusters = n_clsts,
      n_terms    = n_terms,
      n_col      = 1,
      free_y     = FALSE,
      clrs       = clst_clrs
    )
  
  heat$heatmap <- heat$heatmap +
    theme(axis.text = element_text(size = 7))
  
  # Select genes to plot
  # tot_n_terms <- clsts$clusters %>%
  #   group_by(cluster) %>%
  #   dplyr::slice(1:n_terms) %>%
  #   nrow
  n_gns <- seq_len(n_genes)
  go_gn <- go_typ
  
  if (typ_plt) go_gn <- go_in
  
  # Example genes to plot
  gns <- go_gn@compareClusterResult %>%
    as_tibble() %>%
    right_join(heat$terms, by = "Description") %>%
    mutate(geneID = str_split(geneID, "/")) %>%
    unnest(geneID) %>%
    group_by(geneID, cluster) %>%
    summarize(n = n_distinct(Cluster), .groups = "drop") %>%
    distinct(geneID, .keep_all = TRUE) %>%
    arrange(cluster, desc(n))
  
  top_sig <- degs[[obj]] %>%
    filter(gene %in% gns$geneID) %>%
    group_by(gene) %>%
    summarize(pval = min(max_pval), .groups = "drop")
  
  gns <- gns %>%
    left_join(top_sig, by = c(geneID = "gene")) %>%
    arrange(desc(n), pval) %>%
    group_by(cluster) %>%
    dplyr::slice(n_gns) %>%
    ungroup()
  
  gns <- set_names(as.character(gns$cluster), gns$geneID)

  # gns <- go_gn@compareClusterResult %>%
  #   as_tibble() %>%
  #   right_join(heat$terms, by = "Description") %>%
  #   mutate(geneID = str_split(geneID, "/")) %>%
  #   unnest(geneID) %>%
  #   group_by(geneID, cluster) %>%
  #   summarize(n = n_distinct(Cluster), .groups = "drop") %>%
  #   distinct(geneID, .keep_all = TRUE) %>%
  #   arrange(cluster, desc(n)) %>%
  #   group_by(cluster) %>%
  #   dplyr::slice(n_gns) %>%
  #   ungroup()
  # 
  # gns <- set_names(
  #   as.character(gns$cluster),
  #   gns$geneID
  # )
  
  # Create gene plots
  gn_plts <- create_gene_plots(
    exp_data   = list("8hpi" = so_8, "24hpi" = so_merge),
    deg_data   = list("8hpi" = degs$`so_8-up`, "24hpi" = degs$`so_merge-up`),
    gns        = gns,
    cell_types = 8,
    clrs       = clst_clrs
  ) +
    theme(
      plot.margin = margin(6, 40, 6, 40, unit = "pt"),
      axis.text   = element_text(size = 7),
      strip.text  = element_text(size = 8)
    )
  
  # Create final figure
  bot <- plot_grid(
    heat$heatmap + theme(plot.margin = margin(6, 40, 6, 40, unit = "pt")),
    gn_plts,
    nrow = 1,
    labels = c("B", "C"),
    rel_widths = c(0.9, 1),
    align = "h",
    axis  = "tb"
  )
  
  res <- plot_grid(
    tr, bot,
    ncol = 1,
    rel_heights = c(0.3, 1),
    labels = "A"
  )
  
  res
}

go_type[grepl("-all$", names(go_type))] %>%
  iwalk(~ {
    ttl <- str_remove(.y, "^so_")
    ttl <- str_replace(ttl, "^merge", "24hpi-8hpi")
    
    cat("\n\n#### ", ttl, "\n\n")
    
    plt <- create_go_summary_figures(
      go_in = .x,
      sample_name = .y
    )
    
    if (is.null(plt)) {
      plt <- ggplot() +
        geom_blank()
    }
    
    print(plt)
    cat("\n\n---\n\n<br>\n\n<br>")
  })
```



```{r "GO module scores", eval = FALSE}

# Object to use for calculating scores
obj <- so_merge

# Top terms
mod_terms <- clusters$`so_8-up`$clusters %>%
  filter(cluster == 1) %>%
  mutate(rank = row_number()) %>%
  dplyr::select(Description, ID, rank)

mod_terms <- clusters$`so_merge-up`$clusters %>%
  filter(cluster == 1) %>%
  head(10)
  # left_join(mod_terms, by = c("Description", "ID"))

mod_terms <- set_names(mod_terms$Description, mod_terms$ID)

# Pull genes for each term
mart <- biomaRt::useMart(
  biomart = "ensembl",
  dataset = "mmusculus_gene_ensembl"
)

term_gns <- unname(mod_terms) %>%
  set_names() %>%
  map(fetch_genes, mart = mart)

term_gns <- term_gns %>%
  map(~ {
    .x[.x %in% rownames(obj)]
  })

# Calculate module scores
clmn_nms <- names(term_gns) %>%
  str_replace_all("[- ]", "_")

clmn_nms <- set_names(
  str_c(clmn_nms, seq_along(clmn_nms)),
  clmn_nms
)
  
# so_merge <- so_merge %>%
obj <- obj %>%
  AddModuleScore(features = term_gns, name = names(clmn_nms))

obj <- obj %>%
  mutate_meta(~ {
    .x %>%
      dplyr::rename(!!!clmn_nms)
  })

# Create boxplot
# lvls <- c("mock", "8hpi")
lvls <- c("8hpi", "24hpi")

plt_dat <- obj@meta.data %>%
  as_tibble(rownames = ".cell_id") %>%
  pivot_longer(all_of(names(clmn_nms))) %>%
  dplyr::select(orig.ident, treatment, rep, subtype, name, value)

plt_dat %>%
  mutate(
    treatment = fct_relevel(treatment, lvls),
    subtype = fct_reorder(subtype, value, .desc = TRUE)
  ) %>%
  ggplot(aes(subtype, value, alpha = treatment, fill = subtype)) +
  geom_boxplot(outlier.size = 0.1, outlier.alpha = 1, position = position_dodge2(preserve = "single")) +
  facet_wrap(~ name, scales = "free_y") +
  scale_alpha_manual(values = c(0.5, 1)) +
  guides(fill = "none") +
  djvdj_theme() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )


```

```{r "GSEA MARKERS", eval = FALSE}
# Cell types to test
typs <- so_24 %>%
  get_cell_types("lec_type", "orig.ident", n_cells = 3)

# Find marker genes for each cell type
marks_path <- here(params$so_dir, "all_markers.tsv")

if (!file.exists(marks_path)) {
  Idents(so_24) <- so_24 %>%
    FetchData("treatment")
  
  marks <- typs %>%
    map_dfr(~ {
      so_24 %>%
        subset(subset = lec_type == .x) %>%
        find_conserved_markers(
          ident_1  = "CHIKV",
          grp_var  = "rep",
          p_max    = 1.1,
          fc_range = c(-Inf, Inf)
        ) %>%
        mutate(cell_type = .x)
    }) %>%
    arrange(desc(avg_log2FC))
  
  marks %>%
    write_tsv(marks_path)
  
} else {
  marks <- read_tsv(marks_path)
}

# Exclude ribosomal protein and mitochondrial genes
marks <- marks %>%
  filter(!grepl("^Rp[sl]|^mt-", gene))

```

```{r "H CLUSTERING", eval = FALSE}

# Marker stats columns
reps     <- unique(so_24$rep)
fc_clmns <- str_c(reps, "_avg_log2FC")
p_clmns  <- str_c(reps, "_p_val_adj")

# Format matrix
# Only include genes >1.25 fold change and <0.05 adj p-value
# This will cluster based only on fold changes for genes/cell types
# sinificantly upregulated, genes that are not upregulated are set as 0
sig_marks <- marks %>%
  filter(
    if_all(all_of(fc_clmns), ~ .x > log2(1.25)),
    if_all(all_of(p_clmns),  ~ .x < 0.05)
  ) %>%
  rowwise() %>%
  mutate(max_p = max(!!!syms(p_clmns))) %>%
  ungroup() %>%
  dplyr::select(gene, cell_type, avg_log2FC, max_p)
  
mat <- sig_marks %>%
  dplyr::select(-max_p) %>%
  pivot_wider(
    names_from  = cell_type,
    values_from = avg_log2FC,
    values_fill = 0
  ) %>%
  column_to_rownames("gene") %>%
  t() %>%
  scale() %>%
  t()

# Hierarchical clustering
clsts_path <- here(params$so_dir, "gene_clusters.tsv")

if (!file.exists(clsts_path)) {
  hcl <- mat %>%
    dist() %>%
    hclust(method = "ward.D")
  
  clsts <- cutree(hcl, k = 10)
  
  clsts <- tibble(
    gene    = names(clsts),
    cluster = as.character(unname(clsts))
  )
  
  clsts %>%
    write_tsv(clsts_path)
  
} else {
  clsts <- read_tsv(clsts_path, col_types = cols(cluster = col_character()))
}

# Summarize gene fold change for each cluster
# Calculate overall average fold change and p-value for each cell_type
# Use average fold change to identify the predominant cell types upregulated for
# each cluster
clst_dat <- marks %>%
  dplyr::select(gene, cell_type, avg_log2FC, max_pval) %>%
  right_join(clsts, by = "gene") %>%
  group_by(cluster, cell_type) %>%
  mutate(
    type_log2FC = mean(avg_log2FC),
    type_pval   = mean(max_pval),
  ) %>%
  ungroup()

# Only include cell type if meets FC and p threshold for the cluster
clst_dat <- clst_dat %>%
  group_by(cluster) %>%
  mutate(
    max_fc     = max(type_log2FC),
    max_fc_lim = max(type_log2FC[type_log2FC < unique(max_fc)]) * 1.5
  ) %>%
  filter(
    cell_type %in% cell_type[type_log2FC > log2(1.25) & type_pval < 0.05]
  )

# Further filter cell types for each cluster
# if one cell type is >1.5 fold higher than other cell types,
# remove other cell types
clst_dat <- clst_dat %>%
  filter(
    n_distinct(cell_type) == 1 |
    cell_type %in% cell_type[
      (type_log2FC == max_fc & max_fc > max_fc_lim) |
      all(type_log2FC <= max_fc_lim)
    ]
  ) %>%
  mutate(
    up_types = list(unique(cell_type)),
    n_types = n_distinct(cell_type)
  ) %>%
  ungroup() %>%
  mutate(shared = n_types >= 5)

# Merge clusters with >4 positive cell types
# Create data.frame with new cluster IDs
clst_dat <- clst_dat %>%
  mutate(cluster = ifelse(shared, max(cluster[shared]), cluster))

```

```{r "H CLUSTERING HEATMAP", eval = FALSE}

# Identify top 6 clusters
up_types <- clst_dat %>%
  distinct(cluster, gene, up_types, n_types) %>%
  group_by(cluster, up_types, n_types) %>%
  summarize(n = n_distinct(gene), .groups = "drop")

top_clsts <- up_types %>%
  group_by(cluster, n_types, n) %>%
  summarize(id = map_chr(up_types, str_c, collapse = "/"), .groups = "drop") %>%
  mutate(id = ifelse(n_types >= 5, "interferon response", id)) %>%
  group_by(cluster, id) %>%
  summarize(n = sum(n), .groups = "drop") %>%
  arrange(desc(n)) %>%
  mutate(
    rnk = row_number(),
    id  = str_replace(id, "_", " "),
    id = str_c(id, "\n", n, " genes")
  ) 

clst_lvls <- set_names(top_clsts$id, top_clsts$cluster)

top_clsts <- head(top_clsts, 6)
  
# Format scaled data for plotting
# Create new table with revised cluster IDs
# Want to show fold changes for all genes/cell types when creating heatmaps,
# not just upregulated genes
clsts <- clst_dat %>%
  distinct(gene, cluster) %>%
  filter(cluster %in% top_clsts$cluster)

plt_dat <- marks %>%
  filter(
    gene %in% unique(sig_marks$gene),
    cell_type %in% colnames(mat)
  ) %>%
  
  dplyr::select(gene, cell_type, avg_log2FC) %>%
  pivot_wider(
    names_from  = cell_type,
    values_from = avg_log2FC,
    values_fill = 0
  ) %>%
  column_to_rownames("gene") %>%
  t() %>%
  scale() %>%
  t() %>%

  as_tibble(rownames = "gene") %>%
  left_join(clsts, by = "gene") %>%
  filter(!is.na(cluster)) %>%
  pivot_longer(-c(gene, cluster), names_to = "cell_type") %>%
  mutate(
    cell_type = as.factor(cell_type),
    cluster = fct_relevel(cluster, top_clsts$cluster)
  ) %>%
  arrange(cluster, cell_type)
  
# ORIGINAL VERSION
# plt_dat <- mat %>%
#   as_tibble(rownames = "gene") %>%
#   left_join(clsts, by = "gene") %>%
#   filter(!is.na(cluster)) %>%  # NAs are genes not found in any cluster
#   pivot_longer(-c(gene, cluster), names_to = "cell_type") %>%
#   mutate(
#     cluster = fct_relevel(cluster, top_clsts$cluster)
#   ) %>%
#   arrange(cluster, cell_type)

# Format data for drawing heatmap boxes
type_lvls <- levels(plt_dat$cell_type)
type_lvls <- set_names(seq_along(type_lvls), type_lvls)

bx_dat <- up_types %>%
  filter(n_types < 3) %>%
  unnest(up_types) %>%
  group_by(cluster, up_types) %>%
  mutate(
    x = type_lvls[up_types],
    x = list(c(x - 0.5, x + 0.5))
  ) %>%
  ungroup() %>%
  unnest(x) %>%
  filter(cluster %in% plt_dat$cluster) %>%
  mutate(cluster = fct_relevel(cluster, levels(plt_dat$cluster)))

# Create heatmaps
clst_clrs <- c(
  "3" = lec_type_cols[["unassigned-LEC"]],
  "8" = lec_type_cols[["BEC"]],
  "5" = lec_type_cols[["PvC"]],
  "2" = lec_type_cols[["Macrophages"]],
  "4" = lec_type_cols[["Marco_LEC"]],
  "9" = lec_type_cols[["FRC"]]
)

h_heat <- plt_dat %>%
  # ggplot(aes(cell_type, gene, fill = value)) +
  # scale_fill_gradient2(low = "grey85", mid = "white", high = "#D7301F") +
  # scale_fill_gradient2(low = "#56B4E9", mid = "white", high = "#D7301F") +
  # guides(fill = guide_colorbar(
  #   ticks = FALSE,
  #   title.position = "bottom",
  #   barwidth = unit(150, "pt"), barheight = unit(10, "pt")
  # )) +
  
  ggplot(aes(cell_type, gene, fill = cluster, alpha = value)) +
  scale_alpha_continuous(range = c(0.01, 1)) +
  scale_fill_manual(values = clst_clrs) +
  guides(
    fill = "none",
    alpha = guide_legend(
      label.position = "bottom",
      keyheight = unit(7, "pt"),
      title = "z-score",
      title.position = "top"
    )
  ) +
  geom_vline(data = bx_dat, aes(xintercept = x)) +
  geom_tile() +
  facet_wrap(
    ~ cluster,
    scales         = "free_y",
    strip.position = "left",
    labeller       = as_labeller(clst_lvls),
    ncol = 1
  ) +
  scale_x_discrete(position = "top") +
  djvdj_theme() +
  theme(
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.x  = element_text(angle = 90, hjust = 0, vjust = 0.5),
    axis.title   = element_blank(),
    legend.position = "bottom",
    legend.title    = element_text(size = txt_pt1, hjust = 0.5),
    strip.clip = "off"
  )

```

```{r "H CLUSTERING GO", eval = FALSE}

# Format genes for GO analysis
go_gns <- clsts %>%
  split(as.character(.$cluster)) %>%
  map(pull, gene)

# Identify GO terms
go_file <- file.path(params$so_dir, "gene_clusters_go.tsv")

if (!file.exists(go_file)) {
  go_res <- go_gns %>%
    gost(
      organism = "mmusculus",
      ordered_query = FALSE,
      evcodes = TRUE
    ) %>%
    .$result %>%
    filter(
      source %in% c("GO:BP", "GO:MF", "KEGG"),
      p_value < 0.05,
      term_size < 500
    ) %>%
    arrange(p_value)
  
  go_res %>%
    write_tsv(go_file)

} else {
  go_res <- read_tsv(go_file, col_types = cols(query = col_character()))
}

# Create GO bargraphs
lab_fn <- function(x) {
  x %>%
    str_remove("^[0-9]+-") %>%
    str_trunc(80) %>%
    str_wrap(45)
}

go_bars <- go_res %>%
  group_by(query) %>%
  dplyr::slice(1:6) %>%
  ungroup() %>%
  dplyr::select(-parents) %>%
  mutate(
    term_name = str_c(query, "-", term_name),
    term_name = fct_reorder(term_name, p_value, .desc = TRUE),
    query     = fct_relevel(query, names(clst_lvls))
  ) %>%
  ggplot(aes(-log10(p_value), term_name, fill = query)) +
  geom_col() +
  labs(x = "-log10(p-value)") +
  facet_wrap(~ query, scales = "free_y", strip.position = "right", ncol = 1) +
  scale_fill_manual(values = clst_clrs) +
  scale_y_discrete(labels = lab_fn) +
  djvdj_theme() +
  theme(
    axis.title.y = element_blank(),
    axis.title.x = element_text(size = txt_pt1),
    legend.position = "none",
    strip.text = element_blank()
  )

```

```{r "H CLUSTERING TOP GENES", eval = FALSE}

# gns <- c("Cd74", "H2-Ab1", "Lgmn", "Angpt2", "Pik3r1", "Gja1", "Ywhag")    # BEC
# gns <- c("Vcam1", "Akt3", "Cdh5", "Ccl5", "F11r", "Olr1", "Dst", "Nlgn2")  # Marco
# gns <- c("Cxcl9", "Cxcl10", "Ccl2", "Ccl7", "Ccl4", "Il1b", "Il6", "Tnf")  # All
# gns <- c("Nod1", "Tlr3")                                                   # FRC/PvC
# gns <- c("Oas2", "Oas3", "Fgl2", "Irf1", "Cxcl10")                         # Mac

gns <- c("Irf7", "Ccl2", "Cxcl9", "Oas3", "Vcam1", "Tlr3")

# Format plotting data
dat <- so_24 %>%
  FetchData(c("treatment", "orig.ident", "lec_type", gns)) %>%
  rownames_to_column("cell_id") %>%
  pivot_longer(all_of(gns), names_to = "gene") %>%
  filter(lec_type %in% colnames(mat)) %>%
  mutate(
    treatment = fct_relevel(treatment, treats),
    gene = fct_relevel(gene, gns)
  )
  
# Format data for p-value labels
p_dat <- sig_marks %>%
  mutate(p_lab = format_pvalue(max_p)) %>%
  dplyr::rename(lec_type = cell_type) %>%
  filter(gene %in% gns) %>%
  mutate(gene = fct_relevel(gene, gns))

# Create boxplots
bx_fn <- function(x) str_c(x, "\nexpression")

gn_bxs <- dat %>%
  ggplot(aes(lec_type, value, alpha = treatment, fill = lec_type, color = lec_type)) +
  
  geom_boxplot(
    outlier.size = 0.001,
    position = position_dodge2(preserve = "single"),
    key_glyph = draw_key_point
  ) +

  geom_richtext(
    aes(lec_type, Inf, label = p_lab),
    data = p_dat,
    alpha = 1,
    size  = 5 / .pt,
    color = "black",
    fill  = NA,
    label.color = NA,
    vjust = "inward"
  ) +
    
  facet_wrap(
    ~ gene,
    scales = "free_y",
    ncol = 1,
    strip.position = "left",
    labeller = as_labeller(bx_fn)
  ) +
  guides(
    fill = "none",
    color = "none",
    alpha = guide_legend(override.aes = list(shape = 15, alpha = c(0.5, 1), size = 4))
  ) +
  scale_y_continuous(expand = expansion(c(0.05, 0.2))) +
  scale_alpha_manual(values = c(0.1, 0.6)) +
  scale_fill_manual(values = lec_type_cols) +
  scale_color_manual(values = lec_type_cols) +
  djvdj_theme() +
  theme(
    axis.title      = element_blank(),
    axis.text.x     = element_text(angle = 45, hjust = 1),
    legend.title    = element_blank(),
    legend.position = "top",
    strip.placement = "outside"
    # plot.margin = margin(15, 15, 15, 30),
  )

```

```{r "H FIGURE", fig.height = 10, fig.width = 10, eval = FALSE}

plot_grid(
  h_heat, go_bars, gn_bxs,
  align = "h",
  axis  = "tb",
  nrow  = 1,
  rel_widths = c(0.75, 1, 1),
  labels = c("A", "B", "C"),
  label_size = ttl_pt2 * 1.5
)

```

```{r "H SUPP", eval = FALSE}

# Format cluster labels
tab_labs <- clst_lvls %>%
  map_chr(str_remove, "\n.+") %>%
  map_chr(str_replace, "[/ ]", "_")

# Format table for gene clusters
tab_dat <- clst_dat %>%
  group_by(gene, cluster) %>%
  summarize(
    avg_log2FC = mean(avg_log2FC),
    # pval       = mean(max_pval),
    .groups    = "drop"
  ) %>%
  mutate(cluster = tab_labs[cluster]) %>%
  group_by(cluster) %>%
  mutate(n_genes = n_distinct(gene)) %>%
  ungroup() %>%
  arrange(desc(n_genes), desc(avg_log2FC)) %>%
  as.data.frame()

# Write excel file
tab_labs %>%
  walk(~ {
    tab_dat %>%
      filter(cluster == .x) %>%
      xlsx::write.xlsx(
        file      = file.path(params$so_dir, "gene_clusters.xlsx"),
        sheetName = .x,
        append    = TRUE,
        col.names = TRUE,
        row.names = FALSE
      )
  })

```

```{r "CLUSTERING IFN GENES", eval = FALSE}

# Cluster IFN genes
# EXCLUDE CD45+ CELL TYPES
cd45_typs <- c("T cells", "B cells", "Macrophages", "unassigned")

ifn_clst <- top_clsts %>%
  filter(grepl("interferon", id)) %>% 
  pull(cluster)

ifn_gns <- clsts %>%
  filter(cluster == ifn_clst) %>%
  pull(gene)

ifn_mat <- mat[ifn_gns, !colnames(mat) %in% cd45_typs]

hcl <- ifn_mat %>%
  dist() %>%
  hclust(method = "ward.D")

ifn_clsts <- cutree(hcl, k = 10)

ifn_clsts <- tibble(
  gene    = names(ifn_clsts),
  cluster = as.character(unname(ifn_clsts))
)

# Format data for heatmaps
# Summarize gene fold change for each cluster
# Calculate overall average fold change and p-value for each cell_type
# Use average fold change to identify the predominant cell types upregulated for
# each cluster
clst_dat <- marks %>%
  dplyr::select(gene, cell_type, avg_log2FC, max_pval) %>%
  right_join(ifn_clsts, by = "gene") %>%
  group_by(cluster, cell_type) %>%
  mutate(
    type_log2FC = mean(avg_log2FC),
    type_pval   = mean(max_pval),
  ) %>%
  ungroup()

# Only include cell type if meets FC and p threshold for the cluster
# EXCLUDE CD45+ CELL TYPES
clst_dat <- clst_dat %>%
  group_by(cluster) %>%
  mutate(
    max_fc     = max(type_log2FC),
    max_fc_lim = max(type_log2FC[type_log2FC < unique(max_fc)]) * 1.5
  ) %>%
  filter(
    cell_type %in% cell_type[type_log2FC > log2(1.25) & type_pval < 0.05],
    !cell_type %in% cd45_typs
  )

# Further filter cell types for each cluster
# if one cell type is >1.5 fold higher than other cell types,
# remove other cell types
clst_dat <- clst_dat %>%
  filter(
    n_distinct(cell_type) == 1 |
    cell_type %in% cell_type[
      (type_log2FC == max_fc & max_fc > max_fc_lim) |
      all(type_log2FC <= max_fc_lim)
    ]
  ) %>%
  mutate(
    up_types = list(unique(cell_type)),
    n_types = n_distinct(cell_type)
  ) %>%
  ungroup() %>%
  mutate(shared = n_types >= 5)

# Merge clusters with >4 positive cell types
# Create data.frame with new cluster IDs
# clst_dat <- clst_dat %>%
#   mutate(cluster = ifelse(shared, max(cluster[shared]), cluster))

```

```{r "IFN HEATMAPS", eval = FALSE}

# Identify top 6 clusters
up_types <- clst_dat %>%
  distinct(cluster, gene, up_types, n_types) %>%
  group_by(cluster, up_types, n_types) %>%
  summarize(n = n_distinct(gene), .groups = "drop")

top_clsts <- up_types %>%
  group_by(cluster, n_types, n) %>%
  summarize(id = map_chr(up_types, str_c, collapse = "/"), .groups = "drop") %>%
  mutate(id = ifelse(n_types >= 5, "interferon response", id)) %>%
  group_by(cluster, id) %>%
  summarize(n = sum(n), .groups = "drop") %>%
  arrange(desc(n)) %>%
  mutate(
    rnk = row_number(),
    id  = str_replace(id, "_", " "),
    id = str_c(id, "\n", n, " genes")
  ) 

clst_lvls <- set_names(top_clsts$id, top_clsts$cluster)

top_clsts <- head(top_clsts, 6)
  
# Format scaled data for plotting
# Create new table with revised cluster IDs
# Want to show fold changes for all genes/cell types when creating heatmaps,
# not just upregulated genes
clsts <- clst_dat %>%
  distinct(gene, cluster) %>%
  filter(cluster %in% top_clsts$cluster)

plt_dat <- marks %>%
  filter(
    gene %in% unique(sig_marks$gene),
    cell_type %in% colnames(ifn_mat)
  ) %>%
  
  dplyr::select(gene, cell_type, avg_log2FC) %>%
  pivot_wider(
    names_from  = cell_type,
    values_from = avg_log2FC,
    values_fill = 0
  ) %>%
  column_to_rownames("gene") %>%
  t() %>%
  scale() %>%
  t() %>%

  as_tibble(rownames = "gene") %>%
  left_join(clsts, by = "gene") %>%
  filter(!is.na(cluster)) %>%
  pivot_longer(-c(gene, cluster), names_to = "cell_type") %>%
  mutate(
    cell_type = as.factor(cell_type),
    cluster = fct_relevel(cluster, top_clsts$cluster)
  ) %>%
  arrange(cluster, cell_type)

# Format data for drawing heatmap boxes
type_lvls <- levels(plt_dat$cell_type)
type_lvls <- set_names(seq_along(type_lvls), type_lvls)

bx_dat <- up_types %>%
  filter(n_types < 3) %>%
  unnest(up_types) %>%
  group_by(cluster, up_types) %>%
  mutate(
    x = type_lvls[up_types],
    x = list(c(x - 0.5, x + 0.5))
  ) %>%
  ungroup() %>%
  unnest(x) %>%
  filter(cluster %in% plt_dat$cluster) %>%
  mutate(cluster = fct_relevel(cluster, levels(plt_dat$cluster)))

# Create heatmaps
clst_clrs <- c(
  "3" = lec_type_cols[["unassigned-LEC"]],
  "8" = lec_type_cols[["BEC"]],
  "5" = lec_type_cols[["PvC"]],
  "2" = lec_type_cols[["Macrophages"]],
  "4" = lec_type_cols[["Marco_LEC"]],
  "9" = lec_type_cols[["FRC"]]
)

h_heat <- plt_dat %>%
  ggplot(aes(cell_type, gene, fill = cluster, alpha = value)) +
  scale_alpha_continuous(range = c(0.01, 1)) +
  scale_fill_manual(values = clst_clrs) +
  guides(
    fill = "none",
    alpha = guide_legend(
      label.position = "bottom",
      keyheight = unit(7, "pt"),
      title = "z-score",
      title.position = "top"
    )
  ) +
  geom_vline(data = bx_dat, aes(xintercept = x)) +
  geom_tile() +
  facet_wrap(
    ~ cluster,
    scales         = "free_y",
    strip.position = "left",
    labeller       = as_labeller(clst_lvls),
    ncol = 1
  ) +
  scale_x_discrete(position = "top") +
  djvdj_theme() +
  theme(
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.x  = element_text(angle = 90, hjust = 0, vjust = 0.5),
    axis.title   = element_blank(),
    legend.position = "bottom",
    legend.title    = element_text(size = txt_pt1, hjust = 0.5),
    strip.clip = "off"
  )

```

# P01 figures

## Figure 1

```{r "8hpi type 24hpi chikv counts"}
# 8 hpi cell types
type_8 <- so_8 %>%
  plot_scatter(
    "lec_type",
    plot_colors = lec_type_cols,
    plot_lvls   = NULL,
    size = 0.2,
    label_params = list(size = txt_pt2)
  ) +
  umap_theme +
  theme(
    aspect.ratio = 0.9,
    legend.title = element_blank(), legend.key.height = unit(30, "pt")
  )

# 24 hpi CHIKV counts
pseudo <- so_24$pct_CHIKV
pseudo <- min(pseudo[pseudo > 0]) / 2

chikv_24 <- so_24@meta.data %>%
  arrange(pct_CHIKV) %>%
  ggplot(aes(UMAP_1, UMAP_2, fill = pct_CHIKV + pseudo)) +
  geom_point_trace(
    color = "grey",
    trace_position = "bottom",
    size = 0.2
  ) +
  scale_fill_gradientn(colours = c("white", "#D7301F"), labels = scales::label_number()) +
  guides(fill = guide_colorbar(title.position = "top", ticks = FALSE, title = "% CHIKV\ncounts")) +
  umap_theme +
  theme(
    aspect.ratio         = 0.9,
    legend.position      = "top",
    legend.title         = element_text(hjust = 0.5, size = ttl_pt2 * 1.5),
    legend.text          = element_text(angle = 45, hjust = 1), 
    legend.direction     = "horizontal",
    legend.justification = 0.2,
    legend.key.height    = unit(30, "pt"),
    legend.key.width     = unit(5, "pt")
  )

# 24 hpi Marco expression
marco_24 <- so_24 %>%
  create_gene_boxplot(
    "Marco", "Marco_LEC",
    clr = "#D7301F",
    pval_y = 5.8
  ) +
  theme(axis.text.x = element_text(hjust = c(0.95, 0.5, 0.05)))
```

```{r "P01 figure", fig.height = 20, fig.width = 18}
# Adjust fraction bargraphs
frac_24 <- frac_24 +
  theme(
    aspect.ratio = 0.2,
    plot.margin  = margin(5, 5, 5, 25),
    axis.text.x  = element_text(size = txt_pt2)
  )

frac_8 <- frac_8 +
  theme(
    aspect.ratio = 0.2,
    plot.margin  = margin(5, 5, 5, 25),
    axis.text.x  = element_text(size = txt_pt2)
  )

# Adjust CHIKV count UMAPs
A <- A +
  guides(fill = guide_colorbar(title.position = "top", ticks = FALSE, title = "% CHIKV\ncounts")) +
  theme(
    legend.position = "right",
    legend.title = element_text(size = ttl_pt1, angle = 0),
    legend.text  = element_text(size = txt_pt1, angle = 0),
    legend.direction = "vertical",
    legend.key.height    = unit(30, "pt"),
    legend.key.width     = unit(5, "pt")
  )

chikv_24 <- chikv_24 +
  theme(
    legend.position = "right",
    legend.title = element_text(size = ttl_pt1, angle = 0),
    legend.text  = element_text(size = txt_pt1, angle = 0),
    legend.direction = "vertical"
  )

# Adjust cell type UMAPs
type_8 <- type_8 +
  ggtitle("8 hpi") +
  theme(plot.title = element_text(size = ttl_pt2 * 1.5, hjust = 0.5))

type_umap <- type_umap +
  ggtitle("24 hpi") +
  theme(plot.title = element_text(size = ttl_pt2 * 1.5, hjust = 0.5))
  
# Combine 8 hpi plots
bot <- plot_grid(
  marco_bxs, madcam_bxs,
  nrow  = 1,
  align = "h",
  axis  = "tb"
)

hpi8 <- plot_grid(
  type_8, A, frac_8, bot,
  labels     = c("A", "C", "E", "G"),
  label_size = ttl_pt2 * 1.5,
  ncol  = 1,
  align = "v",
  axis  = "rl",
  rel_heights = c(1, 1, 0.45, 0.7)
)

# Combine 24 hpi plots
bot <- plot_grid(
  marco_24, NULL,
  nrow  = 1,
  align = "h",
  axis  = "tb"
)

hpi24 <- plot_grid(
  type_umap, chikv_24, frac_24, bot,
  labels     = c("B", "D", "F", "H"),
  label_size = ttl_pt2 * 1.5,
  ncol  = 1,
  align = "v",
  axis  = "rl",
  rel_heights = c(1, 1, 0.45, 0.7)
)

# Create final figure
plot_grid(
  hpi8, hpi24,
  nrow  = 1,
  align = "h",
  axis  = "tb"
)
```

<br>

## Figure 2

A.  MARCO expression is shown for LEC and FRC subtypes for the 8 hpi and 24 hpi timepoints.
B.  Mxra8 expression is shown as described in A.

```{r, fig.height = 9, fig.width = 6}
# Format data for boxplots
bx_plt_dat <- typ_bx_dat %>%
  mutate(
    cell_type     = ifelse(lec_type %in% c("FRC", "PvC"), lec_type, cell_type),
    new_cell_type = ifelse(lec_type == "BEC", lec_type, cell_type),
    new_cell_type = ifelse(new_cell_type %in% lec_cell_types, "LEC", new_cell_type),
    new_lec_type  = ifelse(cell_type %in% lec_cell_types, lec_type, "other"),
    new_fib_type  = ifelse(cell_type %in% c(fib_cell_types, "FRC"), fib_type, "other")
  )

# Plot Marco and Mxra8 expression
gns <- c("Marco", "Mxra8")
  
lec_fig <- bx_plt_dat %>%
  filter(new_lec_type != "other") %>%
  create_example_gene_fig(
    gns    = gns,
    x_clmn = "new_lec_type",
    ttl    = "LEC subsets",
    clrs   = subtype_cols
  )

fib_fig <- bx_plt_dat %>%
  filter(new_fib_type != "other") %>%
  create_example_gene_fig(
    gns    = gns,
    x_clmn = "new_fib_type",
    ttl    = "FRC subsets",
    clrs   = subtype_cols
  ) %>%
  map(~ {
    .x + theme(axis.title.y = element_blank()) +
      plot_layout(tag_level = "new")
  })

# Create final figure
append(lec_fig, fib_fig) %>%
  wrap_plots(guides = "collect", ncol = 2, byrow = FALSE) +
  plot_annotation(tag_levels = "A") &
  theme(aspect.ratio = 0.25, plot.tag = element_text(size = ttl_pt2 * 1.5))
```

<br>

## Figure 3

* Using scRNAseq, we found that during WT CHIKV infection, expression of CCL21
  (attracts CCR7+ cells) and IL-7 (supports T cell proliferation and survival)
  were reduced in both LECs and FRCs
* In addition, expression of CXCL13, which recruits CXCR5 expressing B cells and
  Tfh cells to B cell follicles and GCs, was specifically reduced in FDCs.
* Moreover, MRCs that are positioned at the edge of B cell follicles adjacent
  to the SCS, and are also an important source of CXCL13, were undetectable by
  scRNAseq in the LNs of mice infected with WT CHIKV at 24 hpi.
  MRCs were detected in LNs of mock-infected mice and CHIKV-infected mice at 8
  hpi, suggesting these cells are lost or damaged by 24 h after CHIKV infection.
  
A.  CCL21 and IL7 expression is shown for mock and CHIKV-infected samples from the 24 hpi timepoint. * p < 0.01, ** p < 0.001, *** p < 0.0001.
B.  CXCL13 expression is shown for FRC subsets from mock and CHIKV-infected samples from the 24 hpi timepoint.
C.  The proportion of FRCs belonging to different subsets is shown for the 8 hpi and 24 hpi timepoints.
D.  The proportion of FRCs belonging to different subsets is shown for mock and CHIKV-infected samples from the 24 hpi timepoint. The height of each bar graph shows the mean for 3 biological replicates, error bars show the standard deviation. p-values were calculated using a two-sample t-test, p-values < 0.05 are shown above each set of bar graphs.

```{r, fig.width = 12, fig.height = 6}
# Adjust colors
type_cols["LEC"] <- type_cols[[lec_cell_types]]
type_cols["BEC"] <- lec_type_cols[["Valve"]]

# Calculate p-values
bx_dat <- bx_plt_dat %>%
  filter(tm == "24hpi")

# Create boxplots
gns <- c("Ccl21a", "Il7")

gn_fig1 <- bx_dat %>%
  create_example_gene_fig2(
    gns,
    x_clmn    = "new_cell_type",
    al_clmn   = "treatment",
    plot_lvls = c("FRC", "PvC", "LEC"),
    clrs      = type_cols
  )

gn_fig1[[2]] <- (gn_fig1[[2]] + plot_layout(tag_level = "new"))

gn_fig1 <- gn_fig1 %>%
  wrap_plots(nrow = 1, guides = "collect") &
  theme(
    strip.text = element_blank(),
    legend.position = "top"
  )

gn_fig2 <- bx_dat %>%
  filter(new_fib_type != "other") %>%
  create_example_gene_fig2(
    gns     = "Cxcl13",
    x_clmn  = "new_fib_type",
    al_clmn = "treatment",
    clrs    = subtype_cols
  )

fig_top <- wrap_plots(
  gn_fig1, plot_spacer(), gn_fig2[[1]],
  nrow = 1, widths = c(1, 0.05, 0.5)
) +
  plot_annotation(tag_levels = "A") &
  theme(strip.text = element_blank())

# FRC abundance
abun_dat <- bx_plt_dat %>%
  filter(new_fib_type != "other")

frc_stack <- abun_dat %>%
  mutate(
    tm_treat = str_c(tm, "-", treatment),
    tm_treat = fct_relevel(tm_treat, c("8hpi-mock", "8hpi-CHIKV", "24hpi-mock", "24hpi-CHIKV"))
  ) %>%
  plot_frequency(
    "new_fib_type", "tm_treat",
    plot_colors = subtype_cols,
    stack = TRUE
  ) +
  facet_wrap(~ tm, scales = "free_x") +
  theme(legend.title = element_blank())
  
mrc_bars <- abun_dat %>%
  filter(tm == "24hpi") %>%
  mutate(treatment = fct_relevel(treatment, treats)) %>%
  plot_frequency(
    "new_fib_type", "orig.ident", "treatment",
    p_method = "t",
    plot_colors = c(mock = "#F7AF34", CHIKV = "#A1342D")
  ) +
  coord_cartesian(ylim = c(0, 100)) +
  theme(
    legend.title = element_blank()
  )

fig_bot <- wrap_plots(
  frc_stack, mrc_bars, plot_spacer(),
  nrow = 1, widths = c(0.5, 1, 0.7)
)

# Create final figure
final_fig <- (fig_top / fig_bot) +
  plot_annotation(tag_levels = "A") &
  theme(plot.tag = element_text(size = ttl_pt2 * 1.5))

final_fig


# # FRC markers
# # PDPN+TNFSF11+MADCAM1+VCAM1+ICAM1+BST1+RELB+
# # CXCL13+ LN stroma (Katakai et al., 2008). One cluster ex-
# # pressed almost all of these markers and was enriched for
# # Tnfsf11 and Cxcl13 expression, suggesting that the constituent
# # cells are MRCs
# gns <- c(
#   "Ccl19", "Ccl21a", "Cxcl13",
#   "Ch25h",  # MRC
# )
# 
# so_24 %>%
#   plot_violin(
#     "Cxcl13", "fib_type", "treatment",
#     method = "boxplot"
#   )
# 
# so_24 %>%
#   plot_scatter(
#     "fib_type", group_col = "treatment",
#     size = 0.5
#   )
# 
# so_24 %>%
#   plot_scatter(
#     "Ch25h", group_col = "treatment", size = 0.5,
#     plot_colors = c("white", "red"), outline = TRUE
#   )
# 
# so_24 %>%
#   plot_violin(
#     "Tnfsf11", "fib_type", "treatment",
#     method = "boxplot"
#   )
# 
# abun_dat %>%
#   filter(tm == "8hpi") %>%
#   plot_frequency(
#     "new_fib_type", "orig.ident", stack = TRUE,
#     plot_colors = subtype_cols
#   ) 
# 
# bx_plt_dat %>%
#   filter(tm == "24hpi", new_fib_type != "other") %>%
#   plot_frequency(
#     "new_fib_type", "treatment",
#     p_label = "none"
#   )
```

<br>



```{r "EARLY GENES", eval = FALSE}

gn <- "Bst2"
gn <- "Irf7"
gn <- "Cxcl10"
gn <- "Ifi44"

dat <- list(so_8, so_24) %>%
  map_dfr(~ {
    .x %>%
      FetchData(c("treatment", "lec_subtype", gn, "orig.ident", "chikv_grp", "tm"))
  })

dat <- dat %>%
  mutate(
    tm        = ifelse(is.na(tm), "24hpi", tm),
    tm_treat  = ifelse(treatment == "CHIKV", tm, treatment),
    tm_treat  = fct_relevel(tm_treat, c("mock", "8hpi", "24hpi")),
    treatment = fct_relevel(treatment, c("mock", "CHIKV")),
    tm        = fct_relevel(tm, c("8hpi", "24hpi"))
  )

dat %>%
  ggplot(aes(tm_treat, !!sym(gn), fill = tm_treat, alpha = tm)) +
  geom_boxplot(
    position = position_dodge2(preserve = "single"),
    outlier.alpha = 1,
    outlier.size = 0.5
  ) +
  facet_wrap(~ lec_subtype) +
  scale_alpha_manual(values = c(`8hpi` = 0.25, `24hpi` = 0.75)) +
  djvdj_theme()
  

# dat %>%
#   mutate(treatment = fct_relevel(treatment, c("mock", "CHIKV"))) %>%
#   ggplot(aes(lec_subtype, !!sym(gn), fill = lec_subtype, alpha = treatment)) +
#   geom_boxplot() +
#   facet_wrap(~ tm) +
#   scale_alpha_manual(values = c(mock = 0.25, CHIKV = 0.75)) +
#   djvdj_theme()

```

```{r "GSEA RESULTS", eval = FALSE}

# Gene sets to use
m_db <- msigdbr(species = "Mus musculus")

to_query <- c("H", "C2", "C3", "C5")

gene_set <- m_db %>%
  filter(gs_cat %in% to_query) %>%
  dplyr::select(gs_name, gene_symbol)

# Turn off BiocParallel multi-threading
# Memory usage exceeds 32G when using 6 threads
options(MulticoreParam = BiocParallel::MulticoreParam(workers = 1))

# Run GSEA
gsea_path <- here(params$so_dir, "all_gsea.tsv")

if (!file.exists(gsea_path)) {
  gsea_res <- set_names(typs) %>%
    map_dfr(~ {
      gene_lst <- filter(marks, cell_type == .x)
      gene_lst <- set_names(gene_lst$avg_log2FC, gene_lst$gene)
      
      set.seed(42)
      
      gene_lst %>%
        GSEA(
          TERM2GENE    = gene_set,
          pvalueCutoff = 0.05,
          eps          = 1e-50
        ) %>%
        as_tibble() %>%
        mutate(cell_type = .x)
    })
  
  gsea_res %>%
    write_tsv(here(params$so_dir, "gsea.tsv"))
  
} else {
  gsea_res <- read_tsv(gsea_path)
}

# Focus on enriched pathway terms
gsea_res <- gsea_res %>%
  filter(
    enrichmentScore > 0,
    grepl("^(HALLMARK|WP|KEGG)_", ID)
  )

```

```{r "GSEA PLOTS", eval = FALSE}

k_dat <- gsea_res %>%
  group_by(cell_type) %>%
  dplyr::slice(1:30) %>%
  dplyr::select(ID, enrichmentScore, cell_type) %>%
  pivot_wider(
    names_from  = cell_type,
    values_from = enrichmentScore,
    values_fill = 0
  ) %>%
  column_to_rownames("ID")

k_res <- k_dat %>%
  kmeans(6)

# Bar graphs
plt_dat <- gsea_res %>%
  mutate(ID = fct_reorder(ID, -log10(p.adjust), mean))
  
plt_dat %>%
  # group_by(cell_type) %>%
  # dplyr::slice(1:10) %>%
  # ungroup() %>%
  filter(grepl("^(HALLMARK)_", ID)) %>%
  ggplot(aes(-log10(p.adjust), ID, fill = cell_type)) +
  geom_col() +
  facet_wrap(~ cell_type, ncol = 1, scales = "free_y") +
  scale_fill_manual(values = lec_type_cols) +
  djvdj_theme()

# Heatmaps
plt_dat %>%
  # group_by(cell_type) %>%
  # dplyr::slice(1:20) %>%
  # ungroup() %>%
  filter(grepl("^(HALLMARK|KEGG)_", ID)) %>%
  ggplot(aes(cell_type, ID, fill = -log10(p.adjust))) +
  geom_tile() +
  scale_fill_gradientn(colours = c("lightblue", "red")) +
  djvdj_theme() +
  scale_x_discrete(position = "top") +
  theme(
    axis.title.x = element_blank(),
    axis.text.x  = element_text(angle = 45, hjust = 0)
  )

```

```{r "GSEA MARKER HEATMAP", eval = FALSE}

# Fold changes for every gene
fc_dat <- marks %>%
  left_join(m_db, by = c("gene" = "gene_symbol")) %>%
  dplyr::select(gs_cat, gs_name, gene, avg_log2FC, cell_type) %>%
  filter(grepl("^(HALLMARK|KEGG)_", gs_name))

# Format GSEA data
terms <- gsea_res %>%
  filter(grepl("^(HALLMARK|KEGG)_", ID)) %>%
  group_by(cell_type) %>%
  dplyr::slice(1:10) %>%
  ungroup() %>%
  separate_rows(core_enrichment, sep = "/")

# Identify top genes
gns <- terms %>%
  group_by(cell_type, core_enrichment) %>%
  summarize(n = n(), .groups = "drop") %>%
  group_by(cell_type) %>%
  slice_max(n, n = 5)

# Identify top terms
# Overall top terms
# top_terms <- terms %>%
#   distinct(ID, cell_type, p.adjust) %>%
#   group_by(ID) %>%
#   summarize(
#     p.adjust = mean(p.adjust),
#     n = n_distinct(cell_type)
#   ) %>%
#   arrange(desc(n)) %>%
#   pull(ID)
top_terms <- terms %>%
  distinct(cell_type, ID)

# Format plot data
plt_dat <- fc_dat %>%
  filter(
    # gs_name %in% top_terms,
    gene %in% gns$core_enrichment
  ) %>%
  semi_join(top_terms, by = c(gs_name = "ID", "cell_type"))

# Add GSEA p-values
plt_dat <- terms %>%
  distinct(ID, p.adjust, cell_type) %>%
  right_join(plt_dat, by = c(ID = "gs_name", "cell_type"))

plt_dat %>%
  mutate(
    # ID   = fct_relevel(ID, rev(top_terms)),
    ID   = fct_reorder(ID, p.adjust, .desc = TRUE),
    gene = fct_reorder(gene, avg_log2FC, .desc = TRUE)
  ) %>%

# plt_dat %>%
#   filter(core_enrichment %in% unique(gns$core_enrichment)) %>%
#   group_by(core_enrichment) %>%
#   mutate(n = n_distinct(ID)) %>%
#   ungroup() %>%
#   mutate(core_enrichment = fct_reorder(core_enrichment, n, .desc = TRUE)) %>%
  
  ggplot(aes(gene, ID, fill = avg_log2FC)) +
  geom_tile() +
  facet_wrap(~ cell_type, ncol = 2, scales = "free_y") +
  scale_fill_gradient2(low = "blue", mid = "grey90", high = "red") +
  djvdj_theme() +
  theme(
    axis.title = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

```

```{r "K CLUSTERING DEGs", eval = FALSE}

reps     <- unique(so_24$rep)
fc_clmns <- str_c(reps, "_avg_log2FC")
p_clmns  <- str_c(reps, "_p_val_adj")

# Cluster genes based on FC for each cell type
# degs <- marks %>%
#   filter(
#     if_all(all_of(fc_clmns), ~ .x > 0),
#     if_all(all_of(p_clmns),  ~ .x < 0.05)
#   ) %>%
#   pull(gene) %>%
#   unique()

k_dat <- marks %>%
  filter(
    if_all(all_of(fc_clmns), ~ .x > 0),
    if_all(all_of(p_clmns),  ~ .x < 0.05)
  ) %>%
  # filter(gene %in% degs) %>%
  dplyr::select(gene, avg_log2FC, cell_type) %>%
  pivot_wider(
    names_from  = cell_type,
    values_from = avg_log2FC,
    values_fill = 0
  ) %>%
  column_to_rownames("gene") %>%
  t() %>%
  scale() %>%
  t()

k_res <- k_dat %>%
  kmeans(20)

k_res <- tibble(
  gene    = names(k_res$cluster),
  cluster = unname(k_res$cluster)
)

# Format plot data
clsts <- unique(k_res$cluster)

clsts %>%
  map(~ {
    # marks %>%
    k_dat %>%
      as.data.frame() %>%
      rownames_to_column("gene") %>%
      pivot_longer(-gene, names_to = "cell_type", values_to = "avg_log2FC") %>%
      inner_join(k_res, by = "gene") %>%
      filter(cluster == .x) %>%
      
      group_by(gene) %>%
      mutate(avg_log2FC = as.numeric(scale(avg_log2FC))) %>%
      ungroup() %>%
      
      ggplot(aes(cell_type, gene, fill = avg_log2FC)) +
      geom_tile() +
      scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
      facet_wrap(~ cluster, scales = "free") +
      djvdj_theme() +
      theme(
        axis.text.y  = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x  = element_text(angle = 45, hjust = 1),
        axis.title   = element_blank()
      )
  }) %>%
  plot_grid(plotlist = .)

```

```{r "Cell type CellChat", eval = FALSE}

# Create CellChat objects
prfx     <- "all_"
typ_clmn <- "cell_type"
clmns    <- c("orig.ident", "treatment", "rep", typ_clmn)

typ_cc <- so_24 %>%
  run_cellchat(
    group_col    = "treatment",
    cell_col     = typ_clmn,
    include_cols = clmns,
    pos_group    = "CHIKV",
    prefix       = prfx,
    object_dir   = params$so_dir
  )

# Table of differential pathways
typ_net <- typ_cc$cellchat %>%
  netMappingDEG(
    features.name = "CHIKV",
    thresh = 1
  )

typ_net_up <- typ_cc$cellchat %>%
  subsetCommunication(
    net            = typ_net,
    datasets       = "CHIKV",
    ligand.logFC   = 0.2,
    receptor.logFC = NULL
  ) %>%
  filter(pval < 0.05)
  # filter(ligand.pvalues < 0.05)

```

```{r "LEC CellChat", eval = FALSE}

# Cell types to includes
# only include ones with >30 cells for mock and CHIKV
prfx     <- "lec_"
typ_clmn <- str_c(prfx, "type")
clmns    <- c("orig.ident", "treatment", "rep", "cell_type", typ_clmn)

typs <- so_24@meta.data %>%
  group_by(treatment, !!sym(typ_clmn)) %>%
  summarize(n = n(), .groups = "drop") %>%
  filter(n > 30) %>%
  group_by(!!sym(typ_clmn)) %>%
  filter(all(treats %in% treatment)) %>%
  ungroup() %>%
  pull(lec_type) %>%
  unique()

# Create CellChat objects
lec_cc <- so_24 %>%
  subset(!!sym(typ_clmn) %in% typs) %>%
  run_cellchat(
    group_col    = "treatment",
    cell_col     = typ_clmn,
    include_cols = clmns,
    pos_group    = "CHIKV",
    prefix       = prfx,
    object_dir   = params$so_dir
  )

# Table of differential pathways
lec_net <- lec_cc$cellchat %>%
  netMappingDEG(
    features.name = "CHIKV",
    thresh = 1
  )

lec_net_up <- lec_cc$cellchat %>%
  subsetCommunication(
    net            = lec_net,
    datasets       = "CHIKV",
    ligand.logFC   = 0.2,
    receptor.logFC = NULL
  ) %>%
  filter(
    ligand.pvalues < 0.05,
    ligand.logFC > 0.5,
    receptor.logFC > 0
  )

```

```{r "CHIKV TOTAL INTERACTIONS HEATMAP", fig.width = 6, fig.height = 5, eval = FALSE}

# All cell types
file.path(params$so_dir, "all_chikv_heat.png") %>%
  png(res = 300, width = 6, height = 5, units = "in")

typ_cc$cc_objs$CHIKV %>%
  netVisual_heatmap(color.heatmap = "Reds", measure = "weight")

dev.off()

# LEC types
file.path(params$so_dir, "lec_chikv_heat.png") %>%
  png(res = 300, width = 6, height = 5, units = "in")

lec_cc$cc_objs$CHIKV %>%
  netVisual_heatmap(color.heatmap = "Reds", measure = "weight")

dev.off()

```

```{r "DIFF INTERACTIONS HEATMAP", fig.width = 6, fig.height = 5, eval = FALSE}

# All cell types
file.path(params$so_dir, "all_diff_heat.png") %>%
  png(res = 300, width = 6, height = 5, units = "in")

typ_cc$cellchat %>%
  netVisual_heatmap(measure = "weight")

dev.off()

# LEC types
file.path(params$so_dir, "lec_diff_heat.png") %>%
  png(res = 300, width = 6, height = 5, units = "in")

lec_cc$cellchat %>%
  netVisual_heatmap(measure = "weight")

dev.off()

```

```{r "OLD GO", eval = FALSE}

# Find marker genes
Idents(so_24) <- so_24$treatment

marks <- typs %>%
  map_dfr(~ {
    so_24 %>%
      subset(lec_type == .x) %>%
      FindConservedMarkers(
        ident.1 = "CHIKV",
        ident.2 = "mock",
        grouping.var = "rep",
        only.pos = TRUE
      ) %>%
      as_tibble(rownames = "gene") %>%
      mutate(cell_type = .x)
  })

# Filter markers
reps <- unique(so_24$rep)

fc_clmns   <- str_c(reps, "_avg_log2FC")
p_clmns    <- str_c(reps, "_p_val_adj")
pct1_clmns <- str_c(reps, "_pct.1")
pct2_clmns <- str_c(reps, "_pct.2")

up <- marks %>%
  filter(
    if_all(all_of(fc_clmns),   ~ .x > log2(1.25)),
    if_all(all_of(p_clmns),    ~ .x < 0.05),
    if_all(all_of(pct1_clmns), ~ .x > 0.3),
    if_all(all_of(pct2_clmns), ~ .x < 0.5)
  )

# Identify GO terms
go <- up %>%
  split(.$cell_type) %>%
  imap_dfr(~ {
    bg <- so_24 %>%
      subset(lec_type == .y) %>%
      subset(treatment == treats[1])
    
    bg <- bg@assays$RNA@data %>%
      rowMeans() %>%
      sort(decreasing = TRUE) %>%
      head(5000) %>%
      names()
    
    res <- gost(
      query        = .x$gene,
      organism     = "mmusculus",
      domain_scope = "custom",
      custom_bg    = bg,
      evcodes      = TRUE,
      significant  = TRUE
    ) %>%
      .$result
    
    if (is_empty(res)) return(NULL)
    
    res %>%
      as_tibble() %>%
      mutate(query = .y) %>%
      dplyr::select(-evidence_codes, -parents)
  })

# Plot top GO terms
top_go <- go %>%
  filter(
    term_size > 10, term_size < 400,
    intersection_size > 5,
    source %in% c("GO:BP", "HP", "KEGG", "WP")
  ) %>%
  rowwise() %>%
  mutate(
    intersection = list(str_split(intersection, ",")[[1]]),
    frac_term = intersection_size / term_size
  ) %>%
  ungroup() %>%
  arrange(query, p_value)

top_go %>%
  group_by(query) %>%
  slice(1:10) %>%
  
  ggplot(aes(-log10(p_value), term_name, size = frac_term, color = query)) +
  geom_point() +
  facet_wrap(~ query) +
  scale_color_manual(values = lec_type_cols) +
  djvdj_theme()
  
```

```{r "GSEA", eval = FALSE}


```




