---
title: "CHIKV LNSC figures"
author: "Ryan Sheridan"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc:       true
    toc_float: true
    toc_depth: 2
    theme:     cosmo
    highlight: kate
params:
  
  template_dir: "src"
  so_dir:       "~/Dropbox/Ryan/Projects/morrison-lnsc/results/sobjs"
  orig_so_dir:  "~/Dropbox/Ryan/Projects/morrison-scRNA-seq/results"
  type_res:     10                        # Clustering resolution for annotating cell types
  lec_res:      5                         # Clustering resolution for annotating LECs
  fib_res:      3                         # Clustering resolution for annotating fibroblasts/stromal cells
editor_options: 
  chunk_output_type: console
---

<br>

```{r "chunk opts", echo = FALSE}
# Default chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo    = FALSE,
  dpi     = 500
)
```

```{r "packages"}
# plotting
library(scales)
library(ggrepel)
library(ggtrace)
library(patchwork)
library(cowplot)
library(colorblindr)
library(ggtext)

# analysis
library(Seurat)
library(harmony)
library(clustifyr)
library(clustifyrdata)
library(DoubletFinder)
library(M3Drop)
library(CellChat)
library(djvdj)
library(presto)
library(gprofiler2)
library(qs)

library(clusterProfiler)
library(enrichplot)
library(msigdbr)
library(org.Mm.eg.db)
library(GOSemSim)
library(biomaRt)
library(ggtree)

# tidyverse
library(tidyverse)
library(here)
library(knitr)
library(broom)

source(here(params$template_dir, "funs.R"))

chikv_grps <- c("CHIKV-low", "CHIKV-high")
```

```{r "functions"}
type_lab_fn <- function(x) str_replace(x, "_", " ")

plot_example_gene <- function(so_in, feat, grp, box_colors = NULL,
                              umap_colors = c("#56B4E9", "white", "#D7301F")) {
  
  dat <- so_in %>%
    FetchData(c(feat, grp, "UMAP_1", "UMAP_2"))
  
  u <- dat %>%
    arrange(!!sym(feat)) %>%
    ggplot(aes(UMAP_1, UMAP_2, fill = !!sym(feat))) +
    geom_point_trace(size = 0.25, stroke = 0.65) +
    scale_fill_gradientn(colours = umap_colors) +
    guides(fill = guide_colorbar(
      ticks          = FALSE,
      barheight      = unit(10, "pt"),
      barwidth       = unit(140, "pt"),
      title.position = "top"
    )) +
    umap_theme +
    theme(
      legend.position      = "top",
      legend.title         = element_text(hjust = 0.5),
      legend.justification = 0.5,
      panel.border         = element_rect(fill = NA, color = "grey85")
    )
  
  
  lvls <- dat %>%
    group_by(!!sym(grp)) %>%
    summarize(
      med   = median(!!sym(feat)),
      stats = list(boxplot.stats(!!sym(feat))),
      q3    = map_dbl(stats, ~ .x$stats[4]),
      q4    = map_dbl(stats, ~ .x$stats[5]),
      max   = max(!!sym(feat)),
      .groups = "drop"
    ) %>%
    arrange(med, q3, q4, max) %>%
    pull(grp) %>%
    rev()
  
  b <- dat %>%
    plot_violin(
      feat, grp,
      plot_colors   = box_colors,
      plot_lvls     = lvls,
      method        = "boxplot",
      outlier.size  = 0.25,
      outlier.alpha = 1
    ) +
    theme(
      legend.position = "none",
      aspect.ratio = 0.21,
      axis.text.x  = element_text(angle = 45, hjust = 1),
      axis.line.y  = element_line(size = 0.5, color = "grey85"),
      axis.ticks.x = element_blank(),
      panel.border = element_blank(),
      axis.title.x = element_blank()
    )
  
  plot_grid(
    u, b,
    ncol        = 1,
    rel_heights = c(1, 0.5),
    align       = "v",
    axis        = "rl"
  )
}

create_cor_heatmap <- function(df_in, ttl, lec_labs = NULL, ln_clr = fade_0) {
  
  # # Cell type labels
  # lec_labs <- df_in %>%
  #   format_labels(
  #     lab_clmn = "lec_type",
  #     char_vec = new_cell_labs,
  #     expr_vec = marco_expr
  #   )
  # 
  # ref_labs <- c(
  #   Valve      = "Valve LEC",
  #   Collecting = "Collecting LEC",
  #   Ptx3_LEC   = "Ptx3 LEC",
  #   Marco_LEC  = parse(text = marco_expr)
  # )
  
  if (!is.null(lec_labs)) {
    df_in <- df_in %>%
      filter(assigned_type %in% names(lec_labs()))
  }
  
  # Data for tile labels
  lab_df <- df_in %>%
    group_by(assigned_type) %>%
    slice_max(r, n = 1) %>%
    ungroup()
  
  # Create heatmaps
  res <- df_in %>%
    ggplot(aes(ref_type, assigned_type, fill = r)) +
    geom_tile(color = ln_clr, size = 0.2) +
    
    geom_text(
      aes(label = round(r, 2)),
      data  = lab_df,
      color = "black",
      size  = txt_pt1 / .pt
    ) +
    
    guides(fill = bar_gd()) +
    
    scale_fill_gradientn(colors = c(fade_0, "#E69F00")) +
    # scale_x_discrete(labels = ref_labs) +
    # scale_y_discrete(labels = lec_labs) +
    
    labs(title = ttl, x = "reference", y = "assigned type") +
    
    base_theme +
    theme(
      legend.text = element_text(size = txt_pt1),
      axis.line.x = element_blank(),
      axis.line.y = element_blank(),
      axis.text.x = element_text(hjust = 1, angle = 45, size = txt_pt1),
      axis.text.y = element_text(hjust = 1, size = txt_pt1),
      axis.title  = element_text(size = txt_pt2),
      plot.title  = element_text(size = ttl_pt1)
    )
  
  if (!is.null(lec_labs)) {
    res <- res +
      scale_y_discrete(labels = lec_labs)
  }
  
  res
}

create_gene_boxplot <- function(input, GENE, TYPE, clr = lec_type_cols[[TYPE]],
                                pval_y = 5) {
  
  # Format plot data
  dat <- input %>%
    FetchData(c("lec_type", "treatment", "rep", "orig.ident", "chikv_grp", GENE)) %>%
    filter(lec_type == TYPE) %>%
    mutate(chikv_grp = ifelse(treatment == "mock", treatment, chikv_grp))
  
  clrs <- set_names(
    c("grey", rep(clr, 2)),
    unique(dat$chikv_grp)
  )
  
  # Calculate p-values
  p_vals <- dat %>%
    calc_p_vals(
      data_column = GENE,
      type_column = "chikv_grp"
    )
  
  comps <- names(clrs) %>%
    combn(2, simplify = FALSE)
  
  comps <- list(
    x    = map_chr(comps, pluck, 1),
    xend = map_chr(comps, pluck, 2),
    y    = c(pval_y, pval_y + pval_y * 0.12, pval_y)
  )
  
  # Create boxplots
  res <- dat %>%
    plot_violin(
      GENE, "chikv_grp",
      method        = "boxplot",
      plot_colors   = clrs,
      plot_lvls     = names(clrs),
      alpha         = c(0.5, 0.1, 0.5),
      size          = 1,
      outlier.size  = 1.5,
      outlier.alpha = 1,
      width         = 0.6
    ) +
    labs(title = TYPE, y = str_c(GENE, " expression")) +
    base_theme +
    theme(
      legend.position = "none",
      aspect.ratio = 1.5,
      plot.title   = element_text(size = ttl_pt2 * 1.5),
      axis.title.y = element_text(size = ttl_pt2),
      axis.title.x = element_blank(),
      axis.text.x  = element_text(size = ttl_pt2, hjust = c(0.75, 0.5, 0.25)),
      plot.margin  = margin(5, 10, 5, 5)
    )
  
  # Add p-values to plot
  comps %>%
    pwalk(~ {
      v_args <- list(...)[c("x", "xend")]
      
      p <- p_vals %>%
        filter(`Cell type 1` %in% v_args & `Cell type 2` %in% v_args) %>%
        pull(p_adj)
      
      res <<- res %>%
        add_pvals(
          ...,
          p_val    = p,
          size     = txt_pt2 / .pt,
          line_col = "grey75"
        )
    })
  
  res
}

create_example_gene_fig <- function(df_in, gns, x_clmn, clrs = lec_type_cols,
                                    ttl = NULL) {
  res <- gns %>%
    imap(~ {
      lvls <- df_in %>%
        group_by(!!sym(x_clmn), tm_treat) %>%
        summarize(
          n     = n(),
          stats = list(boxplot.stats(!!sym(.x))),
          med   = map_dbl(stats, ~ .x$stats[3]),
          q3    = map_dbl(stats, ~ .x$stats[4]),
          q4    = map_dbl(stats, ~ .x$stats[5]),
          mx    = max(!!sym(.x)),
          .groups = "drop"
        ) %>%
        group_by(!!sym(x_clmn)) %>%
        summarize(across(c(med, q3, q4, mx), mean)) %>%
        arrange(med, q3, q4, mx) %>%
        pull(x_clmn) %>%
        rev()
      
      plt <- df_in %>%
        mutate(
          x_type    = fct_relevel(!!sym(x_clmn), lvls),
          chikv_grp = fct_relevel(chikv_grp, chikv_grps)
        ) %>%
        ggplot(
          # aes(x_type, !!sym(.x), color = x_type, fill = x_type, alpha = chikv_grp)
          aes(x_type, !!sym(.x), color = x_type, fill = x_type)
        ) +
        geom_boxplot(
          linewidth = 0.5, alpha = 0.5,  # color = "black",
          outlier.size = 0.01, outlier.alpha = 0.1,
          position = position_dodge2(preserve = "single"),
          key_glyph = draw_key_point,
        ) +
        scale_color_manual(values = clrs) +
        scale_fill_manual(values = clrs) +
        scale_alpha_manual(values = c(`CHIKV-low` = 0.5, `CHIKV-high` = 1)) +
        scale_x_discrete(labels = type_lab_fn) +
        facet_wrap(~ tm_treat, ncol = 1) +
        labs(y = str_c(.x, " expression")) +
        guides(
          fill = "none", color = "none",
          alpha = guide_legend(
            override.aes = list(shape = 15, fill = "black", size = 4)
          )
        ) +
        # base_theme +
        djvdj_theme() +
        theme(
          aspect.ratio    = 0.15,
          plot.title      = element_text(hjust = 0.5),
          legend.position = "top",
          legend.title    = element_blank(),
          # legend.text     = element_text(size = txt_pt1),
          axis.title.x    = element_blank(),
          axis.text.x     = element_text(angle = 45, hjust = 1),
          # axis.text.y     = element_text(size = txt_pt1 * 0.75),
          # strip.text      = element_text(size = txt_pt2)
        )
      
      if (.y == 1 && !is.null(ttl)) {
        plt <- plt + ggtitle(ttl)
      }
      
      plt
    })
  
  res
}

.format_pvalue <- function(p, digits = 1, cutoffs = NULL) {

  # Set p label based on vector of cutoffs
  if (!is.finite(p)) return(as.character(NA))

  if (!is.null(cutoffs)) {
    if (any(duplicated(cutoffs))) {
      cli::cli_abort("Cutoff values for p_label must be unique.")
    }

    # Set default labels when not provided by user
    if (is.null(names(cutoffs))) {
      cutoffs <- sort(cutoffs, decreasing = TRUE)

      names(cutoffs) <- purrr::imap_chr(
        cutoffs, ~ paste0(rep("*", .y), collapse = "")
      )
    }

    cutoffs <- sort(cutoffs)
    p_label <- as.character(NA)

    for (val in names(cutoffs)) {
      if (p < cutoffs[val]) {
        p_label <- val

        break()
      }
    }

    # Treat "value" as a keyword that will allow user to display actual
    # p-value for a certain cutoff
    # All custom labels need to be wrapped in quotes for parsing
    if (!identical(p_label, "value")) {
      if (!is.na(p_label)) p_label <- paste0("\'", p_label, "\'")

      return(p_label)
    }
  }

  # Format p-value label
  if (p >= 0.1)    return(as.character(round(p, 1)))
  else if (p == 0) return(as.character(p))

  p <- scales::label_scientific(digits = digits)(p)

  ex <- str_extract_all(p, "[+\\-][0-9]+$")

  p <- sub(paste0("\\", ex, "$"), "", p)

  ex <- as.numeric(ex)
  ex <- as.character(ex)

  p <- sub("e", "*x*10^", p)
  p <- paste0(p, ex)

  p
}

create_example_gene_fig2 <- function(df_in, gns, x_clmn, al_clmn,
                                     plot_lvls = NULL, clrs = lec_type_cols,
                                     ttl = NULL) {
  
  vars <- unique(df_in[[al_clmn]])
  
  p_cuts <- c(0.01, 0.001, 0.0001)
  
  res <- gns %>%
    imap(~ {
      # Calculate p-values
      # ONLY SHOW <0.01
      p_dat <- df_in %>%
        mutate(x_type = !!sym(x_clmn)) %>%
        group_by(x_type) %>%
        filter(n_distinct(!!sym(al_clmn)) == 2) %>%
        summarize(
          p = wilcox.test(
            (!!sym(.x))[!!sym(al_clmn) == vars[1]],
            (!!sym(.x))[!!sym(al_clmn) == vars[2]]
          )$p.value,
          .groups = "drop"
        ) %>%
        filter(!is.na(p)) %>%
        mutate(p_adj = p.adjust(p)) %>%
        rowwise() %>%
        mutate(p_lab = .format_pvalue(p_adj, cutoffs = p_cuts)) %>%
        ungroup()
        # filter(p_adj < 0.01)
      
      # Set plot levels
      lvls <- df_in %>%
        group_by(!!sym(x_clmn), tm_treat) %>%
        summarize(
          n     = n(),
          stats = list(boxplot.stats(!!sym(.x))),
          med   = map_dbl(stats, ~ .x$stats[3]),
          q3    = map_dbl(stats, ~ .x$stats[4]),
          q4    = map_dbl(stats, ~ .x$stats[5]),
          mx    = max(!!sym(.x)),
          .groups = "drop"
        ) %>%
        group_by(!!sym(x_clmn)) %>%
        summarize(across(c(med, q3, q4, mx), mean)) %>%
        arrange(med, q3, q4, mx) %>%
        pull(x_clmn) %>%
        rev()
      
      lvls <- unique(c(plot_lvls, lvls))
      
      # Create boxplots
      plt <- df_in %>%
        mutate(
          x_type    = fct_relevel(!!sym(x_clmn), lvls),
          chikv_grp = fct_relevel(chikv_grp, chikv_grps),
          treatment = fct_relevel(treatment, treats)
        ) %>%
        ggplot(
          aes(x_type, !!sym(.x), color = x_type, fill = x_type, alpha = !!sym(al_clmn))
        ) +
        geom_boxplot(
          linewidth = 0.5,
          outlier.size = 0.2, outlier.alpha = 0.1,
          position = position_dodge2(preserve = "single"),
          key_glyph = draw_key_point,
        ) +
        scale_color_manual(values = clrs) +
        scale_fill_manual(values = clrs) +
        scale_alpha_manual(values = c(mock = 0.25, CHIKV = 0.75)) +
        scale_x_discrete(labels = type_lab_fn) +
        facet_wrap(~ tm, ncol = 1) +
        labs(y = str_c(.x, " expression")) +
        guides(
          fill = "none", color = "none",
          alpha = guide_legend(
            override.aes = list(shape = 15, fill = "black", size = 4)
          )
        ) +
        djvdj_theme() +
        theme(
          # aspect.ratio    = 0.25,
          plot.title      = element_text(hjust = 0.5),
          legend.position = "top",
          legend.title    = element_blank(),
          # legend.text     = element_text(size = txt_pt1),
          axis.title.x    = element_blank(),
          axis.text.x     = element_text(angle = 45, hjust = 1),
          # axis.text.y     = element_text(size = txt_pt1 * 0.75),
          strip.text      = element_text(size = txt_pt2)
        )
      
      # Add p-values
      plt <- plt +
        geom_text(
          aes(y = Inf, fill = NULL, label = p_lab),
          data  = p_dat,
          vjust = 1.5,
          color = "black",
          alpha = 1,
          parse = TRUE,
          size  = 16 / .pt
        ) +
        scale_y_continuous(expand = expansion(c(0.05, 0.15)))
      
      if (.y == 1 && !is.null(ttl)) {
        plt <- plt + ggtitle(ttl)
      }
      
      plt
    })
  
  res
}

#' Fill the upper triangular matrix completely
#' 
#' FROM ENRICHPLOT
#'
#' @param x termsim similarity matrix
#' @param keep GO terms to keep
#' @return a data.frame
#' @noRd
fill_termsim <- function(x, keep = NULL) {
  if (!is.null(keep)) termsim <- x[keep, keep]
  else                termsim <- x
  
  termsim[which(is.na(termsim))] <- 0
  
  termsim2 <- termsim + t(termsim)
  
  for ( i in seq_len(nrow(termsim2))) termsim2[i, i] <- 1
  
  termsim2
}

#' Fetch genes for the provided annotations
fetch_genes <- function(terms, mart) {
  att  <- c("ensembl_gene_id", "external_gene_name")
  names(terms) <- names(terms) %||% rep("go_parent_name", length(terms))
  names(terms)[names(terms) == ""] <- "go_parent_name"

  res <- terms %>%
    imap(~ {
      biomaRt::getBM(
        attributes = att,
        filters    = .y,
        values     = .x,
        mart       = mart
      ) %>%
        pull(external_gene_name)
    }) %>%
    reduce(c) %>%
    unique()

  res
}

#' Identify DEGs
#' 
#' @param so_in Seurat object to use for identifying DEGs
#' @param ident_1 Cell label to use for comparing gene expression
#' @param ident_2 Cell label to compare with ident_1
#' @param pval p-value cutoff for filtering DEGs
#' @param log_fc Vector containing upper and lower fold change cutoffs to use
#' for filtering DEGs
#' @param type_clmn Column in object containing cell types, DEGs will be
#' identified separately for each cell type
#' @param treat_clmn Column in object containing ident_1 and ident_2 labels
#' @param rep_clmn Column in object containing replicate IDs
#' @param exclude_types Vector containing cell types to exclude from analysis
#' @param file Path to output file to use for saving results
get_degs <- function(so_in, ident_1 = "CHIKV", ident_2 = "mock",
                     pval = 0.05, log_fc = c(0.15, Inf),
                     type_clmn = "subtype", treat_clmn = "treatment",
                     rep_clmn = "rep", exclude_types = c("other", "unassigned"),
                     file = NULL) {
  
  Idents(so_in) <- unlist(so_in[[treat_clmn]], use.names = FALSE)
  
  so_in <- so_in %>%
    mutate_meta(mutate, treat_rep = str_c(!!sym(treat_clmn), !!sym(rep_clmn)))
  
  typs <- get_cell_types(so_in, "subtype", "treat_rep")
  typs <- typs[!typs %in% exclude_types]
  
  if (!is.null(file) && file.exists(file)) {
    cli::cli_alert("Loading file {.file {file}}")
    
    return(read_tsv(file))
  }
  
  degs <- typs %>%
    map_dfr(~ {
      so_in %>%
        subset(subtype == .x) %>%
        FindConservedMarkers(
          ident.1         = ident_1,
          ident.2         = ident_2,
          grouping.var    = rep_clmn,
          logfc.threshold = min(abs(log_fc)),
          min.cells.group = 3
        ) %>%
        mutate(subtype = .x) %>%
        as_tibble(rownames = "gene")
    })
  
  reps     <- unique(unlist(so_in[[rep_clmn]], use.names = FALSE))
  fc_clmns <- str_c(reps, "_avg_log2FC")
  
  # Filter DEGs
  degs <- degs %>%
    filter(
      if_all(all_of(fc_clmns), ~ .x > log_fc[1] & .x < log_fc[2]),
      max_pval < pval
    ) %>%
    arrange(max_pval)

  if (!is.null(file)) {
    write_tsv(degs, file)
  }
  
  degs
}

#' Identify GO terms
#' 
#' By default all expressed genes are used as background for the cell type
#' This will include results for all terms regardless of significance, need
#' all terms for creating heatmaps
#' 
#' @param gns Named list of differentially expressed genes for each cell type
#' @param so_in Seurat object so use for determining background gene set
#' @param type_clmn Column in Seurat object containing cell types, these should
#' match the cell types provided by gns
#' @param max_term_size Maximum term size to include in results
#' @param min_term_size Minimum term size to include in results
#' @param db GO database to use, specify 'ALL' to use all three
#' @param simplify_terms Should GO terms be simplified to removed redundant
#' results, this has a significant effect on performance
#' @param n_bkgd Number of top expressed genes to include for the background
#' gene set
#' @param exclude_genes Regular expression to use for removing genes before
#' performing GO analysis
#' @param sim_data Similarity data to use for simplifying GO terms, generated
#' using [clusterProfiler::godata()]
#' @param file Path to output file for saving results
get_go <- function(gns, so_in, type_clmn = "subtype", max_term_size = 750,
                   min_term_size = 10, db = "BP", simplify_terms = TRUE,
                   n_bkgd = Inf, exclude_genes = "^(Rp[sl]|mt-)",
                   sim_data = go_sim_data, file = NULL) {

  # Check for save GO file
  obj_file <- str_c(file, ".qs")
  tbl_file <- str_c(file, ".tsv")
  
  if (!is.null(file) && file.exists(obj_file)) {
    cli::cli_alert("Loading file {.file {obj_file}}")
    
    return(qread(obj_file))
  }
  
  # Identify background gene set for each cell type
  bkgd <- gns %>%
    imap(~ {
      bkgd <- NULL
      
      if (!is.null(so_in)) {
        if (is.character(.y)) bkgd <- subset(so_in, !!sym(type_clmn) == .y)
        else                  bkgd <- so_in
        
        bkgd <- bkgd@assays$RNA@data %>%
          rowMeans() %>%
          sort(decreasing = TRUE) %>%
          head(n_bkgd)
        
        bkgd <- names(bkgd[bkgd > 0])
      }
      
      bkgd
    })
  
  # Identify GO terms for each gene list
  # exclude specified genes
  go <- gns %>%
    imap(~ {
      .x <- .x[!grepl(exclude_genes, .x)]
      
      g <- .x %>%
        enrichGO(
          keyType      = "SYMBOL",
          OrgDb        = org.Mm.eg.db,
          universe     = bkgd[[.y]],
          maxGSSize    = max_term_size,
          minGSSize    = min_term_size,
          pvalueCutoff = 1.1,
          qvalueCutoff = 1.1,
          ont          = db
        )
      
      # Add background genes for each term to object
      # need this to calculate overall fold enrichment for GO clusters
      bkgd_gns <- g@result$ID %>%
        bitr(
          fromType = "GOALL", toType = "SYMBOL",
          OrgDb = org.Mm.eg.db
        ) %>%
        filter(SYMBOL %in% bkgd[[.y]]) %>%
        split(.$GOALL)
      
      bkgd_gns <- bkgd_gns %>%
        map_chr(~ {
          .x$SYMBOL %>%
            unique() %>%
            str_c(collapse = "/")
        })
      
      g %>%
        mutate(bkgdID = bkgd_gns[ID])
    })
  
  # Merge GO objects  
  if (!is.null(names(go))) {
    go <- merge_result(go)
    
    go@fun <- "enrichGO"
    
  } else if (length(go) == 1) {
    go <- go[[1]]
  }
  
  # Simplify terms
  # this collapses terms that are very similar
  if (simplify_terms) {
    go <- go %>%
      clusterProfiler::simplify(semData = sim_data)
  }
  
  # Save results
  if (!is.null(file)) {
    qsave(go, obj_file)
    
    go@compareClusterResult %>%
      write_tsv(tbl_file)
  }
  
  go
}

#' Cluster GO terms
#' 
#' @param go_in Object containing GO results
#' @param k Number of clusters to identify
#' @param pval Cutoff for filtering terms based on adjusted p-value, only
#' significant terms are used for clustering
#' @param qval Cutoff for filtering terms based on q-value
#' @param n_overlap Minimum number of genes needed to overlap term for it to be
#' included for clustering
#' @param n_shared Minimum number of cell types that term has to be shared with
#' for it to be included for clustering
#' @param sim_data Similarity data to use for clustering GO terms, generated
#' using [clusterProfiler::godata()]
get_clusters <- function(go_in, k = 3, pval = 0.05, qval = 0.2, n_overlap = 3,
                         n_shared = 2, sim_data = go_sim_data) {
  
  # Filter GO terms
  # calculate summary stats for each term
  # sort by number of cell types that share the term
  go_in <- go_in %>%
    filter(p.adjust < pval, qvalue < qval, Count >= n_overlap)
  
  top_terms <- go_in@compareClusterResult %>%
    separate(GeneRatio, into = c("n_ovlp", "tot_genes"), sep = "/", convert = TRUE) %>%
    separate(BgRatio, into = c("n_bg_ovlp", "tot_bg_genes"), sep = "/", convert = TRUE) %>%
    mutate(
      GeneRatio  = n_ovlp / tot_genes,
      BgRatio    = n_bg_ovlp / tot_bg_genes,
      enrichment = GeneRatio / BgRatio
    ) %>%
    
    group_by(Description, ID) %>%
    summarize(
      n          = n_distinct(Cluster),  # number of cell types with term
      enrichment = mean(enrichment),      
      p.adjust   = mean(p.adjust),       # mean p-value across cell types
      qvalue     = mean(qvalue),         # mean q-value across cell types
      .groups    = "drop"          
    ) %>%
    arrange(desc(n), p.adjust) %>%
    dplyr::filter(n >= n_shared)

  # Set number of clusters
  # must average > 2 terms per cluster
  if (nrow(top_terms) < 2) return(NULL)
  
  k <- min(k, floor(nrow(top_terms) / 2))
  
  # Calculate similarity metric for top terms
  # fill in upper triangle of matrix and filter terms
  # only include significant terms shared with at least two cell types
  go_dist <- go_in %>%
    pairwise_termsim(semData = sim_data) %>%
    .@termsim %>%
    fill_termsim(keep = top_terms$Description)
  
  # Cluster terms
  # use ward.D method to avoid overlapping ancestor nodes of each group
  hc <- stats::hclust(
    stats::as.dist(1 - go_dist),
    method = "ward.D"
  )
  
  clst_obj <- stats::cutree(hc, k)
  
  clsts <- tibble(
    Description = names(clst_obj),
    cluster     = unname(clst_obj)
  )
  
  # Format output object
  res <- clsts %>%
    left_join(top_terms, by = "Description") %>%
  
    arrange(cluster, desc(n), p.adjust) %>%
    group_by(cluster) %>%
    mutate(
      cluster_n_terms = n_distinct(Description),
      cluster_mean_p  = mean(p.adjust)
    ) %>%
    ungroup() %>%
    arrange(cluster, desc(n), p.adjust)
  
  res <- list(
    clusters = res,
    object   = hc,
    clusters_object = clst_obj
  )
  
  res
}

#' Create heatmaps summarizing GO clusters for each cell type
#' 
#' @param df_in data.frame containing clustering results generated with
#' get_clusters(), this provides the terms and cluster assignments to plot
#' @param go_in Object containing GO results, this is used to plot p-values and
#' GeneRatio for each cell type
#' @param n_clusters Number of top GO clusters to plot, clusters are sorted by
#' number of terms, with the top clusters having the most terms
#' @param n_terms The number of top terms to show for each cluster, terms are
#' sorted by the number of cell types that share the term and the overall mean
#' p-value for the term (averaged across all cell types)
#' @param pval Adjusted p-value cutoff for marking significant terms, this
#' cutoff should match the cutoff used for clustering GO terms
#' @param qval q-value cutoff for marking significant terms
#' @param n_overlap Minimum number of genes needed to overlap the term for it to
#' be marked as significant
#' @param n_genes Minimum number of DEGs for cell type to be included on plot
#' @param clrs Colors to use for each cluster
#' @param n_col Number of columns to use for organizing facets (each cluster is
#' plotted as a separate facet)
#' @param cluster_labels Vector containing descriptive labels for each cluster
create_go_heatmap <- function(df_in, go_in, n_clusters = 2, n_terms = 5,
                              pval = 0.05, qval = 0.2, n_overlap = 3, n_genes = 3,
                              clrs = c("orange", "lightblue", "red"), n_col = 1,
                              include_overall_score = FALSE, free_y = FALSE,
                              cluster_labels = NULL) {
  
  # Top GO terms to plot
  # df_in includes combined GO terms identified across all cell types
  # sort to show shared terms at the top, sort by mean adjusted p-value for term
  top_clusters <- df_in$cluster %>%
    table() %>%
    sort(decreasing = TRUE) %>%
    head(n_clusters) %>%
    names()
  
  n_seq <- seq_len(n_terms)
  
  terms <- df_in %>%
    dplyr::filter(cluster %in% top_clusters) %>%
    mutate(shared = n > 1) %>%
    arrange(cluster, desc(n), desc(enrichment)) %>%
    # arrange(cluster, desc(n), p.adjust) %>%
    # arrange(cluster, desc(shared), p.adjust) %>%
    group_by(cluster) %>%
    dplyr::slice(n_seq) %>%
    ungroup()
  
  n_terms <- terms %>%
    group_by(cluster) %>%
    summarize(n = n_distinct(Description), .groups = "drop") %>%
    pull(n) %>%
    max()
  
  # Data for heatmap
  cluster_ids <- df_in %>%
    dplyr::select(Description, cluster)
  
  agg_lab <- "Overall Enrichment"
  lvls    <- c(agg_lab, rev(terms$Description))
  
  dat <- go_in@compareClusterResult %>%
    as_tibble() %>%
    left_join(cluster_ids, by = "Description") %>%
    filter(cluster %in% top_clusters) %>%
    separate(GeneRatio, into = c("n_ovlp", "tot_genes"), sep = "/", convert = TRUE) %>%
    separate(BgRatio, into = c("n_bg_ovlp", "tot_bg_genes"), sep = "/", convert = TRUE) %>%
    mutate(
      GeneRatio  = n_ovlp / tot_genes,
      BgRatio    = n_bg_ovlp / tot_bg_genes,
      enrichment = GeneRatio / BgRatio
    )
  
  # Calculate aggregated fraction overlap
  # only show cell types with >= 10 overlapping genes
  agg_dat <- dat
  
  if (!include_overall_score) {
    agg_dat <- agg_dat %>%
      filter(Description %in% terms$Description)
  }
  
  agg_dat <- agg_dat %>%
    mutate(
      geneID = str_split(geneID, "/"),
      bkgdID = str_split(bkgdID, "/")
    ) %>%
    group_by(Cluster, cluster, tot_genes, tot_bg_genes) %>%
    summarize(
      tot_ovlp    = n_distinct(reduce(geneID, c)),
      tot_bg_ovlp = n_distinct(reduce(bkgdID, c)),
      .groups     = "drop"
    ) %>%
    mutate(
      GeneRatio   = tot_ovlp / tot_genes,
      BgRatio     = tot_bg_ovlp / tot_bg_genes,
      enrichment  = GeneRatio / BgRatio,
      Description = agg_lab
    ) %>%
    filter(tot_genes >= n_genes)
  
  # If not including overall score sort based on terms shown
  typ_lvls <- agg_dat %>%
    arrange(desc(enrichment)) %>%
    mutate(Cluster = fct_inorder(as.character(Cluster))) %>%
    pull(Cluster) %>%
    levels() 
  
  dat <- dat %>%
    filter(
      Description %in% terms$Description,
      Cluster %in% typ_lvls
    )
  
  if (include_overall_score) {
    dat <- dat %>%
      bind_rows(agg_dat)
  }
  
  dat <- dat %>%
    mutate(Description = fct_relevel(Description, lvls)) %>%
    arrange(Description) %>%
    mutate(
      Description = str_trunc(as.character(Description), width = 70, side = "right"),
      Description = str_wrap(Description, width = 40),
      Description = fct_inorder(Description),
      Cluster     = fct_relevel(Cluster, typ_lvls)
    )
  
  ## THIS COULD BE USED TO CALCULATE COMBINED SIGNIFICANCE
  # Fill in missing values
  # these are terms with 0 overlapping genes for the cell type
  # assign p-value of 1 and gene ratio of 0
  # dat <- dat %>%
  #   complete(
  #     crossing(Description, Cluster),
  #     fill = list(GeneRatio = 0, p.adjust = 1)
  #   )
  # 
  # dat %>%
  #   group_by(Cluster) %>%
  #   summarize(
  #     n = length(p.adjust[p.adjust < 0.05]),
  #     frac = n / n(),
  #     
  #     GeneRatio = mean(GeneRatio),
  #     meanp     = (metap::meanp(p.adjust))$p,
  #     fisher    = (metap::sumlog(p.adjust))$p,
  #     wilk      = (metap::maximump(p.adjust))$p,
  #     p.adjust  = mean(p.adjust)
  #   )
    
  # Data for significant terms for each cell type
  # this differs from df_in, since df_in does not contain p-values for each
  # cell type, just mean p-values summarizing overall significance across
  # all cell types
  p_dat <- dat %>%
    dplyr::filter(p.adjust < pval, qvalue < qval, Count >= n_overlap) %>%
    mutate(enriched = "Significant")
  
  # Create heatmap
  # ggplot(aes(Cluster, Description, fill = as.character(cluster), alpha = -log10(p.adjust))) +
  agg_fn <- function(x) {
    new_agg <- str_replace_all(agg_lab, " ", "~")
    new_agg <- str_c("bold(", new_agg, ")")
    
    x[x == agg_lab] <- parse(text = new_agg)
    x
  }
  
  if (!include_overall_score) agg_fn <- ggplot2::waiver()
  
  res <- dat %>%
    ggplot(aes(Cluster, Description, fill = as.character(cluster), alpha = enrichment)) +
    geom_tile() +
    geom_point(
      aes(color = enriched, fill = NULL),
      data   = p_dat,
      alpha  = 1,
      shape  = 5,
      size   = 2,
      stroke = 0.75
    ) +
    scale_alpha_continuous(range = c(0, 1), n.breaks = 6) +
    scale_color_manual(values = "black") +
    scale_fill_manual(values = clrs) +
    scale_y_discrete(labels = agg_fn) +
    guides(
      alpha = guide_legend(
        keyheight      = unit(7, "pt"),
        label.position = "bottom",
        order          = 1,
        title          = "Enrichment Score",
        title.position = "top",
        nrow           = 1
      ),
      color = guide_legend(
        title = NULL,
        label.position = "top",
        label.theme = element_text(size = 11),
        override.aes = list(size = 3, stroke = 1)
      ),
      fill = "none"
    ) +
    djvdj_theme() +
    theme(
      legend.position = "bottom",
      legend.title    = element_text(hjust = 0.5),
      axis.title      = element_blank(),
      axis.text.x     = element_text(angle = 45, hjust = 1),
      strip.clip      = "off"
    )
  
  if (include_overall_score) {
    res <- res +
      geom_hline(yintercept = 1.5, size = 1.5, color = "white")
  }
  
  if (free_y) {
    res <- res +
      facet_grid(
        rows = "cluster",
        scales = "free_y", space = "free_y",
        labeller = cluster_labels %||% "label_value"
      )
  } else {
    res <- res +
      facet_wrap(
        ~ cluster, ncol = n_col, scales = "free_y",
        labeller = cluster_labels %||% "label_value"
      ) +
      theme(aspect.ratio = n_terms / n_distinct(dat$Cluster))
  }
  
  res <- list(
    heatmap = res,
    terms = terms
  )
  
  res
}

#' Create line graphs plotting mean expression of upregulated genes
#' 
#' @param exp_data Named list of Seurat objects containing expression data to
#' plot
#' @param deg_data Named list of data.frames containing DEGs, this is used to
#' determine which genes are upregulated for each cell type and timepoint, the
#' names need to match the names provided for exp_data
#' @param gns Named vector specifying genes to plot, the names should be the
#' gene symbol and the values should be the cluster ID. Genes can be colored
#' based on cluster ID
#' @param clrs Colors to use for each cluster
#' @param cell_types The number of top cell types to include, cell types with
#' the most upregulated genes will be included. Alternatively a vector of cell
#' types to include can be provided.
#' @param lvls Levels to use for ordering values in treatment column
#' @param n_cells Number of cells that must be present for each replicate of
#' each treatment group for a line to be shown for the timepoint/cell type
#' @param only_show_upreg Only show cell types with at least one gene
#' upregulated for any of the timepoints
create_gene_plots <- function(exp_data = list("8hpi" = so_8, "24hpi" = so_merge),
                              deg_data =  list("8hpi" = degs$`so_8-up`, "24hpi" = degs$`so_merge-up`),
                              gns,
                              clrs = c(`1` = "orange"), cell_types = 8,
                              lvls = c("mock", "8hpi", "24hpi"), n_cells = 10,
                              type_clmn = "subtype", only_show_upreg = TRUE) {
  
  # Genes to plot
  genes <- names(gns)
  
  # Format gene expression input data
  exp_data <- exp_data %>%
    imap_dfr(~ {
      .x %>%
        FetchData(c(type_clmn, "orig.ident", "treatment", "rep", genes)) %>%
        as_tibble(rownames = ".cell_id") %>%
        mutate(tm = .y) %>%
        pivot_longer(all_of(names(gns)))
    }) %>%
                                                     # only use mock data and 8hpi data from 8hpi object
    filter(treatment != "8hpi" | tm != "24hpi") %>%  # exclude 8hpi CHIKV data from 24hpi objects (e.g. so_merge)
    filter(tm == "8hpi" | treatment != "mock") %>%   # exclude mock data from 24hpi objects (e.g. so_24)
                                                     # redefine treatment as mock or tm
    
    filter(!(!!sym(type_clmn)) %in% c("other", "unassigned")) %>%  # do not show other and unassigned cells
    mutate(treatment = ifelse(treatment %in% lvls, treatment, tm))
    
  # Only include samples with >10 cells for each replicate
  exp_data <- exp_data %>%
    group_by(!!sym(type_clmn), treatment) %>%
    mutate(reps = list(unique(rep))) %>%
    group_by(!!sym(type_clmn), treatment, rep) %>%
    filter(n_distinct(.cell_id) >= n_cells) %>%
    
    group_by(!!sym(type_clmn), treatment) %>%
    filter(all(unique(unlist(reps)) %in% rep)) %>%
    group_by(!!sym(type_clmn), name) %>%
    filter(n_distinct(treatment) > 1) %>%
    ungroup()
  
  # Format DEG input data
  deg_data <- deg_data %>%
    imap_dfr(~ {
      .x %>%
        dplyr::filter(gene %in% genes) %>%
        dplyr::mutate(treatment = .y) %>%
        dplyr::select(gene, treatment, !!sym(type_clmn), max_pval)
    })
  
  # Filter for top cell types to plot
  if (!is.null(cell_types)) {
    if (is.numeric(cell_types)) {
      cell_types <- deg_data %>%
        group_by(!!sym(type_clmn)) %>%
        summarize(n_genes = n(), .groups = "drop") %>%
        arrange(desc(n_genes)) %>%
        head(cell_types) %>%
        pull(type_clmn)
    }
    
    exp_data <- exp_data %>%
      dplyr::filter(!!sym(type_clmn) %in% cell_types)
  }
  
  # Format data for plotting points
  plt_dat <- exp_data %>%
    group_by(!!sym(type_clmn), treatment, name) %>%
    summarize(
      n       = n(),
      q3      = quantile(value, 0.75),
      q1      = quantile(value, 0.25),
      value   = median(value),
      .groups = "drop"
      # sd      = sd(value),
      # err     = qt(0.975, df = n - 1) * (sd / sqrt(n)),  # 95% CI
    ) %>%
    mutate(
      x_end     = match(treatment, lvls),
      x         = x_end - 1,
      treatment = fct_relevel(treatment, lvls),
      cluster   = gns[name],
      name      = fct_relevel(name, genes)
    )
  
  # Format data for plotting lines
  # only plot cell types with at least one gene upregulated
  # plot as segments so linetype can be varied based on significance
  # need to pull table of DEGs to determine which timepoints/genes are signif
  # pull median expression to use for the start and end of each segment
  exp_dat <- plt_dat %>%
    dplyr::select(name, treatment, !!sym(type_clmn), value)
  
  ln_dat <- plt_dat %>%
    left_join(deg_data, by = c(name = "gene", "treatment", type_clmn)) %>%
    
    dplyr::filter(x > 0) %>%  # remove rows that start at 0 (occurs for mock)
    
    # need to set columns with treatment labels for segment start/end so
    # correct expression values can be pulled
    mutate(trt_end = lvls[x_end], trt_start = lvls[x]) %>%
    
    dplyr::select(
      name, treatment, !!sym(type_clmn), cluster,
      x, x_end, trt_start, trt_end,
      max_pval
    ) %>%
    
    left_join(exp_dat, by = c("name", trt_start = "treatment", type_clmn)) %>%
    dplyr::rename(y = value) %>%
    
    left_join(exp_dat, by = c("name", trt_end = "treatment", type_clmn)) %>%
    dplyr::rename(y_end = value) %>%
    
    mutate(
      Upregulated = as.character(!is.na(max_pval)),
      Upregulated = fct_relevel(Upregulated, c("TRUE", "FALSE")),
      name        = fct_relevel(name, genes)
    )
  
  # Only show cell types with at least one gene upregulated for any timepoint
  if (only_show_upreg) {
    ln_dat <- ln_dat %>%
      group_by(!!sym(type_clmn)) %>%
      filter(any(Upregulated == "TRUE")) %>%
      ungroup()
  }
  
  # Create plots
  aspect <- length(genes) / n_distinct(plt_dat$name) * 0.9
  
  res <- plt_dat %>%
    filter(!!sym(type_clmn) %in% unique(pull(ln_dat, type_clmn))) %>%
    ggplot(aes(treatment, value, color = cluster)) +
    
    geom_errorbar(
      aes(x = treatment, ymin = q1, ymax = q3),
      color = "grey90",
      width = 0,
      linewidth = 1.5
    ) +
    geom_point(size = 1.5) +
    geom_segment(
      aes(
        x = x, xend = x_end, y = y, yend = y_end,
        linetype = Upregulated
      ),
      linewidth = 0.75,
      data  = ln_dat
    ) +
    facet_grid(as.formula(str_c("name ~ ", typ_clmn)), switch = "y", scales = "free_y") +
    
    scale_linetype_manual(values = c("TRUE" = 1, "FALSE" = 3)) +
    scale_color_manual(values = clrs) +
    scale_y_continuous(
      breaks = (function(x) return(c(0, floor(max(x))))),
      expand = expansion(c(0.2, 0.05))
    ) +
    scale_x_discrete(labels = c(mock = "m", `8hpi` = "8h", `24hpi` = "24h")) +
    guides(
      color = "none",
      linetype = guide_legend(title.position = "top", title.hjust = 0.5)
    ) +
    
    djvdj_theme() +
    theme(
      aspect.ratio    = aspect,
      legend.position = "bottom",
      legend.title    = element_text(hjust = 0.5),
      strip.clip      = "off",
      strip.placement = "outside",
      axis.title      = element_blank()
    )
  
  res
}
```

```{r "references"}
# Immgen reference
ref_immgen_new <- ref_fib[, "PvC", drop = FALSE]
ref_immgen_new <- ref_immgen_new[rownames(ref_immgen_new) %in% rownames(ref_immgen), , drop = FALSE]
ref_immgen     <- ref_immgen[rownames(ref_immgen_new), ]

stopifnot(identical(rownames(ref_immgen), rownames(ref_immgen_new)))

ref_immgen_new <- cbind(ref_immgen, ref_immgen_new)

# LEC reference
ref_lec <- ref_immgen[, grepl("^Endothelial cells", colnames(ref_immgen))]
ref_lec <- ref_lec[rownames(ref_lec) %in% rownames(ref_LEC_xiang), ]

colnames(ref_lec) <- colnames(ref_lec) %>%
  str_replace("Endothelial cells \\(BEC\\)", "BEC")

ref_LEC_xiang <- ref_LEC_xiang[rownames(ref_lec), ]

stopifnot(identical(rownames(ref_LEC_xiang), rownames(ref_lec)))

ref_lec <- cbind(ref_LEC_xiang, ref_lec)
ref_lec <- ref_lec[, !grepl("^Endothelial cells", colnames(ref_lec))]

# Fibroblast/stromal cell reference
ref_fib <- ref_immgen[, grepl("^Fibroblast", colnames(ref_immgen))]
ref_fib <- ref_fib[rownames(ref_fib) %in% rownames(ref_lymphnodestromal), ]

ref_lymphnodestromal <- ref_lymphnodestromal[rownames(ref_fib), ]

stopifnot(identical(rownames(ref_lymphnodestromal), rownames(ref_fib)))

ref_fib <- cbind(ref_lymphnodestromal, ref_fib)
```

```{r "broad cell types"}
# Merge 8 and 24 hpi objects
so_8  <- qread(so_8_dir)
so_24 <- qread(so_24_dir)

so_merge <- merge(so_8, so_24) %>%
  FindVariableFeatures(nfeatures = 2000) %>%
  ScaleData() %>%
  RunPCA() %>%
  RunUMAP(dims = 1:40)
  
# Integrate samples
so_merge <- so_merge %>%
  mutate_meta(
    mutate,
    integration_var = ifelse(
      tm == "24hpi" & treatment == "CHIKV",
      "chikv_24hpi", "other"
    )
  ) %>%
  RunHarmony(
    c("rep", "integration_var"),
    dims = 1:40, plot_convergence = TRUE
  ) %>%
  RunUMAP(
    dims = 1:40,
    reduction      = "harmony",
    reduction.name = "humap",
    reduction.key  = "hUMAP_"
  ) %>%
  FindNeighbors(reduction = "harmony", dims = 1:40) %>%
  FindClusters(resolution = 5:10)

# Classify broad cell types
# Manually classified B cells and T cells
type_clst <- str_c("RNA_snn_res.", params$type_res)

b_genes <- list("B cells" = "Cd19")
t_genes <- list("T cells" = "Cd3e")

so_merge <- so_merge %>%
  mutate_meta(dplyr::select, -c(UMAP_1, UMAP_2)) %>%
  clustify(
    ref_mat     = ref_immgen,
    cluster_col = type_clst,
    threshold   = 0.6,
    n_genes     = 2000,
    rename_prefix = "rough"
  ) %>%
  classify_mod_score(    # B cells
    feats    = b_genes,
    prefix   = "b",
    cutoff   = 0.2,
    clst_col = type_clst,
    type_col = "rough_type"
  ) %>%
  classify_mod_score(    # T cells
    feats    = t_genes,
    prefix   = "t",
    cutoff   = 0.5,
    clst_col = type_clst,
    type_col = "rough_type"
  )

# Manually adjust some clusters based on Pdpn and Pecam1 expression
# Set 30, 34, 91, 99, 114, 147, as FRCs
frc_clsts <- c(30, 34, 91, 99, 114, 147)

so_merge <- so_merge %>%
  mutate_meta(
    mutate,
    rough_type = ifelse(
      !!sym(type_clst) %in% frc_clsts,
      "Fibroblasts", rough_type
    )
  )

so_merge <- so_merge %>%
  mutate_meta(
    mutate,
    cell_type = str_remove(rough_type, " \\(.+$"),
  )
```

```{r "fibroblast subsets"}
# Recluster fibroblasts and annotate PvCs
so_fib <- so_merge %>%
  subset(cell_type %in% fib_cell_types) %>%
  FindVariableFeatures(nfeatures = 2000) %>%
  ScaleData() %>%
  RunPCA() %>%
  RunUMAP(dims = 1:40)
  
so_fib <- so_fib %>%
  mutate_meta(
    mutate,
    integration_var = ifelse(
      tm == "24hpi" & treatment == "CHIKV",
      "chikv_24hpi", "other"
    )
  ) %>%
  RunHarmony(
    c("rep", "integration_var"),
    dims = 1:40, plot_convergence = TRUE
  ) %>%
  RunUMAP(
    dims = 1:40,
    reduction      = "harmony",
    reduction.name = "humap",
    reduction.key  = "hUMAP_"
  ) %>%
  FindNeighbors(reduction = "harmony", dims = 1:40) %>%
  FindClusters(resolution = 1:5)

# Set PvCs
# Integration is not great for Cxcl9+ TRCs
# Works good for PvCs
fib_clst <- str_c("RNA_snn_res.", params$fib_res)

so_fib <- so_fib %>%
  mutate_meta(dplyr::select, -starts_with("UMAP_"), -fib_type) %>%
  clustify(
    ref_mat       = ref_fib,
    cluster_col   = fib_clst,
    rename_prefix = "fib",
    n_genes       = 2000,
    threshold     = 0.65
  ) %>%
  mutate_meta(
    mutate,
    cell_type = ifelse(fib_type == "Pvc", fib_type, "FRC")
  )

so_merge <- so_merge %>%
  AddMetaData(FetchData(so_fib, "fib_type")) %>%
  mutate_meta(
    mutate,
    cell_type = case_when(
      fib_type == "PvC" & !is.na(fib_type) ~ fib_type,
      !is.na(fib_type)                     ~ "FRC",
      TRUE                                 ~ cell_type
    )
  )
```



```{r "prepare objects"}
# Create new merged LEC object
create_obj <- !file.exists(file.path(params$so_dir, "so_lec_annotations_2.qs"))

# Directories to save modified objects
so_8_dir  <- here(params$so_dir, "so_8.qs")
so_24_dir <- here(params$so_dir, "so_24.qs")

lec_cell_types <- "Endothelial cells"
fib_cell_types <- c("Fibroblasts", "Stromal cells", "Stromal cells (DN)")

# Replace this with setup.Rmd that has code used to process each sample
if (!file.exists(so_24_dir) || !file.exists(so_8_dir) && create_obj) {
  so_8  <- read_rds(file.path(params$orig_so_dir, "2021-07-16/sobjs/so.rds"))
  so_24 <- read_rds(file.path(params$orig_so_dir, "2021-01-08/sobjs/so.rds"))
  
  # Adjust 24 hpi
  # Add PvCs to cell types
  # This is based on clustifyr results using ref_lymphnodestromal, and Pecam1,
  # Pdpn, Itga7, and Acta2 expression
  so_24 <- so_24 %>%
    mutate_meta(
      mutate,
      cell_type = case_when(
        fib_type == "PvC"             ~ fib_type,
        cell_type %in% fib_cell_types ~ "FRC",
        TRUE                          ~ cell_type
      )
    )
  
  so_24 <- so_24 %>%
    mutate_meta(
      mutate,
      lec_subtype = recode(lec_subtype, unassigned = "unassigned-LEC"),
      lec_type = case_when(
        cell_type %in% lec_cell_types ~ lec_subtype,
        TRUE                          ~ cell_type
      )
    )
  
  so_24 <- so_24 %>%
    mutate_meta(
      mutate,
      subtype = ifelse(lec_subtype == "other", fib_subtype, lec_subtype)
    )
  
  so_24 <- so_24 %>%
    mutate_meta(
      mutate,
      chikv_type = if_else(chikv_grp == chikv_grps[2], lec_type, chikv_grp),
      tm = "24hpi"
    )
  
  # Adjust 8 hpi
  # Cluster 27 appears to be FRCs based on Pdpn, Pecam1, and Pdgfra
  # Adjust subtype column
  so_8 <- so_8 %>%
    mutate_meta(
      mutate,
      fib_type = if_else(fib_subtype == "other", cell_type, fib_subtype),
      cell_type = case_when(
        fib_type == "PvC"             ~ fib_type,
        cell_type %in% fib_cell_types ~ "FRC",
        TRUE                          ~ cell_type
      )
    )
  
  so_8 <- so_8 %>%
    mutate_meta(
      mutate, 
      orig.ident = str_c(treatment, "-", rep),
      lec_type = case_when(
        lec_subtype == "unassigned"   ~ lec_subtype,  # replace unassigned-LEC label
        cell_type %in% lec_cell_types ~ lec_subtype,
        TRUE                          ~ cell_type
      ),
      chikv_grp = ifelse(tot_nCount_CHIKV > 0, chikv_grps[2], chikv_grps[1])
    )
  
  so_8 <- so_8 %>%
    mutate_meta(
      mutate,
      subtype = ifelse(lec_subtype == "other", fib_subtype, lec_subtype)
    )
  
  ### NEED TO UPDATE THIS FOR SUBTYPES ###
  # add cluster to so_fib, re-cluster, re-annotate
  so_8 <- so_8 %>%
    mutate_meta(
      mutate,
      lec_type  = ifelse(RNA_snn_res.5 == "27", "FRC", lec_type),
      cell_type = ifelse(RNA_snn_res.5 == "27", "FRC", cell_type)
    )
  
  # Save objects
  qsave(so_8, so_8_dir)
  qsave(so_24, so_24_dir)
  
  rm(so_8, so_24)
}

# This is used for setting cell type colors
so_8  <- qread(so_8_dir)
so_24 <- qread(so_24_dir)

so_merge_df <- bind_rows(so_8@meta.data, so_24@meta.data)

# Set levels
sam_lvls <- unique(so_24$orig.ident)
treats   <- unique(so_24$treatment)

if (!create_obj) {
  so_lec_merge <- qread(file.path(params$so_dir, "so_lec_annotations_2.qs"))
  
  rm(so_8, so_24)
}
```

```{r "theme"}
# ggplot2 themes
txt_pt1  <- 10
txt_pt2  <- 12
ttl_pt1  <- 14
ttl_pt2  <- 16
ln_pt    <- 0.5
ln_col   <- "grey85"
cir_size <- 3.5
sqr_size <- 4

txt_theme_1 <- theme(
  strip.text  = element_text(size = ttl_pt2),
  legend.text = element_text(size = txt_pt2),
  axis.title  = element_text(size = ttl_pt2),
  axis.text   = element_text(size = txt_pt2)
)

line_theme <- theme(
  axis.line.x  = element_line(linewidth = ln_pt, color = ln_col),
  axis.line.y  = element_line(linewidth = ln_pt, color = ln_col),
  axis.ticks.x = element_line(linewidth = ln_pt, color = ln_col),
  axis.ticks.y = element_line(linewidth = ln_pt, color = ln_col)
)

base_theme <- djvdj_theme() +
  theme(
    plot.title       = element_text(face = "plain", size = ttl_pt2),
    strip.background = element_blank(),
    strip.text       = element_text(face = "plain")
  ) +
  txt_theme_1

umap_theme <- base_theme +
  theme(
    panel.border = element_rect(color = NA, fill = NA),
    axis.title   = element_blank(),
    axis.line.x  = element_blank(),
    axis.line.y  = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text    = element_blank()
  )

fade_0 <- "#FAFAFA"
fade_1 <- "#F0F0F0"
fade_2 <- "#D9D9D9"

hist_y_lab <- "number of cells"

# alpha for plots
al <- 0.7

# Okabe Ito color palettes
ito_cols <- c(
  palette_OkabeIto[c(1:3, 5)], "#D7301F",
  palette_OkabeIto[c(4, 6)],   "#6A51A3",
  palette_OkabeIto[7],         "#875C04",
  "#065D43", "#F7AF34", "#00446E"
)

ito_cols <- ito_cols[3:length(ito_cols)] %>%
  darken(0.2) %>%
  c(ito_cols, ., "#686868", "#000000")

# Set sample colors
get_cols <- create_col_fun(ito_cols)

sam_cols <- c(
  # "#F03B20", "#FD8D3C",
  "#BD0026", "#FECC5C", "#FFFFB2",
  # "#0072B2", "#56B4E9",
  "#00446E", "#035B8F", "#2A8FBF"
)

names(sam_cols) <- sam_lvls

# CHIKV treatment groups
chikv_infctd <- so_merge_df %>%
  group_by(treatment) %>%
  summarize(mn = mean(nCount_CHIKV), .groups = "drop") %>%
  filter(mn == max(mn)) %>%
  pull(treatment)

# Cell type colors
type_cols <- unique(so_merge_df$cell_type)
type_cols <- set_names(ito_cols[seq_along(type_cols)], type_cols)

type_cols["unassigned"] <- "#999999"

subtype_cols <- c(colnames(ref_lec), colnames(ref_fib))
subtype_cols <- set_names(ito_cols[seq_along(subtype_cols)], subtype_cols)
subtype_cols["unassigned"] <- "#999999"
subtype_cols["other"]      <- fade_0
subtype_cols["CD34+ SC"]   <- "#534379"

# lec_type_cols <- c(subtype_cols, type_cols[names(type_cols) != "unassigned"])
# lec_type_cols["CHIKV-low"]      <- "white"
# lec_type_cols["T cells"]        <- "black"
# lec_type_cols["B cells"]        <- "#875C04"
# lec_type_cols["FRC"]            <- "#00375B"
# lec_type_cols["PvC"]            <- "#065D43"
# lec_type_cols["unassigned-LEC"] <- "#676767"
# 
# lec_type_cols <- so_merge_df %>%
#   pull(lec_type) %>%
#   table() %>%
#   sort(decreasing = TRUE) %>%
#   names()
# 
# lec_type_cols <- lec_type_cols[lec_type_cols != "unassigned"]
# 
# lec_type_cols <- set_names(
#   ito_cols[seq_along(lec_type_cols)],
#   lec_type_cols
# )
# 
# lec_type_cols["unassigned"] <- "grey70"
# 
# old_cols <- lec_type_cols
# 
# lec_type_cols["FRC"]   <- old_cols["Valve"]
# lec_type_cols["Valve"] <- old_cols["fLEC"]
# lec_type_cols["fLEC"]  <- old_cols["FRC"]

lec_type_cols <- unique(so_lec_merge$lec_type)
lec_type_cols <- lec_type_cols[!grepl("^unassigned", lec_type_cols)]

lec_type_cols <- set_names(palette_OkabeIto_black, lec_type_cols)

lec_type_cols["unassigned"]     <- "grey85"
lec_type_cols["unassigned-LEC"] <- "grey70"

# CHIKV clusters colors
grp_cols <- set_names(
  c("#56B4E9", "#0072B2"),
  chikv_grps
)

n_reps <- n_distinct(so_merge_df$rep)

grp_rep_cols <- grp_cols %>% 
  imap(~ set_names(
    rep(.x, n_reps),
    str_c(.y, "-", 1:n_reps)
  )) %>%
  flatten_chr()

# Vectors to modify cell type labels for plotting
new_cell_labs <- c(
  Valve      = "Valve LEC",
  Collecting = "Collecting LEC",
  Ptx3_LEC   = "Ptx3 LEC"
)

marco_expr <- c(Marco_LEC = "\"Marco\"^\"+\"*\" LEC\"")
```

```{r "test lec annotations", eval = create_obj}
# Create LEC objects
# * use original broad cell types based on clustering resolution 5
# * merge 8hpi and 24hpi LECs and BECs, re-cluster
# * integrate replicates and integrate 24hpi CHIKV sample with all other samples
# * key issue with past attempts to perform integrated analysis is that
#   integration does not work well when BECs are excluded
so_lec_merge <- so_merge %>%
  subset(cell_type %in% lec_cell_types) %>%
  mutate_meta(
    mutate,
    integration_var = ifelse(
      tm == "24hpi" & treatment == "CHIKV",
      "chikv_24hpi",
      "other"
    )
  ) %>%
  FindVariableFeatures(nfeatures = 2000) %>%
  ScaleData() %>%
  RunPCA() %>%
  RunHarmony(
    c("rep", "integration_var"),
    dims = 1:40, plot_convergence = TRUE
  ) %>%
  RunUMAP(reduction = "harmony", dims = 1:40)

# # TESTING SEURAT INTEGRATION
# so_lec <- so_lec %>%
#   map(~ {
#     .x %>%
#       SplitObject("treatment") %>%
#       map(~ {
#         .x %>%
#           NormalizeData() %>%
#           FindVariableFeatures(nfeatures = 2000)
#       })
#   }) %>%
#   flatten()
# 
# int_features <- so_lec %>%
#   SelectIntegrationFeatures()
# 
# int_anchors <- so_lec %>%
#   FindIntegrationAnchors(anchor.features = int_features)
# 
# so_int <- IntegrateData(anchorset = int_anchors)
# 
# DefaultAssay(so_int) <- "integrated"
# 
# so_int <- so_int %>%
#   ScaleData() %>%
#   RunPCA() %>%
#   RunUMAP(reduction = "pca", dims = 1:40)
# 
# so_int %>%
#   plot_scatter("lec_type", size = 0.5) +
#   facet_grid(tm ~ treatment)

# Parameters to test
# get LEC annotations using 100 different settings
# vary clustering resolution and number of genes used for calculating
# correlations
resolutions <- seq(3, 15, 0.5)
n_genes     <- seq(500, 2000, 500)
obj         <- "all"
met         <- "spearman"
bulk        <- "mean"
clst_params <- as.list(expand_grid(resolutions, n_genes, obj, met, bulk))

so_lec_merge <- so_lec_merge %>%
  FindNeighbors(reduction = "harmony", dims = 1:40) %>%
  FindClusters(resolution = resolutions)

# # To only use mock expression for annotations
# so_mock <- so_lec_merge %>%
#   mutate_meta(dplyr::select, -any_of(c("type", "r", "UMAP_1", "UMAP_2"))) %>%
#   subset(treatment == "mock")

# Annotate LEC subsets for each set of parameters
# return data.frame with summary stats for each
cluster_param_results <- clst_params %>%
  pmap_dfr(~ {
    args  <- list(...)
    rsln  <- args$resolutions
    n_gns <- args$n_genes
    
    # Annotate cell types
    clmn <- str_c("RNA_snn_res.", rsln)
    
    if (args$obj == "mock") obj <- so_mock
    else                    obj <- so_lec_merge
    
    typs <- obj %>%
      clustify(
        ref_mat     = ref_lec,
        cluster_col = clmn,
        n_genes     = n_gns,
        threshold   = 0.55,
        # threshold   = 0.6,
        compute_method    = args$met,
        pseudobulk_method = args$bulk
      )
    
    typs <- typs@meta.data %>%
      distinct(!!sym(clmn), type)
    
    typs <- set_names(typs$type, as.character(pull(typs, clmn)))
    
    so_lec_merge <- so_lec_merge %>%
      mutate_meta(mutate, type = typs[as.character(!!sym(clmn))])
    
    # Calculate stats
    res <- so_lec_merge %>%
      FetchData(c("type", "tm", "treatment", "chikv_grp", "Marco", "Madcam1", clmn)) %>%
      as_tibble(rownames = ".cell_id")
    
    frac_few <- table(res[[clmn]])
    frac_few <- frac_few[frac_few < 100]
    n_few    <- sum(frac_few)
    frac_few <- n_few / nrow(res)
    
    typ <- res %>%
      group_by(tm, treatment, type) %>%
      summarize(n_type = n(), .groups = "drop") %>%
      group_by(tm, treatment) %>%
      mutate(frac_type = n_type / sum(n_type)) %>%
      ungroup()
    
    chikv <- res %>%
      filter(tm == "24hpi", treatment == "CHIKV", chikv_grp == "CHIKV-high") %>%
      group_by(type) %>%
      summarize(n_chikv = n(), .groups = "drop") %>%
      mutate(frac_chikv = n_chikv / sum(n_chikv)) %>%
      ungroup()
    
    marks <- res %>%
      group_by(tm, treatment, type) %>%
      summarize(
        Marco_mn    = mean(Marco),
        Marco_med   = median(Marco),
        Madcam1_mn  = mean(Madcam1),
        Madcam1_med = median(Madcam1),
        .groups = "drop"
      ) %>%
      group_by(tm, treatment) %>%
      summarize(
        Marco_mn    = type[Marco_mn == max(Marco_mn)],
        Marco_med   = type[Marco_med == max(Marco_med)],
        Madcam1_mn  = type[Madcam1_mn == max(Madcam1_mn)],
        Madcam1_med = type[Madcam1_med == max(Madcam1_med)],
        .groups = "drop"
      )
    
    typ_diff <- so_lec_merge@meta.data %>%
      group_by(tm, treatment, lec_type) %>%
      summarize(n_old_type = n(), .groups = "drop")

    res <- typ %>%
      full_join(chikv, by = "type") %>%
      full_join(marks, by = c("tm", "treatment")) %>%
      full_join(typ_diff, by = c("tm", "treatment", c(type = "lec_type"))) %>%
      mutate(
        rsln     = clmn,
        n_genes  = args$n_genes,
        obj      = args$obj,
        type_key = list(typs),
        n_small_clusters    = n_few,
        frac_small_clusters = frac_few
      ) %>%
      rowwise() %>%
      mutate(
        frac_old_diff = abs(diff(c(n_type, n_old_type))) / n_old_type
      ) %>%
      ungroup()
    
    res
  })
```

```{r "determine consensus annotations", eval = create_obj}
# Determine consensus annotations
# determine which cell type annotations are most consistent for each cell
ann_key <- cluster_param_results %>%
  distinct(type_key, rsln, n_genes, obj) %>%
  mutate(id = row_number())

ann_df <- so_lec_merge@meta.data %>%
  as_tibble(rownames = ".cell_id") %>%
  dplyr::select(.cell_id, starts_with("RNA_snn_res."), "tm", "orig.ident", "treatment", "lec_type")

ann_key %>%
  pwalk(~ {
    args <- list(...)
    
    new_clmn <- str_c("type-", args$rsln, "-", args$n_genes)
    
    ann_df <<- ann_df %>%
      mutate(!!sym(new_clmn) := args$type_key[as.character(!!sym(args$rsln))])
  })

ann_stats <- ann_df %>%
  dplyr::select(.cell_id, starts_with("type-")) %>%
  pivot_longer(starts_with("type-")) %>%
  
  group_by(.cell_id) %>%
  summarize(
    count = list(table(value)),
    n = n(),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    top_ann  = names(head(sort(count, decreasing = TRUE), 1)),
    sec_ann  = names(tail(head(sort(count, decreasing = TRUE), 2), 1)),
    top_n    = max(count),
    top_frac = top_n / n,
    ann_n    = length(count)
  ) %>%
  ungroup()

top_typs <- set_names(ann_stats$top_ann, ann_stats$.cell_id)
sec_typs <- set_names(ann_stats$sec_ann, ann_stats$.cell_id)
top_frac <- set_names(ann_stats$top_frac, ann_stats$.cell_id)

so_lec_merge <- so_lec_merge %>%
  AddMetaData(top_typs, col.name = "top_type") %>%
  AddMetaData(sec_typs, col.name = "sec_type") %>%
  AddMetaData(top_frac, col.name = "top_frac")

# Cluster cell type annotations
# want to identify primary annotation schemes
ann_mat <- ann_df %>%
  dplyr::select(.cell_id, starts_with("type-"))

ann_typs <- ann_mat %>%
  dplyr::select(starts_with("type-")) %>%
  as.matrix() %>%
  as.factor() %>%
  levels()

ann_mat <- ann_mat %>%
  mutate(across(starts_with("type-"), ~ as.numeric(factor(.x, ann_typs)))) %>%
  column_to_rownames(".cell_id") %>%
  as.matrix() %>%
  t()

ann_clsts <- kmeans(ann_mat, centers = 10)

ann_clst_res <- tibble(
  key = names(ann_clsts$cluster),
  id  = unname(ann_clsts$cluster),
  type = "all"
) %>%
  separate(key, into = c("blank", "rsln", "n_genes"), sep = "-") %>%
  dplyr::select(-blank) %>%
  group_by(id) %>%
  mutate(n = n()) %>%
  dplyr::slice(1) %>%
  ungroup() %>%
  arrange(desc(n)) %>%
  mutate(id = row_number())
```

```{r "refine consensus annotations"}
# # Use clustifyr params identified above
# # 2000 genes, resolution 11
# clst <- "RNA_snn_res.11"
# 
# if (create_obj) {
#   so_lec_merge <- so_lec_merge %>%
#     clustify(
#       ref_mat     = ref_lec,
#       cluster_col = clst,
#       n_genes     = 2000,
#       threshold   = 0.6,
#       compute_method    = "spearman",
#       pseudobulk_method = "mean"
#     )
# }

# Adjust clusters based on Marco expression
clst <- "RNA_snn_res.11"

top_marco <- so_lec_merge %>%
  FetchData(c("Marco", "tm", "treatment", clst)) %>%
  group_by(!!sym(clst)) %>%
  summarize(Marco = mean(Marco), .groups = "drop") %>%
  arrange(desc(Marco)) %>%
  filter(Marco > 0.5) %>%
  pull(clst)

if (create_obj) {
  so_lec_merge <- so_lec_merge %>%
    mutate_meta(
      mutate,
      new_type = ifelse(!!sym(clst) %in% top_marco, "Marco_LEC", top_type)
    )
  
  so_lec_merge %>%
    qsave(here(params$so_dir, "so_lec_annotations_2.qs"))
}

# Adjust unassigned clusters based on Pdpn and Pecam1 expression
other_becs <- so_lec_merge %>%
  subset(top_type == "unassigned") %>%
  FetchData(c("Pdpn", "Pecam1", "Cd34", "tm", "treatment", clst)) %>%
  group_by(!!sym(clst)) %>%
  summarize(across(c(Pdpn, Pecam1, Cd34), mean), .groups = "drop") %>%
  filter(Pdpn < 0.1, Pecam1 > 0.5) %>%
  pull(clst) %>%
  as.character()

so_lec_merge %>%
  plot_scatter(
    clst, top = other_becs,
    size = 0.001,
    plot_colors = c(other = "grey85")
  ) +
  facet_grid(tm ~ treatment)

# so_lec_merge %>%
#   plot_violin(
#     "Marco",
#     "RNA_snn_res.11",
#     plot_colors = lec_type_cols,
#     method = "boxplot"
#   ) +
#   facet_grid(tm ~ treatment)
```

```{r "PLOT DIFFERENT ANNOTATIONS", eval = FALSE}
# Filter results
test_res <- ann_clst_res %>%
  pmap_dfr(~ {
    args <- list(...)
    
    cluster_param_results %>%
      filter(
        rsln    == args$rsln,
        n_genes == args$n_genes,
        obj     == args$type
      ) %>%
      distinct(n_genes, obj, rsln, .keep_all = TRUE) %>%
      mutate(ttl = str_c(args$id, rsln, n_genes, obj, n_genes, sep = "-"))
  })
  
  # # filter(n_genes == 1000, obj == "all") %>%    # 18 is closest to consensus
  # # filter(n_genes == 2000, obj == "all") %>%    # 17 is closest to consensus
  # 
  # filter(n_genes == 1500, rsln == "RNA_snn_res.9.5", obj == "all") %>%      # cluster 7
  # # filter(n_genes == 2000, rsln == "RNA_snn_res.9", obj == "all") %>%      # cluster 9
  # 
  # distinct(n_genes, obj, rsln, .keep_all = TRUE)
  # 
  # # filter(rsln == "RNA_snn_res.15") %>%
  # # group_by(rsln, n_genes, obj) %>%
  # # filter(
  # #   # (Marco_mn == "Marco_LEC" | Marco_med == "Marco_LEC"),
  # #   # all(Marco_mn[treatment == "mock"] == "Marco_LEC" | is.na(Marco_mn[treatment == "mock"])),
  # #   all(Madcam1_mn == "fLEC" | is.na(Madcam1_mn)),
  # #   type == "Marco_LEC",
  # #   n_chikv > 200
  # # ) %>%
  # # ungroup()

# Example plots
# plot selected examples
test_plts <- test_res %>%
  pmap(~ {
    args <- list(...)
    
    type_key  <- args$type_key
    clst_clmn <- args$rsln
    
    so_ann <- so_lec_merge %>%
      mutate_meta(mutate, type = type_key[as.character(!!sym(clst_clmn))])
    
    umap <- so_ann %>%
      plot_scatter(
        "type", size = 0.5,
        plot_colors = c(Marco_LEC = "red", fLEC = "black")
      ) +
      facet_grid(tm ~ treatment) +
      ggtitle(args$ttl)
    
    bx1 <- so_ann %>%
      plot_violin(
        cluster_col = "type", method = "boxplot", data_col = "Marco",
        plot_colors = c(Marco_LEC = "red", fLEC = "black")
      ) +
      facet_grid(tm ~ treatment)
    
    bx2 <- so_ann %>%
      plot_violin(
        cluster_col = "type", method = "boxplot", data_col = "Madcam1",
        plot_colors = c(Marco_LEC = "red", fLEC = "black")
      ) +
      facet_grid(tm ~ treatment)
    
    bx3 <- so_ann %>%
      subset(treatment == "CHIKV") %>%
      plot_violin("Marco", "chikv_grp", method = "boxplot") +
      facet_grid(tm ~ type)
    
    res <- plot_grid(bx1, bx2, ncol = 1)
    res <- plot_grid(umap, res, nrow = 1)
    res <- plot_grid(res, bx3, ncol = 1, rel_heights = c(1, 0.7))
    
    res
  })
```

```{r "INTEGRATE BROAD CELL TYPES", eval = FALSE}

# Merge 8 and 24 hpi objects
so_8  <- qread(so_8_dir)
so_24 <- qread(so_24_dir)

so_merge <- merge(so_8, so_24) %>%
  FindVariableFeatures(nfeatures = 2000) %>%
  ScaleData() %>%
  RunPCA() %>%
  RunUMAP(dims = 1:40)
  
# Integrate samples
so_merge <- so_merge %>%
  mutate_meta(
    mutate,
    integration_var = ifelse(
      tm == "24hpi" & treatment == "CHIKV",
      "chikv_24hpi", "other"
    )
  ) %>%
  RunHarmony(
    c("rep", "integration_var"),
    dims = 1:40, plot_convergence = TRUE
  ) %>%
  RunUMAP(
    dims = 1:40,
    reduction      = "harmony",
    reduction.name = "humap",
    reduction.key  = "hUMAP_"
  )

so_merge %>%
  qsave(file.path(params$so_dir, "so_merge_int.qs"), compress_level = 5L)

# so_merge %>%
#   plot_scatter(
#     "cell_type",
#     x = "harmony_1",
#     y = "harmony_2",
#     size = 0.1
#   ) +
#   facet_grid(tm ~ treatment)

# Annotate broad cell types
so_merge <- qread(file.path(params$so_dir, "so_merge_int.qs"))

so_merge <- so_merge %>%
  FindNeighbors(reduction = "harmony", dims = 1:40) %>%
  FindClusters(resolution = 5:10)

so_merge <- so_merge %>%
  mutate_meta(dplyr::select, -starts_with("UMAP_"), -c(type, r)) %>%
  clustify(
    # ref_mat = ref_immgen_new,
    ref_mat = ref_immgen,
    cluster_col = "RNA_snn_res.10",
    n_genes = 2000,
    threshold = 0.6
  )

# Recluster fibroblasts and annotate PvCs
fib_bcs <- so_merge@meta.data %>%
  filter(grepl("^Stromal cells|^Fibroblasts", type)) %>%
  rownames()

so_fib <- so_merge %>%
  subset(cells = fib_bcs) %>%
  FindVariableFeatures(nfeatures = 2000) %>%
  ScaleData() %>%
  RunPCA() %>%
  RunUMAP(dims = 1:40)
  
so_fib <- so_fib %>%
  mutate_meta(
    mutate,
    integration_var = ifelse(
      tm == "24hpi" & treatment == "CHIKV",
      "chikv_24hpi", "other"
    )
  ) %>%
  RunHarmony(
    c("rep", "integration_var"),
    dims = 1:40, plot_convergence = TRUE
  ) %>%
  RunUMAP(
    dims = 1:40,
    reduction      = "harmony",
    reduction.name = "humap",
    reduction.key  = "hUMAP_"
  ) %>%
  FindNeighbors(reduction = "harmony", dims = 1:40) %>%
  FindClusters(resolution = 1:5)

# Set PvCs
# Integration is not great for Cxcl9+ TRCs
# Works good for PvCs
so_fib <- so_fib %>%
  mutate_meta(dplyr::select, -starts_with("UMAP_"), -c(type, r)) %>%
  clustify(
    ref_mat     = ref_fib,
    cluster_col = "RNA_snn_res.3",
    n_genes     = 2000,
    threshold   = 0.65
  )

so_merge <- so_merge %>%
  AddMetaData(FetchData(so_fib, "type"), col.name = "fib_type") %>%
  mutate_meta(
    mutate,
    new_cell_type = ifelse(fib_type == "PvC" & !is.na(fib_type), fib_type, type)
  )

# Check cell type annotations
so_merge %>%
  plot_scatter(
    # "new_cell_type",
    "fib_type",
    "hUMAP_1", "hUMAP_2",
    size = 0.001
  ) +
  facet_grid(tm ~ treatment)

so_merge %>%
  plot_scatter(
    "r",
    "hUMAP_1", "hUMAP_2",
    size = 0.001, plot_colors = c("lightblue", "red")
  ) +
  facet_grid(tm ~ treatment)

so_merge %>%
  plot_scatter(
    "Pdpn",
    "hUMAP_1", "hUMAP_2",
    size = 0.001, plot_colors = c("lightblue", "red")
  ) +
  facet_grid(tm ~ treatment)
```

<br>

## Summary

The LEC subset annotations were reassessed.

* Identified a new set annotations after integrating the datasets and compared these with our original annotations
* I have tried this approach before with these data, but was previously unable to get reasonable integration of the samples
* There is a population of Madcam1+ cells in the CHIKV 24 hpi dataset that could reasonably be annotated as fLECs. This population is still reduced when compared to the mock sample

Expression of flow markers used in the paper to identify fLECs was assessed.

* The frequency of fLECs is relatively similar for the mock and CHIKV 24 hpi datasets when this population is defined based on the flow markers.

---

<br>

## Sample integration {.tabset .tabset-pills}

The 24 hpi CHIKV infected sample was integrated with the other samples (24 hpi mock, 8 hpi mock and CHIKV). UMAP projections for the integrated data are shown below with cells colored based on the original LEC subset annotations.

```{r}
umap_theme_2 <- theme(
  aspect.ratio = 0.9,
  legend.title = element_blank(),
  axis.title   = element_blank(),
  axis.text    = element_blank(),
  axis.ticks   = element_blank()
)

# UMAPs
so_lec_merge <- so_lec_merge %>%
  mutate_meta(
    mutate,
    treatment = fct_relevel(treatment, treats)
  )

so_lec_merge %>%
  plot_scatter(
    "lec_type",
    size        = 0.01,
    plot_colors = lec_type_cols,
    n_label     = "legend"
  ) +
  facet_grid(tm ~ treatment) +
  umap_theme_2
```

CHIKV-high cells are shown below for the integrated data.

```{r}
# UMAPs
so_lec_merge %>%
  plot_scatter(
    "chikv_grp",
    size        = 0.01,
    plot_colors = c(`CHIKV-low` = "lightblue", `CHIKV-high` = "#D7301F"),
    plot_lvls   = "CHIKV-high",
    n_label     = "legend"
  ) +
  facet_grid(tm ~ treatment) +
  umap_theme_2
```

Expression of key LEC markers is shown below for the original annotations.

```{r, fig.width = 10, fig.height = 6, results = "asis"}
key_markers <- c(
  "Pdpn", "Pecam1", "Prox1", "Lyve1",
  "Marco", "Madcam1", "Icam1", "Vcam1", "Mrc1",
  "Ptx3", "Ackr4", "Cd36"
)

key_markers %>%
  walk(~ {
    cat("\n\n###", .x, "\n\n")
    u <- so_lec_merge %>%
      plot_scatter(
        .x,
        size = 0.01,
        plot_colors = c("lightblue", "#D7301F")
      ) +
      facet_grid(tm ~ treatment) +
      guides(color = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
      umap_theme_2
    
    b <- so_lec_merge %>%
      
      plot_violin(
        .x,
        cluster_col = "lec_type",
        method      = "boxplot",
        plot_colors = lec_type_cols,
        outlier.alpha = 1,
        outlier.size  = 0.1
      ) +
      facet_wrap(tm ~ treatment, ncol = 1)
    
    p <- plot_grid(
      u, b,
      nrow = 1,
      rel_widths = c(1, 0.55),
      align = "h",
      axis  = "tb"
    )
    
    print(p)
    cat("\n\n---\n\n<br>\n\n")
  })
```

## Assessing annotations {.tabset .tabset-pills}

Two key parameters that affect cell type annotation are clustering resolution (~45-140 clusters) and the number of genes used for calculating the correlation with the reference (500-2000). By varying these two parameters, 100 additional annotations were identified for the integrated data. From these 100 annotations, the top cell type identities that occurred most frequently are shown below.

Notable differences from our original annotations:

* Identification of some fLECs in the 24 hpi CHIKV dataset
* Some of the Valve LECs identified in the 24 hpi CHIKV dataset are classified as cLECs
* Some of the Marco LECs identified in the 24 hpi dataset are classified as tzLECs. I feel that these cells would be better classified as Marco LECs (like in our original annotations) based on Marco expression.

```{r}
so_lec_merge %>%
  plot_scatter(
    "top_type",
    size        = 0.01,
    plot_colors = lec_type_cols,
    n_label     = "legend"
  ) +
  facet_grid(tm ~ treatment) +
  umap_theme_2
```

To assess the consistency/stability of the top cell type identities, the fraction of annotations matching the top identities is shown below (i.e. dark blue indicates that regardless of the parameters, the same cell type is reported).

Some key things to note:

* The fLEC annotation appears very consistent for the 24 hpi CHIKV sample
* The main tzLEC cluster fluctuates between being annotated as Marco LECs, tzLECs, and fLECs. Based on Marco expression, I think it is reasonable to annotate this cluster as Marco LECs.
* Some of the BEC clusters seem to vary when clustering parameters are modified. This is because depending on the parameters some BEC clusters get classified as "unassigned", i.e. BECs are always classified as a BEC or unassigned

```{r}
so_lec_merge %>%
  plot_scatter(
    "top_frac",
    size        = 0.01,
    plot_colors = c("white", "#00446E"),
    n_label     = "none"
  ) +
  facet_grid(tm ~ treatment) +
  guides(color = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
  umap_theme_2
```

Expression of key LEC markers is shown below for the integrated annotations.

```{r, fig.width = 10, fig.height = 6, results = "asis"}
key_markers <- c(
  "Pdpn", "Pecam1", "Prox1", "Lyve1",
  "Marco", "Madcam1", "Icam1", "Vcam1", "Mrc1",
  "Ptx3", "Ackr4", "Cd36"
)

key_markers %>%
  walk(~ {
    cat("\n\n###", .x, "\n\n")
    u <- so_lec_merge %>%
      plot_scatter(
        .x,
        size = 0.01,
        plot_colors = c("lightblue", "#D7301F")
      ) +
      facet_grid(tm ~ treatment) +
      guides(color = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
      umap_theme_2
    
    b <- so_lec_merge %>%
      plot_violin(
        .x,
        cluster_col = "top_type",
        method      = "boxplot",
        plot_colors = lec_type_cols,
        outlier.alpha = 1,
        outlier.size  = 0.1
      ) +
      facet_wrap(tm ~ treatment, ncol = 1)
    
    p <- plot_grid(
      u, b,
      nrow = 1,
      rel_widths = c(1, 0.55),
      align = "h",
      axis  = "tb"
    )
    
    print(p)
    cat("\n\n---\n\n<br>\n\n")
  })
```

## Refining annotations {.tabset .tabset-pills}

Some of the integrated annotations could be adjusted based on Marco expression. The top Marco-expressing cell clusters are shown below, this includes clusters annotated as tzLECs.

```{r, fig.width = 10, fig.height = 6}
clst_cols <- set_names(
  palette_OkabeIto[seq_along(top_marco)],
  top_marco
)

clst_cols["other"] <- "grey85"

u <- so_lec_merge %>%
  plot_scatter(
    clst,
    size = 0.01,
    plot_colors = clst_cols,
    plot_lvls   = top_marco,
    top         = top_marco,
    n_label     = "legend"
  ) +
  facet_grid(tm ~ treatment) +
  umap_theme_2

b <- so_lec_merge %>%
  plot_violin(
    "Marco",
    cluster_col   = clst,
    method        = "boxplot",
    top           = top_marco,
    plot_colors   = clst_cols,
    outlier.alpha = 1,
    outlier.size  = 0.1
  ) +
  facet_wrap(tm ~ treatment, ncol = 1)

plot_grid(
  u, b,
  nrow = 1,
  rel_widths = c(1, 0.5),
  align = "h",
  axis  = "tb"
)
```

Refined annotations are shown below after adjusting the Marco LEC annotations to include all of the top Marco-expressing clusters.

```{r}
so_lec_merge %>%
  plot_scatter(
    "new_type",
    size        = 0.01,
    plot_colors = lec_type_cols,
    plot_lvls   = c("fLEC", "tzLEC", "Ptx3_LEC", "unassigned"),
    n_label     = "legend"
  ) +
  facet_grid(tm ~ treatment) +
  umap_theme_2
```

Expression of key LEC markers is shown below for the refined annotations.

```{r, fig.width = 10, fig.height = 6, results = "asis"}
key_markers <- c(
  "Pdpn", "Pecam1", "Prox1", "Lyve1",
  "Marco", "Madcam1", "Icam1", "Vcam1", "Mrc1",
  "Ptx3", "Ackr4", "Cd36"
  
  # "Cd3e", "Cd4", "Cd8a", "Ptprc"
  # "Bmp4", "Cav1", "Edn1", "Pdgfb"
)

key_markers %>%
  walk(~ {
    cat("\n\n###", .x, "\n\n")
    u <- so_lec_merge %>%
      plot_scatter(
        .x,
        size = 0.01,
        plot_colors = c("lightblue", "#D7301F")
      ) +
      facet_grid(tm ~ treatment) +
      guides(color = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
      umap_theme_2
    
    b <- so_lec_merge %>%
      
      plot_violin(
        .x,
        cluster_col = "new_type",
        method      = "boxplot",
        plot_colors = lec_type_cols,
        outlier.alpha = 1,
        outlier.size  = 0.1
      ) +
      facet_wrap(tm ~ treatment, ncol = 1)
    
    p <- plot_grid(
      u, b,
      nrow = 1,
      rel_widths = c(1, 0.55),
      align = "h",
      axis  = "tb"
    )
    
    print(p)
    cat("\n\n---\n\n<br>\n\n")
  })
```

## Frequency of LEC subsets

The frequency of different LEC subsets is shown below for the original, integrated, and refined (based on Marco expression) cell type annotations. With all three cell type annotations fLECs are significantly reduced in frequency in the CHIKV 24 hpi dataset.

```{r, fig.width = 10, fig.height = 10.5}
type_args <- list(
  clmn  = c("lec_type", "top_type", "new_type"),
  color = c("#6A51A3", "#009E73", "#D55E00"),
  ttl   = c("original", "integrated", "refined")
)

type_args %>%
  pmap(~ {
    args <- list(...)
    
    c("8hpi", "24hpi") %>%
      imap(~ {
        so_lec_merge %>%
          subset(!!sym(args$clmn) != "BEC" & tm == .x) %>%
          plot_frequency(
            args$clmn,
            cluster_col = "orig.ident",
            group_col   = "treatment",
            p_label     = "none",
            # p_method = "edgeR",
            plot_colors = c(mock = "lightblue", CHIKV = args$color)
          ) +
          labs(title = str_c(.x, " - ", args$ttl), y = "% LECs") +
          theme(legend.title = element_blank())
      }) %>%
      wrap_plots(nrow = 1, guides = "collect")
  }) %>%
  plot_grid(plotlist = ., ncol = 1)
```

---

<br>

## CHIKV-high Marco expression

Marco expression is shown below for CHIKV-low/high cells for the original, integrated, and refined cell type annotations. Marco is consistently more highly expressed in CHIKV-high cells regardless of cell type annotations.

```{r, fig.width = 8, fig.height = 5.5}
vars <- c(
  "orig.ident", "tm", "treatment", "rep",
  "chikv_grp", type_args$clmn, "Marco"
)

dat <- so_lec_merge %>%
  FetchData(vars) %>%
  as_tibble(rownames = ".cell_id") %>%
  filter(treatment == "CHIKV") %>%
  mutate(chikv_grp = fct_relevel(chikv_grp, chikv_grps))
  
plts <- type_args %>%
  pmap(~ {
    args <- list(...)
    clrs <- c(`CHIKV-low` = "lightblue", `CHIKV-high` = args$color)
    
    # typs <- dat %>%
    #   group_by(tm, !!sym(args$clmn), chikv_grp, orig.ident) %>%
    #   summarize(n = n(), .groups = "drop") %>%
    #   group_by(tm, !!sym(args$clmn)) %>%
    #   filter(all(n > 3), all(chikv_grps %in% chikv_grp)) %>%
    #   ungroup() %>%
    #   distinct(tm, !!sym(args$clmn))
    typs <- c("fLEC", "Marco_LEC", "tzLEC")
    
    dat %>%
      filter(!!sym(args$clmn) %in% typs) %>%
      # semi_join(typs, by = c("tm", args$clmn)) %>%
      ggplot(aes(orig.ident, Marco, color = chikv_grp, fill = chikv_grp)) +
      geom_boxplot(
        alpha = 0.5,
        linewidth  = 0.5,
        outlier.alpha = 1,
        outlier.size  = 0.1,
        position      = position_dodge2(preserve = "single")
      ) +
      facet_grid(as.formula(str_c("tm ~ ", args$clmn))) +
      scale_color_manual(values = clrs) +
      scale_fill_manual(values = clrs) +
      labs(title = args$ttl) +
      djvdj_theme() +
      theme(
        aspect.ratio = 0.9,
        axis.text.x  = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks.x = element_blank(),
        legend.title = element_blank(),
        legend.position = "bottom"
      )
  })

plts <- append(plts[1:2], list(NULL)) %>%
  append(plts[3])

plot_grid(plotlist = plts, nrow = 2, rel_widths = c(0.6, 1))
```

---

<br>

## Flow markers

LECs were divided into MRC1+/- cells

```{r "Mrc1", fig.width = 10, fig.height = 6}
# Format new object
key_marks <- c("Pdpn", "Pecam1", "Mrc1", "Icam1", "Cd36", "Itga2b")

so_lec <- so_lec_merge %>%
  subset(new_type != "BEC")

so_lec <- so_lec %>%
  AddMetaData(FetchData(., key_marks))

# Set new colors
new_cols          <- lec_type_cols
new_cols["fLEC"]  <- lec_type_cols["tzLEC"]
new_cols["tzLEC"] <- lec_type_cols["fLEC"]

new_cols_2             <- new_cols
new_cols_2["new_fLEC"] <- lec_type_cols["tzLEC"]
new_cols_2["fLEC"]     <- lec_type_cols["unassigned-LEC"]

# # Pdpn and Pecam1
# so_lec_merge %>%
#   mutate_meta(mutate, broad_type = ifelse(new_type == "BEC", new_type, "LEC")) %>%
#   plot_scatter(
#     "broad_type",
#     x = "Pecam1",
#     y = "Pdpn",
#     plot_colors = palette_OkabeIto
#   ) +
#   facet_grid(tm ~ treatment)
# mean_dat <- so_lec_merge %>%
#   FetchData(c("tm", "treatment", "new_type", clst, "Pdpn", "Pecam1")) %>%
#   mutate(broad_type = ifelse(new_type == "BEC", new_type, "LEC")) %>%
#   group_by(!!sym(clst), tm, treatment, broad_type) %>%
#   summarize(across(c(Pdpn, Pecam1), mean), .groups = "drop")

# Identity Mrc1- cells
# Pecam1 > 0.25; Mrc1 < 0.2
mrc1_cutoff  <- 0.2
pecam_cutoff <- 0.25

so_lec <- so_lec %>%
  mutate_meta(
    mutate,
    mrc1_grp = ifelse(Pecam1 > pecam_cutoff & Mrc1 < mrc1_cutoff,  "Mrc1-", "other"),
    mrc1_grp = ifelse(Pecam1 > pecam_cutoff & Mrc1 >= mrc1_cutoff, "Mrc1+", mrc1_grp)
  ) %>%
  mutate_meta(~ {
    .x %>%
      group_by(tm, treatment) %>%
      mutate(n = n()) %>%
      group_by(tm, treatment, mrc1_grp) %>%
      mutate(mrc1_frac = n() / n) %>%
      ungroup()
  })

# Create scatter plots
lab_dat <- so_lec@meta.data %>%
  filter(mrc1_grp != "other") %>%
  distinct(tm, treatment, mrc1_grp, n, mrc1_frac) %>%
  mutate(
    mrc1_frac = round(mrc1_frac * 100, 1),
    mrc1_frac = str_c(mrc1_grp, ": ", mrc1_frac, "%"),
    n = scales::label_comma()(n),
    n = str_c("n = ", n)
  ) %>%
  pivot_wider(names_from = mrc1_grp, values_from = mrc1_frac) %>%
  mutate(lab = str_c(n, `Mrc1-`, `Mrc1+`, sep = "\n"))

s <- so_lec %>%
  plot_scatter(
    "new_type",
    x = "Pecam1",
    y = "Mrc1",
    plot_colors = new_cols,
    plot_lvls = "fLEC",
    n_label = "legend"
  ) +
  facet_grid(tm ~ treatment) + 
  geom_segment(
    aes(x = pecam_cutoff, xend = Inf, y = mrc1_cutoff, yend = mrc1_cutoff),
    linetype = 2,
    color = "black",
    show.legend = FALSE
  ) +
  geom_segment(
    aes(x = pecam_cutoff, xend = pecam_cutoff, y = -Inf, yend = mrc1_cutoff),
    linetype = 2,
    color = "black",
    show.legend = FALSE
  ) +
  geom_text(
    aes(Inf, Inf, label = lab),
    data = lab_dat,
    color = "black",
    hjust = 1.1,
    vjust = 1.1,
    size  = 8 / .pt
  ) +
  theme(
    aspect.ratio = 0.9,
    legend.title = element_blank()
  )

# Create bargraphs
b <- so_lec@meta.data %>%
  filter(mrc1_grp != "other") %>%
  mutate(tm_treat = str_c(tm, "-", treatment)) %>%
  ggplot(aes(tm_treat, fill = new_type, color = new_type)) +
  geom_bar(position = "fill", alpha = 0.7) +
  facet_wrap(~ mrc1_grp, ncol = 1) +
  scale_color_manual(values = new_cols) +
  scale_fill_manual(values = new_cols) +
  djvdj_theme() +
  theme(
    axis.title   = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.y  = element_blank(),
    legend.position = "none",
    axis.text.x  = element_text(hjust = 1, angle = 45)
  )

# Create final figure
plot_grid(
  s, b,
  nrow = 1,
  align = "h",
  axis  = "tb",
  rel_widths = c(1, 0.3)
)
```

MRC1-/ICAM1+/CD36- cells were selected

```{r "Cd36", fig.width = 10, fig.height = 6}
# Identify Cd36- cells
# Cd36 > 1; Icam1 > 0.2
cd36_cutoff  <- 1
icam1_cutoff <- 0.2

so_lec <- so_lec %>%
  mutate_meta(
    mutate,
    cd36_grp = ifelse(
      mrc1_grp == "Mrc1-" & Cd36 < cd36_cutoff & Icam1 > icam1_cutoff,
      "Cd36-", "other"
    )
  )

# Create scatter plots
lab_dat <- so_lec@meta.data %>%
  filter(mrc1_grp == "Mrc1-") %>%
  group_by(tm, treatment) %>%
  mutate(n = n()) %>%
  group_by(tm, treatment, n, cd36_grp) %>%
  summarize(frac = n() / n, .groups = "drop") %>%
  distinct() %>%
  mutate(
    frac = round(frac * 100, 1),
    frac = str_c(cd36_grp, ": ", frac, "%"),
    n = scales::label_comma()(n),
    n = str_c("n = ", n)
  ) %>%
  filter(cd36_grp == "Cd36-") %>%
  pivot_wider(names_from = cd36_grp, values_from = frac) %>%
  mutate(lab = str_c(n, `Cd36-`, sep = "\n"))

s <- so_lec %>%
  subset(mrc1_grp == "Mrc1-") %>%
  plot_scatter(
    "new_type",
    x = "Cd36",
    y = "Icam1",
    plot_colors = new_cols,
    plot_lvls = "fLEC",
    n_label = "legend"
  ) +
  facet_grid(tm ~ treatment) + 
  geom_segment(
    aes(x = cd36_cutoff, xend = cd36_cutoff, y = icam1_cutoff, yend = Inf),
    linetype = 2,
    color = "black",
    show.legend = FALSE
  ) +
  geom_segment(
    aes(x = -Inf, xend = cd36_cutoff, y = icam1_cutoff, yend = icam1_cutoff),
    linetype = 2,
    color = "black",
    show.legend = FALSE
  ) +
  geom_text(
    aes(Inf, Inf, label = lab),
    data = lab_dat,
    color = "black",
    hjust = 1.1,
    vjust = 1.1,
    size  = 8 / .pt
  ) +
  theme(
    aspect.ratio = 0.9,
    legend.title = element_blank()
  )

# Create bargraphs
b <- so_lec@meta.data %>%
  filter(mrc1_grp == "Mrc1-") %>%
  mutate(
    tm_treat = str_c(tm, "-", treatment),
    new_type = fct_relevel(new_type, c("fLEC", "Marco_LEC"))
  ) %>%
  ggplot(aes(tm_treat, fill = new_type, color = new_type)) +
  geom_bar(position = "fill", alpha = 0.7) +
  facet_wrap(~ cd36_grp, ncol = 1) +
  scale_color_manual(values = new_cols) +
  scale_fill_manual(values = new_cols) +
  djvdj_theme() +
  theme(
    axis.title   = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.y  = element_blank(),
    legend.position = "none",
    axis.text.x  = element_text(hjust = 1, angle = 45)
  )

# Create final figure
plot_grid(
  s, b,
  nrow = 1,
  align = "h",
  axis  = "tb",
  rel_widths = c(1, 0.3)
)
```

MRC1-/ICAM1+/CD36-/ITGA2B+ cells were selected

```{r "Itga2b", fig.width = 10, fig.height = 6}
# Identify Itga2b+ cells
itga2b_cutoff <- 0.25

so_lec <- so_lec %>%
  mutate_meta(
    mutate,
     new_fLEC = ifelse(
      cd36_grp == "Cd36-" & Itga2b > itga2b_cutoff,
      "new_fLEC", "other"
    )
  )

new_fLECs <- so_lec@meta.data %>%
  filter(new_fLEC == "new_fLEC") %>%
  dplyr::select(new_fLEC)

so_lec_merge <- so_lec_merge %>%
  AddMetaData(new_fLECs, "new_fLEC") %>%
  mutate_meta(mutate, new_fLEC = ifelse(is.na(new_fLEC), new_type, new_fLEC))

# Create scatter plots
lab_dat <- so_lec@meta.data %>%
  filter(cd36_grp == "Cd36-") %>%
  group_by(tm, treatment) %>%
  mutate(n = n()) %>%
  group_by(tm, treatment, n, new_fLEC) %>%
  summarize(frac = n() / n, .groups = "drop") %>%
  distinct() %>%
  mutate(
    frac = round(frac * 100, 1),
    frac = str_c(new_fLEC, ": ", frac, "%"),
    n = scales::label_comma()(n),
    n = str_c("n = ", n)
  ) %>%
  filter(new_fLEC == "new_fLEC") %>%
  pivot_wider(names_from = new_fLEC, values_from = frac) %>%
  mutate(lab = str_c(n, new_fLEC, sep = "\n"))

s <- so_lec %>%
  subset(cd36_grp == "Cd36-") %>%
  plot_scatter(
    "new_type",
    x = "Cd36",
    y = "Itga2b",
    plot_colors = new_cols,
    plot_lvls = "fLEC",
    n_label = "legend"
  ) +
  facet_grid(tm ~ treatment) + 
  geom_hline(yintercept = itga2b_cutoff, linetype = 2) +
  geom_text(
    aes(Inf, Inf, label = lab),
    data = lab_dat,
    color = "black",
    hjust = 1.1,
    vjust = 1.1,
    size  = 8 / .pt
  ) +
  theme(
    legend.title = element_blank(),
    aspect.ratio = 0.9
  )

# Create bargraphs
b <- so_lec@meta.data %>%
  filter(cd36_grp == "Cd36-") %>%
  mutate(
    tm_treat = str_c(tm, "-", treatment),
    new_type = fct_relevel(new_type, c("fLEC", "Marco_LEC"))
  ) %>%
  ggplot(aes(tm_treat, fill = new_type, color = new_type)) +
  geom_bar(position = "fill", alpha = 0.7) +
  facet_wrap(~ new_fLEC, ncol = 1) +
  scale_color_manual(values = new_cols) +
  scale_fill_manual(values = new_cols) +
  scale_y_continuous(breaks = c(0, 0.5, 1)) +
  djvdj_theme() +
  theme(
    axis.title   = element_blank(),
    # axis.ticks.y = element_blank(),
    # axis.text.y  = element_blank(),
    legend.position = "none",
    axis.text.x  = element_text(hjust = 1, angle = 45)
  )

# Create final figure
plot_grid(
  s, b,
  nrow = 1,
  align = "h",
  axis  = "tb",
  rel_widths = c(1, 0.3)
)
```

The revised fLEC annotations are shown below

```{r "new fLEC UMAP"}
so_lec_merge %>%
  plot_scatter(
    "new_fLEC",
    size = 0.01,
    plot_colors = new_cols_2,
    plot_lvls = "new_fLEC"
  ) +
  facet_grid(tm ~ treatment)
```

The difference in fLEC frequency is shown below for the new fLEC annotations

```{r "new fLEC frequency", fig.width = 10, fig.height = 3}
c("8hpi", "24hpi") %>%
  map(~ {
    so_lec_merge %>%
      subset(tm == .x & new_type != "BEC") %>%
      plot_frequency(
        "new_fLEC", "orig.ident", "treatment",
        plot_colors = c("#0072B2", "#D55E00"),
        p_label = "none"
        # p_method = "edgeR"
      ) +
      labs(title = .x, y = "% LECs")
  }) %>%
  plot_grid(plotlist = ., nrow = 1)
```

```{r "OLD new fLECs", eval = FALSE}
# Add new fLECs to object
so_lec_merge <- so_lec_merge %>%
  AddMetaData(FetchData(new_fLECs, "new_fLEC")) %>%
  mutate_meta(mutate, new_fLEC = ifelse(is.na(new_fLEC), new_type, new_fLEC))

so_lec_merge %>%
  plot_scatter(
    "new_fLEC",
    size = 0.5,
    plot_colors = new_cols_2,
    plot_lvls = "new_fLEC"
  ) +
  facet_grid(tm ~ treatment)

new_fLECs@meta.data %>%
  mutate(
    tm_treat = str_c(tm, "-", treatment),
    new_type = fct_infreq(new_type)
  ) %>%
  ggplot(aes(tm_treat, fill = new_type, color = new_type)) +
  geom_bar(position = "fill", alpha = 0.5) +
  scale_color_manual(values = new_cols_2) +
  scale_fill_manual(values = new_cols_2) +
  djvdj_theme()

c("8hpi", "24hpi") %>%
  map(~ {
    so_lec_merge %>%
      subset(tm == .x & new_type != "BEC") %>%
      plot_frequency(
        "new_fLEC", "orig.ident", "treatment",
        p_label = "none"
        # p_method = "edgeR"
      )
  }) %>%
  plot_grid(plotlist = ., nrow = 1)
```


