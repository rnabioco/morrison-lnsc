
```{r "packages"}
# plotting
library(scales)
library(ggrepel)
library(ggtrace)
library(patchwork)
library(cowplot)
library(colorblindr)
library(ggtext)
library(ggforce)

# analysis
library(Seurat)
library(harmony)
library(clustifyr)
library(clustifyrdata)
library(DoubletFinder)
library(M3Drop)
library(CellChat)
library(djvdj)
library(presto)
library(gprofiler2)
library(qs)

library(clusterProfiler)
library(enrichplot)
library(msigdbr)
library(org.Mm.eg.db)
library(GOSemSim)
library(biomaRt)
library(ggtree)

# tidyverse
library(tidyverse)
library(here)
library(knitr)
library(broom)
library(cli)
library(xlsx)
library(devtools)

source(here(params$src_dir, "funs.R"))
```

```{r "functions"}
type_lab_fn <- function(x) str_replace(x, "_", " ")

plot_example_gene <- function(so_in, feat, grp, box_colors = NULL,
                              umap_colors = c("#56B4E9", "white", "#D7301F")) {
  
  dat <- so_in %>%
    FetchData(c(feat, grp, "UMAP_1", "UMAP_2"))
  
  u <- dat %>%
    arrange(!!sym(feat)) %>%
    ggplot(aes(UMAP_1, UMAP_2, fill = !!sym(feat))) +
    geom_point_trace(size = 0.25, stroke = 0.65) +
    scale_fill_gradientn(colours = umap_colors) +
    guides(fill = guide_colorbar(
      ticks          = FALSE,
      barheight      = unit(10, "pt"),
      barwidth       = unit(140, "pt"),
      title.position = "top"
    )) +
    umap_theme +
    theme(
      legend.position      = "top",
      legend.title         = element_text(hjust = 0.5),
      legend.justification = 0.5,
      panel.border         = element_rect(fill = NA, color = "grey85")
    )
  
  
  lvls <- dat %>%
    group_by(!!sym(grp)) %>%
    summarize(
      med   = median(!!sym(feat)),
      stats = list(boxplot.stats(!!sym(feat))),
      q3    = map_dbl(stats, ~ .x$stats[4]),
      q4    = map_dbl(stats, ~ .x$stats[5]),
      max   = max(!!sym(feat)),
      .groups = "drop"
    ) %>%
    arrange(med, q3, q4, max) %>%
    pull(grp) %>%
    rev()
  
  b <- dat %>%
    plot_violin(
      feat, grp,
      plot_colors   = box_colors,
      plot_lvls     = lvls,
      method        = "boxplot",
      outlier.size  = 0.25,
      outlier.alpha = 1
    ) +
    theme(
      legend.position = "none",
      aspect.ratio = 0.21,
      axis.text.x  = element_text(angle = 45, hjust = 1),
      axis.line.y  = element_line(size = 0.5, color = "grey85"),
      axis.ticks.x = element_blank(),
      panel.border = element_blank(),
      axis.title.x = element_blank()
    )
  
  plot_grid(
    u, b,
    ncol        = 1,
    rel_heights = c(1, 0.5),
    align       = "v",
    axis        = "rl"
  )
}

create_cor_heatmap <- function(df_in, ttl = NULL, lec_labs = NULL, ln_clr = fade_0) {
  
  if (!is.null(lec_labs)) {
    df_in <- df_in %>%
      filter(assigned_type %in% names(lec_labs()))
  }
  
  # Data for tile labels
  lab_df <- df_in %>%
    group_by(assigned_type) %>%
    slice_max(r, n = 1) %>%
    ungroup()
  
  # Create heatmaps
  res <- df_in %>%
    ggplot(aes(ref_type, assigned_type, fill = r)) +
    geom_tile(color = ln_clr, size = 0.2) +
    
    geom_text(
      aes(label = round(r, 2)),
      data  = lab_df,
      color = "black",
      size  = txt_pt1 / .pt
    ) +
    
    guides(fill = bar_gd()) +
    scale_fill_gradientn(colors = c(fade_0, "#E69F00")) +
    labs(title = ttl, x = "reference", y = "assigned type") +
    
    base_theme +
    theme(
      aspect.ratio = n_distinct(df_in$assigned_type) / n_distinct(df_in$ref_type) * 0.75,
      legend.text  = element_text(size = txt_pt1),
      axis.line.x  = element_blank(),
      axis.line.y  = element_blank(),
      axis.text.x  = element_text(hjust = 1, angle = 45, size = txt_pt1),
      axis.text.y  = element_text(hjust = 1, size = txt_pt1),
      axis.title   = element_text(size = txt_pt2),
      plot.title   = element_text(size = ttl_pt1)
    )
  
  if (!is.null(lec_labs)) {
    res <- res +
      scale_y_discrete(labels = lec_labs)
  }
  
  res
}

create_gene_boxplot <- function(input, GENE, TYPE, type_clmn = "lec_type",
                                clr = lec_type_cols[[TYPE]], lvls = NULL,
                                pval_y = 5, p_size = txt_pt2, use_adj_p = TRUE) {
  
  # Format plot data
  dat <- input %>%
    FetchData(c(type_clmn, "treatment", "rep", "orig.ident", "chikv_grp", GENE)) %>%
    filter(!!sym(type_clmn) == TYPE) %>%
    mutate(chikv_grp = ifelse(treatment == "mock", treatment, chikv_grp))
  
  if (!is.null(lvls)) {
    dat <- dat %>%
      mutate(chikv_grp = fct_relevel(chikv_grp, lvls))
    
  } else {
    lvls <- unique(dat$chikv_grp)
  }
  
  clrs <- set_names(
    c("grey", rep(clr, 2)),
    lvls
  )
  
  # Calculate p-values
  p_vals <- dat %>%
    calc_p_vals(
      data_column = GENE,
      type_column = "chikv_grp"
    )
  
  comps <- names(clrs) %>%
    combn(2, simplify = FALSE)
  
  comps <- list(
    x    = map_chr(comps, pluck, 1),
    xend = map_chr(comps, pluck, 2),
    y    = c(pval_y, pval_y + pval_y * 0.12, pval_y)
  )
  
  # Create boxplots
  res <- dat %>%
    plot_violin(
      GENE, "chikv_grp",
      method        = "boxplot",
      plot_colors   = clrs,
      plot_lvls     = names(clrs),
      alpha         = c(0.5, 0.1, 0.5),
      linewidth     = 1,
      outlier.size  = 1.5,
      outlier.alpha = 1,
      width         = 0.6
    ) +
    labs(title = TYPE, y = str_c(GENE, " expression")) +
    base_theme +
    theme(
      legend.position = "none",
      aspect.ratio = 1.5,
      plot.title   = element_text(size = ttl_pt2 * 1.5),
      axis.title.y = element_text(size = ttl_pt2),
      axis.title.x = element_blank(),
      axis.text.x  = element_text(size = ttl_pt1, hjust = c(0.75, 0.5, 0.25)),
      plot.margin  = margin(5, 10, 5, 5)
    )
  
  # Add p-values to plot
  if (use_adj_p) p_clmn <- "p_adj"
  else           p_clmn <- "p.value"
  
  comps %>%
    pwalk(~ {
      v_args <- list(...)[c("x", "xend")]
      
      p <- p_vals %>%
        filter(`Cell type 1` %in% v_args & `Cell type 2` %in% v_args) %>%
        pull(p_clmn)
      
      res <<- res %>%
        add_pvals(
          ...,
          p_val    = p,
          size     = p_size / .pt,
          line_col = "grey75"
        )
    })
  
  res
}

create_example_gene_fig <- function(df_in, gns, x_clmn, clrs = lec_type_cols,
                                    ttl = NULL) {
  res <- gns %>%
    imap(~ {
      lvls <- df_in %>%
        group_by(!!sym(x_clmn), tm_treat) %>%
        summarize(
          n     = n(),
          stats = list(boxplot.stats(!!sym(.x))),
          med   = map_dbl(stats, ~ .x$stats[3]),
          q3    = map_dbl(stats, ~ .x$stats[4]),
          q4    = map_dbl(stats, ~ .x$stats[5]),
          mx    = max(!!sym(.x)),
          .groups = "drop"
        ) %>%
        group_by(!!sym(x_clmn)) %>%
        summarize(across(c(med, q3, q4, mx), mean)) %>%
        arrange(med, q3, q4, mx) %>%
        pull(x_clmn) %>%
        rev()
      
      plt <- df_in %>%
        mutate(
          x_type    = fct_relevel(!!sym(x_clmn), lvls),
          chikv_grp = fct_relevel(chikv_grp, chikv_grps)
        ) %>%
        ggplot(
          # aes(x_type, !!sym(.x), color = x_type, fill = x_type, alpha = chikv_grp)
          aes(x_type, !!sym(.x), color = x_type, fill = x_type)
        ) +
        geom_boxplot(
          linewidth = 0.5, alpha = 0.5,  # color = "black",
          outlier.size = 0.01, outlier.alpha = 0.1,
          position = position_dodge2(preserve = "single"),
          key_glyph = draw_key_point,
        ) +
        scale_color_manual(values = clrs) +
        scale_fill_manual(values = clrs) +
        scale_alpha_manual(values = c(`CHIKV-low` = 0.5, `CHIKV-high` = 1)) +
        scale_x_discrete(labels = type_lab_fn) +
        facet_wrap(~ tm_treat, ncol = 1) +
        labs(y = str_c(.x, " expression")) +
        guides(
          fill = "none", color = "none",
          alpha = guide_legend(
            override.aes = list(shape = 15, fill = "black", size = 4)
          )
        ) +
        djvdj_theme() +
        theme(
          aspect.ratio    = 0.15,
          plot.title      = element_text(hjust = 0.5),
          legend.position = "top",
          legend.title    = element_blank(),
          axis.title.x    = element_blank(),
          axis.text.x     = element_text(angle = 45, hjust = 1),
          # legend.text     = element_text(size = txt_pt1),
          # axis.text.y     = element_text(size = txt_pt1 * 0.75),
          # strip.text      = element_text(size = txt_pt2)
        )
      
      if (.y == 1 && !is.null(ttl)) {
        plt <- plt + ggtitle(ttl)
      }
      
      plt
    })
  
  res
}

.format_pvalue <- function(p, digits = 1, cutoffs = NULL) {

  # Set p label based on vector of cutoffs
  if (!is.finite(p)) return(as.character(NA))

  if (!is.null(cutoffs)) {
    if (any(duplicated(cutoffs))) {
      cli::cli_abort("Cutoff values for p_label must be unique.")
    }

    # Set default labels when not provided by user
    if (is.null(names(cutoffs))) {
      cutoffs <- sort(cutoffs, decreasing = TRUE)

      names(cutoffs) <- purrr::imap_chr(
        cutoffs, ~ paste0(rep("*", .y), collapse = "")
      )
    }

    cutoffs <- sort(cutoffs)
    p_label <- as.character(NA)

    for (val in names(cutoffs)) {
      if (p < cutoffs[val]) {
        p_label <- val

        break()
      }
    }

    # Treat "value" as a keyword that will allow user to display actual
    # p-value for a certain cutoff
    # All custom labels need to be wrapped in quotes for parsing
    if (!identical(p_label, "value")) {
      if (!is.na(p_label)) p_label <- paste0("\'", p_label, "\'")

      return(p_label)
    }
  }

  # Format p-value label
  if (p >= 0.1)    return(as.character(round(p, 1)))
  else if (p == 0) return(as.character(p))

  p <- scales::label_scientific(digits = digits)(p)

  ex <- str_extract_all(p, "[+\\-][0-9]+$")

  p <- sub(paste0("\\", ex, "$"), "", p)

  ex <- as.numeric(ex)
  ex <- as.character(ex)

  p <- sub("e", "*x*10^", p)
  p <- paste0(p, ex)

  p
}

create_example_gene_fig2 <- function(df_in, gns, x_clmn, al_clmn,
                                     plot_lvls = NULL, clrs = lec_type_cols,
                                     ttl = NULL) {
  
  vars <- unique(df_in[[al_clmn]])
  
  p_cuts <- c(0.01, 0.001, 0.0001)
  
  res <- gns %>%
    imap(~ {
      # Calculate p-values
      # ONLY SHOW <0.01
      p_dat <- df_in %>%
        mutate(x_type = !!sym(x_clmn)) %>%
        group_by(x_type) %>%
        filter(n_distinct(!!sym(al_clmn)) == 2) %>%
        summarize(
          p = wilcox.test(
            (!!sym(.x))[!!sym(al_clmn) == vars[1]],
            (!!sym(.x))[!!sym(al_clmn) == vars[2]]
          )$p.value,
          .groups = "drop"
        ) %>%
        filter(!is.na(p)) %>%
        mutate(p_adj = p.adjust(p)) %>%
        rowwise() %>%
        mutate(p_lab = .format_pvalue(p_adj, cutoffs = p_cuts)) %>%
        ungroup()
        # filter(p_adj < 0.01)
      
      # Set plot levels
      lvls <- df_in %>%
        group_by(!!sym(x_clmn), tm_treat) %>%
        summarize(
          n     = n(),
          stats = list(boxplot.stats(!!sym(.x))),
          med   = map_dbl(stats, ~ .x$stats[3]),
          q3    = map_dbl(stats, ~ .x$stats[4]),
          q4    = map_dbl(stats, ~ .x$stats[5]),
          mx    = max(!!sym(.x)),
          .groups = "drop"
        ) %>%
        group_by(!!sym(x_clmn)) %>%
        summarize(across(c(med, q3, q4, mx), mean)) %>%
        arrange(med, q3, q4, mx) %>%
        pull(x_clmn) %>%
        rev()
      
      lvls <- unique(c(plot_lvls, lvls))
      
      # Create boxplots
      plt <- df_in %>%
        mutate(
          x_type    = fct_relevel(!!sym(x_clmn), lvls),
          chikv_grp = fct_relevel(chikv_grp, chikv_grps),
          treatment = fct_relevel(treatment, treats)
        ) %>%
        ggplot(
          aes(x_type, !!sym(.x), color = x_type, fill = x_type, alpha = !!sym(al_clmn))
        ) +
        geom_boxplot(
          linewidth = 0.5,
          outlier.size = 0.2, outlier.alpha = 0.1,
          position = position_dodge2(preserve = "single"),
          key_glyph = draw_key_point,
        ) +
        scale_color_manual(values = clrs) +
        scale_fill_manual(values = clrs) +
        scale_alpha_manual(values = c(mock = 0.25, CHIKV = 0.75)) +
        scale_x_discrete(labels = type_lab_fn) +
        facet_wrap(~ tm, ncol = 1) +
        labs(y = str_c(.x, " expression")) +
        guides(
          fill = "none", color = "none",
          alpha = guide_legend(
            override.aes = list(shape = 15, fill = "black", size = 4)
          )
        ) +
        djvdj_theme() +
        theme(
          # aspect.ratio    = 0.25,
          plot.title      = element_text(hjust = 0.5),
          legend.position = "top",
          legend.title    = element_blank(),
          # legend.text     = element_text(size = txt_pt1),
          axis.title.x    = element_blank(),
          axis.text.x     = element_text(angle = 45, hjust = 1),
          # axis.text.y     = element_text(size = txt_pt1 * 0.75),
          strip.text      = element_text(size = txt_pt2)
        )
      
      # Add p-values
      plt <- plt +
        geom_text(
          aes(y = Inf, fill = NULL, label = p_lab),
          data  = p_dat,
          vjust = 1.5,
          color = "black",
          alpha = 1,
          parse = TRUE,
          size  = 16 / .pt
        ) +
        scale_y_continuous(expand = expansion(c(0.05, 0.15)))
      
      if (.y == 1 && !is.null(ttl)) {
        plt <- plt + ggtitle(ttl)
      }
      
      plt
    })
  
  res
}

create_type_umaps <- function(so_in, data_col, x = "hUMAP_1", y = "hUMAP_2",
                              clrs = type_cols, ttl = NULL, n_lab = TRUE,
                              facet_plot = c("tm", "treatment"),
                              lab_size = txt_pt2, key_height = 30, ...) {
  res <- so_in %>%
    mutate_meta(~ {
      dat <- .x
      
      if (!is.null(facet_plot)) {
        dat <- dat %>%
          group_by(!!!syms(facet_plot))
      }
      
      dat %>%
        mutate(
          n_lab = label_comma()(n()),
          n_lab = str_c("n = ", n_lab)
        ) %>%
        ungroup() %>%
        mutate(
          tm = fct_relevel(tm, tms),
          treatment = fct_relevel(treatment, treats)
        )
    })
  
  args <- list(
    input       = res,
    data_col    = data_col,
    x           = x,
    y           = y,
    plot_colors = clrs,
    ...
  )
  
  args$n_label <- args$n_label %||% "legend"
  
  res <- lift_dl(plot_scatter)(args) +
    ggtitle(ttl) +
    base_theme +
    theme(
      aspect.ratio      = 0.9,
      plot.margin       = margin(15, 15, 30, 15),
      plot.title        = element_text(face = "plain", hjust = 0.5, size = ttl_pt2),
      strip.text        = element_text(size = ttl_pt1),
      panel.background  = element_blank(),
      legend.title      = element_blank(),
      legend.position   = "right",
      legend.key.height = unit(key_height, "pt"),
      legend.text       = element_text(size = lab_size),
      axis.title        = element_blank(),
      axis.text         = element_blank(),
      axis.ticks        = element_blank()
    )
  
  if (n_lab) {
    res <- res +
      geom_text(
        aes(Inf, Inf, label = n_lab),
        hjust = 1.1, vjust = 1.2, color = "black",
        check_overlap = TRUE,
        size = lab_size / .pt
      )
  }
  
  if (!is.null(facet_plot)) {
    frm <- case_when(  # returns vector of same length as input
      length(facet_plot) == 1 ~ str_c("~ ", facet_plot),
      length(facet_plot) > 1  ~ str_c(facet_plot[1:2], collapse = " ~ ")
    )
    
    res <- res +
      facet_grid(as.formula(frm[1]))
  }
  
  res
}

#' Fill the upper triangular matrix completely
#' 
#' FROM ENRICHPLOT
#'
#' @param x termsim similarity matrix
#' @param keep GO terms to keep
#' @return a data.frame
#' @noRd
fill_termsim <- function(x, keep = NULL) {
  if (!is.null(keep)) termsim <- x[keep, keep]
  else                termsim <- x
  
  termsim[which(is.na(termsim))] <- 0
  
  termsim2 <- termsim + t(termsim)
  
  for ( i in seq_len(nrow(termsim2))) termsim2[i, i] <- 1
  
  termsim2
}

#' Fetch genes for the provided annotations
fetch_genes <- function(terms, mart) {
  att  <- c("ensembl_gene_id", "external_gene_name")
  names(terms) <- names(terms) %||% rep("go_parent_name", length(terms))
  names(terms)[names(terms) == ""] <- "go_parent_name"

  res <- terms %>%
    imap(~ {
      biomaRt::getBM(
        attributes = att,
        filters    = .y,
        values     = .x,
        mart       = mart
      ) %>%
        pull(external_gene_name)
    }) %>%
    reduce(c) %>%
    unique()

  res
}

#' Identify DEGs
#' 
#' @param so_in Seurat object to use for identifying DEGs
#' @param ident_1 Cell label to use for comparing gene expression
#' @param ident_2 Cell label to compare with ident_1
#' @param pval p-value cutoff for filtering DEGs
#' @param log_fc Vector containing upper and lower fold change cutoffs to use
#' for filtering DEGs
#' @param type_clmn Column in object containing cell types, DEGs will be
#' identified separately for each cell type
#' @param treat_clmn Column in object containing ident_1 and ident_2 labels
#' @param rep_clmn Column in object containing replicate IDs
#' @param exclude_types Vector containing cell types to exclude from analysis
#' @param file Path to output file to use for saving results
get_degs <- function(so_in, ident_1 = "CHIKV", ident_2 = "mock",
                     pval = 0.05, log_fc = c(0.15, Inf),
                     type_clmn = "subtype", treat_clmn = "treatment",
                     rep_clmn = "rep", exclude_types = c("other", "unassigned"),
                     file = NULL) {
  
  # Format input data
  Idents(so_in) <- unlist(so_in[[treat_clmn]], use.names = FALSE)
  
  so_in <- so_in %>%
    mutate_meta(mutate, treat_rep = str_c(!!sym(treat_clmn), !!sym(rep_clmn)))
  
  # Identify cell types with >3 cells in all replicates/samples
  # exclude cell types in exclude_types, e.g. unassigned
  typs <- so_in %>%
    get_cell_types(
      type_clmn    = type_clmn,
      sample_clmn = "treat_rep",
      n_cells     = 3
    )
  
  typs <- typs[!typs %in% exclude_types]
  
  if (!is.null(file) && file.exists(file)) {
    cli::cli_alert("Loading file {.file {file}}")
    
    return(read_tsv(file, show_col_types = FALSE, progress = FALSE))
  }
  
  # Identify DEGs
  only_pos <- all(log_fc > 0)
  
  degs <- typs %>%
    map_dfr(~ {
      so_in %>%
        subset(!!sym(type_clmn) == .x) %>%
        FindConservedMarkers(
          ident.1         = ident_1,
          ident.2         = ident_2,
          grouping.var    = rep_clmn,
          logfc.threshold = min(abs(log_fc)),
          only.pos        = only_pos,
          min.cells.group = 3
        ) %>%
        mutate(!!sym(type_clmn) := .x) %>%
        as_tibble(rownames = "gene")
    })
  
  # Filter DEGs
  # genes are only reported with fold change within log_fc for all replicates
  # and max_pval for replicates <pval
  # since we are combining p-values from multiple replicates, it is reasonable
  # to use the max unadjusted p-value for filtering
  reps     <- unique(unlist(so_in[[rep_clmn]], use.names = FALSE))
  fc_clmns <- str_c(reps, "_avg_log2FC")
  
  degs <- degs %>%
    filter(
      if_all(all_of(fc_clmns), ~ .x > log_fc[1] & .x < log_fc[2]),
      max_pval < pval
    ) %>%
    arrange(max_pval)

  if (!is.null(file)) write_tsv(degs, file)
  
  degs
}

#' Identify GO terms
#' 
#' By default all expressed genes are used as background for the cell type
#' This will include results for all terms with any overlap regardless of
#' significance, we need all terms for plotting enrichment scores
#' 
#' Terms with no overlap will not be included in results
#' 
#' @param genes Named list of differentially expressed genes for each cell type,
#' names should correspond to cell type labels found in type_clmn
#' @param so_in Seurat object so use for determining background gene set, if
#' `NULL` all genes are used
#' @param type_clmn Column in Seurat object containing cell types, these should
#' match the cell types provided by genes
#' @param max_term_size Maximum term size to include in results
#' @param min_term_size Minimum term size to include in results
#' @param db GO database to use, specify 'ALL' to use all three
#' @param simplify_terms Should GO terms be simplified to removed redundant
#' results, this has a significant effect on performance
#' @param n_bkgd Number of top expressed genes to include for the background
#' gene set
#' @param exclude_genes Regular expression to use for removing genes before
#' performing GO analysis, by default ribo protein and mito genes are excluded
#' @param org_db Bioconductor organism annotation database, should be class
#' OrgDb
#' @param sim_data Similarity data to use for simplifying GO terms, generated
#' using [clusterProfiler::godata()]
#' @param file Path to output file for saving results
get_go <- function(genes, so_in, type_clmn = "subtype", max_term_size = 750,
                   min_term_size = 10, db = "BP", simplify_terms = TRUE,
                   n_bkgd = Inf, exclude_genes = "^(Rp[sl]|mt-)",
                   org_db = org.Mm.eg.db, sim_data = go_sim_data, file = NULL) {
  
  # Check for save GO file
  # this function will save a tsv and a GO object
  obj_file <- str_c(file, ".qs")
  tbl_file <- str_c(file, ".tsv")
  
  if (!is.null(file) && file.exists(obj_file)) {
    cli::cli_alert("Loading file {.file {obj_file}}")
    
    return(qread(obj_file))
  }
  
  # Identify background gene set for each cell type
  # this includes all genes with >0 counts for any cell
  bkgd <- genes %>%
    imap(~ {
      bkgd <- NULL
      
      # so_in is required to determine background gene list
      # if genes is not named, all cells in so_in will be used
      if (!is.null(so_in)) {
        if (is.character(.y)) bkgd <- subset(so_in, !!sym(type_clmn) == .y)
        else                  bkgd <- so_in
        
        bkgd <- bkgd@assays$RNA@data %>%
          rowMeans() %>%
          sort(decreasing = TRUE) %>%
          head(n_bkgd)
        
        bkgd <- names(bkgd[bkgd > 0])
        
      } else {
        cli::cli_warn(
          "Background gene set can only be determined if so_in is provided"
        )
      }
      
      bkgd
    })
  
  # Identify GO terms for each gene list
  # exclude specified genes
  go <- genes %>%
    imap(~ {
      .x <- .x[!grepl(exclude_genes, .x)]
      
      g <- .x %>%
        enrichGO(
          keyType      = "SYMBOL",
          OrgDb        = org_db,
          universe     = bkgd[[.y]],
          maxGSSize    = max_term_size,
          minGSSize    = min_term_size,
          pvalueCutoff = 1.1,
          qvalueCutoff = 1.1,
          ont          = db
        )
      
      # Add background genes for each term to object
      # * this column is formatted in the same way as the geneID column
      # * these genes could be used to calculate overall fold enrichment for
      #   each cell type for GO clusters, i.e. determine total number of unique
      #   background genes overlapping all terms in the cluster
      # * overall fold enrichment scores for each cell type were not used
      #   in the final version of the GO heatmaps since the overall enrichment
      #   scores are on a much different scale as the other enrichement scores
      bkgd_gns <- g@result$ID %>%
        clusterProfiler::bitr(         # used to fetch gene symbols for GO terms
          fromType = "GOALL", toType = "SYMBOL",
          OrgDb = org.Mm.eg.db
        ) %>%
        filter(SYMBOL %in% bkgd[[.y]]) %>%
        split(.$GOALL)
      
      bkgd_gns <- bkgd_gns %>%
        map_chr(~ {
          .x$SYMBOL %>%
            unique() %>%
            str_c(collapse = "/")
        })
      
      g %>%
        mutate(bgID = bkgd_gns[ID])
    })
  
  # Merge GO objects  
  if (!is.null(names(go))) {
    go <- merge_result(go)
    
    go@fun <- "enrichGO"
    
  } else if (length(go) == 1) {
    go <- go[[1]]
  }
  
  # Simplify terms
  # this collapses terms that are very similar
  # this is very slow
  if (simplify_terms) {
    go <- go %>%
      clusterProfiler::simplify(semData = sim_data)
  }
  
  # Calculate enrichment scores
  go <- go %>%
    mutate(
      n_ovlp       = as.numeric(str_extract(GeneRatio, "^[0-9]+")),
      tot_genes    = as.numeric(str_extract(GeneRatio, "[0-9]+$")),
      n_bg_ovlp    = as.numeric(str_extract(BgRatio,   "^[0-9]+")),
      tot_bg_genes = as.numeric(str_extract(BgRatio,   "[0-9]+$")),
      enrichment   = (n_ovlp / tot_genes) / (n_bg_ovlp / tot_bg_genes)
    )
  
  # Save results
  if (!is.null(file)) {
    qsave(go, obj_file)
    
    go@compareClusterResult %>%
      write_tsv(tbl_file)
  }
  
  go
}

#' Cluster GO terms
#' 
#' @param go_in Object containing GO results
#' @param k Number of clusters to identify
#' @param pval Cutoff for filtering terms based on adjusted p-value, only
#' significant terms are used for clustering
#' @param qval Cutoff for filtering terms based on q-value
#' @param n_overlap Minimum number of genes needed to overlap term for it to be
#' included for clustering
#' @param n_shared Minimum number of cell types that term has to be shared with
#' for it to be included for clustering
#' @param sim_data Similarity data to use for clustering GO terms, generated
#' using [clusterProfiler::godata()]
#' @param min_term_size Minimum number of genes for term to be included
#' @param max_term_size Maximum number of genes for term to be included
#' @param exclude_cell_types Cell types to exclude from GO clustering
get_go_clusters <- function(go_in, k = 3, pval = 0.05, qval = 0.2, n_overlap = 3,
                            n_shared = 1, sim_data = go_sim_data,
                            min_term_size = -Inf, max_term_size = Inf,
                            exclude_cell_types = NULL) {
  
  # Identify significant GO terms
  go_in <- go_in %>%
    filter(
      p.adjust < pval, qvalue < qval,
      Count >= n_overlap,
      !Cluster %in% exclude_cell_types
    )
  
  # Calculate summary stats for each term
  # filter by min/max term size and number of cell types sharing the term
  # sort by number of cell types that share the term
  # these are the terms that will be used for clustering
  top_terms <- go_in@compareClusterResult %>%
    filter(                              # filter based on term size
      n_bg_ovlp >= min_term_size,
      n_bg_ovlp <= max_term_size
    ) %>%
    
    group_by(Description, ID) %>%
    summarize(
      n_cell_types = n_distinct(Cluster),  # number of cell types with term
      enrichment   = mean(enrichment),     # mean enrichment score
      p.adjust     = mean(p.adjust),       # mean p-value across cell types
      qvalue       = mean(qvalue),         # mean q-value across cell types
      .groups      = "drop"          
    ) %>%
    arrange(desc(n_cell_types), p.adjust) %>%
    dplyr::filter(n_cell_types >= n_shared)

  # Set number of clusters
  # must average > 2 terms per cluster
  if (nrow(top_terms) < 2) return(NULL)
  
  k <- min(k, floor(nrow(top_terms) / 2))
  
  # Calculate similarity metric for top terms
  # fill in upper triangle of matrix and filter terms
  # use top_terms determined previously
  go_dist <- go_in %>%
    pairwise_termsim(semData = sim_data) %>%
    .@termsim %>%
    fill_termsim(keep = top_terms$Description)
  
  # Cluster terms
  # use ward.D method to avoid overlapping ancestor nodes of each group
  hc <- stats::hclust(
    stats::as.dist(1 - go_dist),
    method = "ward.D"
  )
  
  clst_obj <- stats::cutree(hc, k)
  
  clsts <- tibble(
    Description = names(clst_obj),
    cluster     = unname(clst_obj)
  )
  
  # Format output object
  res <- clsts %>%
    left_join(top_terms, by = "Description") %>%
  
    arrange(cluster, desc(n_cell_types), p.adjust) %>%
    group_by(cluster) %>%
    mutate(
      cluster_n_terms = n_distinct(Description),
      cluster_mean_p  = mean(p.adjust)
    ) %>%
    ungroup() %>%
    arrange(cluster, desc(n_cell_types), p.adjust)
  
  res <- list(
    clusters = res,             # data.frame with cluster stats/assignments
    object   = hc,              # hclust object
    clusters_object = clst_obj  # vector of cluster assignments
  )
  
  res
}

#' Create heatmaps summarizing GO clusters for each cell type
#' 
#' @param df_in data.frame containing clustering results generated with
#' get_clusters(), this provides the terms and cluster assignments to plot
#' @param go_in Object containing GO results, this is used to plot p-values and
#' GeneRatio for each cell type
#' @param n_clusters Number of top GO clusters to plot, clusters are sorted by
#' number of terms, with the top clusters having the most terms
#' @param n_terms The number of top terms to show for each cluster, terms are
#' sorted by the number of cell types that share the term and the overall mean
#' p-value for the term (averaged across all cell types)
#' @param pval Adjusted p-value cutoff for marking significant terms, this
#' cutoff should match the cutoff used for clustering GO terms
#' @param qval q-value cutoff for marking significant terms
#' @param n_overlap Minimum number of genes needed to overlap the term for it to
#' be marked as significant
#' @param n_genes Minimum number of DEGs for cell type to be included on plot
#' @param clrs Colors to use for each cluster
#' @param n_col Number of columns to use for organizing facets (each cluster is
#' plotted as a separate facet)
#' @param clusters Which clusters to plot, this overrides n_clusters
#' @param include_overall_score Include row in heatmap showing combined
#' enrichment score for each cell type
#' @param free_y Allow height of each heatmap to differ based on the number of
#' rows
#' @param cluster_labels Vector containing descriptive labels for each cluster
#' @param exclude_cell_types Cell types to exclude from plot
create_go_heatmap <- function(df_in, go_in, n_clusters = 2, n_terms = 5,
                              pval = 0.05, qval = 0.2, n_overlap = 3,
                              n_genes = 3,
                              clrs = c("orange", "lightblue", "red"), n_col = 1,
                              clusters = NULL, include_overall_score = FALSE,
                              free_y = FALSE, cluster_labels = NULL,
                              exclude_cell_types = NULL) {
  
  # Top GO clusters to show
  # selected based on number of terms belonging to each cluster
  top_clusters <- clusters %||%
    df_in$cluster %>%
    table() %>%
    sort(decreasing = TRUE) %>%
    head(n_clusters) %>%
    names()
  
  # Data for heatmap
  # filter cell types (Cluster column)
  cluster_ids <- df_in %>%
    dplyr::select(Description, cluster, n_cell_types)
  
  dat <- go_in@compareClusterResult %>%
    as_tibble() %>%
    left_join(cluster_ids, by = "Description") %>%
    filter(
      cluster %in% top_clusters,
      !Cluster %in% exclude_cell_types
    ) %>%
    mutate(
      significant = p.adjust < pval & qvalue < qval & n_ovlp >= n_overlap,
      enriched    = ifelse(significant, "Significant", "NS")  # this is used to add diamond
    )
  
  # Top GO terms to plot
  # df_in includes combined GO terms identified across all cell types
  # sorted based on number of cell types sharing term, then mean enrichment
  terms <- dat %>%
    filter(significant) %>%
    group_by(Description, ID, cluster) %>%
    summarize(                               # recalculate since some cell types
      n_cell_types = n_distinct(Cluster),    # removed with exclude_cell_types
      enrichment   = mean(enrichment),
      .groups = "drop"
    ) %>%
    arrange(cluster, desc(n_cell_types), desc(enrichment)) %>%
    group_by(cluster) %>%
    dplyr::slice(1:n_terms) %>%
    ungroup()
  
  term_lvls <- rev(terms$Description)
  
  dat <- dat %>%
    filter(ID %in% terms$ID)
  
  # Sort cell types based on number of significant terms and max enrichment
  # score
  typ_lvls <- dat %>%
    group_by(Cluster) %>%
    summarize(
      n_terms = length(ID[significant]),
      max_enr = max(enrichment),
      .groups = "drop"
    ) %>%
    arrange(desc(n_terms), desc(max_enr)) %>%
    pull(Cluster) %>%
    as.character()
  
  # Format term labels
  dat <- dat %>%
    mutate(Description = fct_relevel(Description, term_lvls)) %>%
    arrange(Description) %>%
    mutate(
      Description = str_trunc(
        as.character(Description), width = 70, side = "right"
      ),
      Description = str_wrap(Description, width = 40),
      Description = fct_inorder(Description),
      Cluster     = fct_relevel(Cluster, typ_lvls)
    )
  
  # Create heatmap
  if (length(clrs) == 1) scale_clr <- clrs
  else                   scale_clr <- "black"
  
  al_scale <- list(range = c(0, 1))
  
  if (max(dat$enrichment) < 70) al_scale$breaks <- seq(0, 70, 15)
  
  res <- dat %>%
    ggplot(aes(Cluster, Description, fill = as.character(cluster), alpha = enrichment)) +
    geom_tile() +
    geom_point(
      aes(color = enriched, fill = NULL),
      data   = ~ filter(.x, significant),
      alpha  = 1,
      shape  = 5,
      size   = 3,
      stroke = 1.2
    ) +
    scale_color_manual(values = "black") +
    scale_fill_manual(values = clrs) +
    lift_dl(scale_alpha_continuous)(al_scale) +
    scale_x_discrete(labels = ~ str_replace(.x, "_", " ")) +
    guides(
      alpha = guide_legend(
        keyheight      = unit(7, "pt"),
        label.position = "bottom",
        order          = 1,
        title          = "Enrichment Score",
        title.position = "top",
        nrow           = 1,
        override.aes   = list(fill = scale_clr)
      ),
      color = guide_legend(
        title          = NULL,
        label.position = "top",
        label.theme    = element_text(size = ttl_pt2),
        label.vjust    = 0.45,
        override.aes   = list(size = 4.5, stroke = 1.7),
      ),
      fill = "none"
    ) +
    base_theme +
    theme(
      legend.position    = "bottom",
      legend.title.align = 0.5,
      legend.key.width   = unit(25, "pt"),
      axis.title         = element_blank(),
      axis.text.x        = element_text(angle = 45, hjust = 1),
      strip.clip         = "off"
    )
  
  if (free_y) {
    res <- res +
      facet_grid(
        rows = "cluster",
        scales = "free_y", space = "free_y",
        labeller = cluster_labels %||% "label_value"
      )
  } else {
    n_terms <- terms %>%
      group_by(cluster) %>%
      summarize(n = n_distinct(Description), .groups = "drop") %>%
      pull(n) %>%
      max()
    
    res <- res +
      facet_wrap(
        ~ cluster, ncol = n_col, scales = "free_y",
        labeller = cluster_labels %||% "label_value"
      ) +
      theme(aspect.ratio = n_terms / n_distinct(dat$Cluster))
  }
  
  res <- list(
    heatmap = res,
    terms = terms
  )
  
  res
}

#' Identify top genes to plot for GO clusters
#' 
#' This will return the top genes to plot based on the number of cell types
#' differentially expressing the gene and the minimum p-value for the gene.
#' 
#' If a vector of gene names is provided, this will check that all the
#' provided genes are differentially expressed and overlap a GO term for at
#' least one cell type
#' 
#' @param go_in data.frame containing GO results (compareClusterResult)
#' @param degs_in data.frame containing DEG results
#' @param clust_in data.frame containing cluster assignments for each GO term
#' @param genes Either the number of genes to plot or a vector of gene names
#' to plot
#' @param exclude_cell_types Cell types to exclude when identifying genes to
#' plot
#' @return vector containing GO cluster assignments for each top gene (cluster
#' with at least one term the gene overlaps)
#' @export
get_go_genes <- function(go_in, degs_in, clust_in, genes = 5,
                         exclude_cell_types = NULL) {
  
  # Format GO cluster data
  # go_in has genes overlapping each term
  # clust_in has cluster assignments for each term
  # sort by number of cell types sharing the term (Cluster column)
  gns <- go_in %>%
    filter(!Cluster %in% exclude_cell_types) %>%
    right_join(clust_in, by = "Description") %>%
    mutate(geneID = str_split(geneID, "/")) %>%
    unnest(geneID) %>%
    group_by(geneID, cluster) %>%
    summarize(n = n_distinct(Cluster), .groups = "drop") %>%
    distinct(geneID, .keep_all = TRUE) %>%
    arrange(cluster, desc(n))
  
  # Calculate gene expression stats
  # sort by number of cell types sharing the term and smallest DEG p-value for
  # the gene (summarizing p-values across cell types for the gene)
  exp_dat <- degs_in %>%
    filter(gene %in% gns$geneID) %>%
    group_by(gene) %>%
    summarize(pval = min(max_pval), .groups = "drop")
  
  gns <- gns %>%
    left_join(exp_dat, by = c(geneID = "gene")) %>%
    arrange(cluster, desc(n), pval)
  
  # Pull top genes
  if (is.numeric(genes)) {
    gns <- gns %>%
      group_by(cluster) %>%
      dplyr::slice(1:genes)
    
  } else {
    gns <- gns %>%
      filter(geneID %in% genes)
    
    if (any(!genes %in% gns$geneID)) {
      cli_warn("Some genes are not present in GO and/or DEG data")
    }
  }
  
  gns <- set_names(
    as.character(gns$cluster),
    gns$geneID
  )
  
  gns
}

#' Create line graphs plotting mean expression of upregulated genes
#' 
#' @param all_exp_data Named list of Seurat objects containing all expression
#' data wanting to plot
#' @param all_degs_data Named list of data.frames containing DEGs, this is used to
#' determine which genes are upregulated for each cell type and timepoint. DEGs
#' need to be provided for each Seurat object provided to all_exp_data
#' @param genes Named vector specifying genes to plot, the names should be the
#' gene symbol and the values should be the cluster ID. Genes can be colored
#' based on cluster ID
#' @param clrs Colors to use for each cluster
#' @param cell_types The number of top cell types to include, cell types with
#' the most upregulated genes will be included. Alternatively a vector of cell
#' types to include can be provided.
#' @param lvls Levels to use for ordering values in treatment column
#' @param n_cells Number of cells that must be present for each replicate of
#' each treatment group for a line to be shown for the timepoint/cell type
#' @param only_show_upreg Only show cell types with at least one gene
#' upregulated for any of the timepoints
#' @param exclude_cell_types Cell types to exclude from plot
create_go_gene_plots <- function(all_exp_data = list("8hpi" = so_8, "24hpi" = so_merge),
                                 all_degs_data = list("8hpi" = degs$`so_8-up`,
                                                 "24hpi" = degs$`so_merge-up`),
                                 genes,
                                 clrs = c(`1` = "orange"), cell_types = 10,
                                 lvls = c("mock", "8hpi", "24hpi"), n_cells = 10,
                                 type_clmn = "lec_type", only_show_upreg = TRUE,
                                 exclude_cell_types = NULL, ln_size = 0.75, pt_size = 1.5,
                                 ttl = "Differentially\nexpressed",
                                 cell_type_lvls = NULL) {
  
  # Genes to plot
  gns <- names(genes) %||% genes
  
  # Format gene expression input data
  all_exp_data <- all_exp_data %>%
    imap_dfr(~ {
      .x %>%
        FetchData(c(type_clmn, "orig.ident", "treatment", "rep", gns)) %>%
        as_tibble(rownames = ".cell_id") %>%
        mutate(tm = .y) %>%
        pivot_longer(all_of(gns))
    }) %>%
                                                     # only use mock data and 8hpi data from 8hpi object
    filter(treatment != "8hpi" | tm != "24hpi") %>%  # exclude 8hpi CHIKV data from 24hpi objects (e.g. so_merge)
    filter(tm == "8hpi" | treatment != "mock") %>%   # exclude mock data from 24hpi objects (e.g. so_24)
                                                     # redefine treatment as mock or tm
    
    filter(!(!!sym(type_clmn)) %in% c("other", "unassigned")) %>%  # do not show other and unassigned cells
    mutate(treatment = ifelse(treatment %in% lvls, treatment, tm))
    
  # Only include samples with >10 cells for each replicate
  all_exp_data <- all_exp_data %>%
    group_by(!!sym(type_clmn), treatment) %>%
    mutate(reps = list(unique(rep))) %>%
    group_by(!!sym(type_clmn), treatment, rep) %>%
    filter(n_distinct(.cell_id) >= n_cells) %>%
    
    group_by(!!sym(type_clmn), treatment) %>%
    filter(all(unique(unlist(reps)) %in% rep)) %>%
    group_by(!!sym(type_clmn), name) %>%
    filter(n_distinct(treatment) > 1) %>%
    ungroup()
  
  # Format DEG input data
  all_degs_data <- all_degs_data %>%
    imap_dfr(~ {
      .x %>%
        dplyr::filter(gene %in% gns) %>%
        dplyr::mutate(treatment = .y) %>%
        dplyr::select(gene, treatment, !!sym(type_clmn), max_pval)
    })
  
  # Filter for top cell types to plot
  all_exp_data <- all_exp_data %>%
    filter(!(!!sym(type_clmn) %in% exclude_cell_types))
  
  all_degs_data <- all_degs_data %>%
    filter(!(!!sym(type_clmn) %in% exclude_cell_types))
  
  if (!is.null(cell_types)) {
    if (is.numeric(cell_types)) {
      all_types <- distinct(all_exp_data, lec_type)  # Cell types with no DEGs will
                                                     # not be included in all_degs_data,
      cell_types <- all_degs_data %>%                # add these as 0's
        group_by(!!sym(type_clmn)) %>%
        summarize(n_genes = n(), .groups = "drop") %>%
        full_join(all_types, by = "lec_type") %>%
        mutate(n_genes = replace_na(n_genes, 0)) %>%
        arrange(desc(n_genes)) %>%
        head(cell_types) %>%
        pull(type_clmn)
    }
    
    all_exp_data <- all_exp_data %>%
      dplyr::filter(!!sym(type_clmn) %in% cell_types)
  }
  
  # Format data for plotting points
  plt_dat <- all_exp_data %>%
    group_by(!!sym(type_clmn), treatment, name) %>%
    summarize(
      n       = n(),
      q3      = quantile(value, 0.75),
      q1      = quantile(value, 0.25),
      value   = median(value),
      .groups = "drop"
    ) %>%
    mutate(
      x_end     = match(treatment, lvls),
      x         = x_end - 1,
      treatment = fct_relevel(treatment, lvls),
      cluster   = genes[name],
      name      = fct_relevel(name, gns)
    )
  
  # Format data for plotting lines
  # plot as segments so linetype can be varied based on significance
  # need to pull table of DEGs to determine which timepoints/genes are signif
  # pull median expression to use for the start and end of each segment
  exp_dat <- plt_dat %>%
    dplyr::select(name, treatment, !!sym(type_clmn), value)
  
  ln_dat <- plt_dat %>%
    left_join(all_degs_data, by = c(name = "gene", "treatment", type_clmn)) %>%
    
    dplyr::filter(x > 0) %>%  # remove rows that start at 0 (occurs for mock)
    
    # need to set columns with treatment labels for segment start/end so
    # correct expression values can be pulled
    mutate(trt_end = lvls[x_end], trt_start = lvls[x]) %>%
    
    dplyr::select(
      name, treatment, !!sym(type_clmn), cluster,
      x, x_end, trt_start, trt_end,
      max_pval
    ) %>%
    
    left_join(exp_dat, by = c("name", trt_start = "treatment", type_clmn)) %>%
    dplyr::rename(y = value) %>%
    
    left_join(exp_dat, by = c("name", trt_end = "treatment", type_clmn)) %>%
    dplyr::rename(y_end = value) %>%
    
    mutate(
      Upregulated       = as.character(!is.na(max_pval)),
      Upregulated       = fct_relevel(Upregulated, c("TRUE", "FALSE")),
      name              = fct_relevel(name, gns),
      !!sym(type_clmn) := fct_relevel(!!sym(type_clmn), cell_type_lvls)
    )
  
  # Only show cell types with at least one gene upregulated for any timepoint
  if (only_show_upreg) {
    ln_dat <- ln_dat %>%
      group_by(!!sym(type_clmn)) %>%
      filter(any(Upregulated == "TRUE")) %>%  # filter like this since column
      ungroup()                               # converted to factor for plotting
  }
  
  if (nrow(ln_dat) == 0) return(NULL)
  
  # Create plots
  aspect <- length(gns) / n_distinct(plt_dat$name) * 0.9
  
  res <- plt_dat %>%
    filter(!!sym(type_clmn) %in% unique(pull(ln_dat, type_clmn))) %>%
    mutate(!!sym(type_clmn) := fct_relevel(!!sym(type_clmn), cell_type_lvls)) %>%
    ggplot(aes(treatment, value, color = cluster)) +
    
    geom_errorbar(
      aes(x = treatment, ymin = q1, ymax = q3),
      color = "grey80",
      width = 0,
      linewidth = pt_size
    ) +
    geom_point(size = pt_size) +
    geom_segment(
      aes(
        x = x, xend = x_end, y = y, yend = y_end,
        linetype = Upregulated
      ),
      linewidth = ln_size,
      data  = ln_dat
    ) +
    facet_grid(
      as.formula(str_c("name ~ ", type_clmn)),
      switch = "y", scales = "free_y",
      labeller = as_labeller(~ str_replace(.x, "_", " "))
    ) +
    
    scale_linetype_manual(values = c("TRUE" = 1, "FALSE" = 3)) +
    scale_color_manual(values = clrs) +
    scale_y_continuous(
      breaks = ~ c(0, floor(max(.x))),
      limits = ~ c(.x[1], ifelse(.x[2] < 1, 1, .x[2])),  # set 1 as lowest upper limit
      expand = expansion(c(0.2, 0.05))
    ) +
    scale_x_discrete(labels = c(mock = "m", `8hpi` = "8", `24hpi` = "24")) +
    guides(
      color = "none",
      linetype = guide_legend(
        title = ttl, title.position = "top",
        override.aes = list(linewidth = 1.5)
      )
    ) +
    
    base_theme +
    theme(
      aspect.ratio       = aspect,
      legend.position    = "bottom",
      legend.key.width   = unit(20, "pt"),
      legend.title.align = 0.5,
      legend.text        = element_text(size = ttl_pt1),
      strip.placement    = "outside",
      strip.clip         = "off",
      strip.text         = element_text(size = ttl_pt1),
      axis.title         = element_blank()
    )
  
  res
}

#' Create expanded GO summary plots
#' 
#' @param go_in data.frame containing GO results (compareClusterResult)
#' @param degs_in data.frame containing DEG results, this is used to select
#' the top differentially expressed genes for go_in
#' @param all_exp_data Named list of Seurat objects containing all expression
#' data wanting to plot
#' @param all_degs_data Named list of data.frames containing DEGs, this is used to
#' determine which genes are upregulated for each cell type and timepoint. DEGs
#' need to be provided for each Seurat object provided to all_exp_data
#' @param n_clusters Number of top GO clusters to plot, clusters are sorted by
#' number of terms, with the top clusters having the most terms
#' @param n_terms The number of top terms to show for each cluster, terms are
#' sorted by the number of cell types that share the term and the overall mean
#' p-value for the term (averaged across all cell types)
#' @param n_genes Number of top genes to plot for each GO cluster
#' @param pval Adjusted p-value cutoff for marking significant terms
#' @param n_overlap Minimum number of genes needed to overlap the term for it to
#' be marked as significant
#' @param n_shared Minimum number of cell types that term has to be shared with
#' for it to be included
#' @param exclude_cell_types Cell types to exclude from plots
create_go_summary_plots <- function(go_in, degs_in,
                                    all_exp_data = list(
                                      "8hpi" = so_8, "24hpi" = so_merge
                                    ),
                                    all_degs_data = list(
                                      "8hpi"  = degs[["so_8-up_lectype"]],
                                      "24hpi" = degs[["so_merge-up_lectype"]]
                                    ),
                                    n_clusters = 5, n_terms = 6, n_genes = 4,
                                    pval = 0.05, n_overlap = 3, n_shared = 1,
                                    only_show_upreg = TRUE,
                                    exclude_cell_types = NULL
                                    ) {
  
  # Cluster GO terms
  clsts <- go_in %>%
    get_go_clusters(
      k         = n_clusters,
      pval      = pval,
      n_overlap = n_overlap,
      n_shared  = n_shared,
      exclude_cell_types = NULL
    )
  
  if (is.null(clsts)) return(NULL)
  
  # Create tree
  clst_ids <- as.character(unique(sort(clsts$clusters$cluster)))
  
  clst_clrs <- set_names(
    unname(type_cols)[1:n_distinct(clst_ids)],
    clst_ids
  )
  
  cl <- split(
    names(clsts$clusters_object),
    clsts$clusters_object
  )
  
  tr <- ggtree(clsts$object, linewidth = 1)
  
  clades <- cl %>%
    map_int(~ MRCA(tr, .x))
  
  tr <- groupClade(tr, clades, group_name = "cluster") +
    aes(color = cluster) +
    scale_color_manual(values = clst_clrs) +
    geom_tiplab(angle = 90, hjust = 1, nudge_x = -0.1) +
    layout_dendrogram() +
    theme(
      legend.position = "none",
      plot.margin = margin(6, 6, 250, 6)
    )
  
  # Create heatmaps
  heat <- clsts$clusters %>%
    create_go_heatmap(
      go_in      = go_in,
      n_overlap  = n_overlap,
      n_clusters = n_clusters,
      n_genes    = 0,           # Min genes represented on plot for cell type
      n_terms    = n_terms,     # to be shown on plot
      n_col      = 1,
      free_y     = FALSE,
      clrs       = clst_clrs,
      exclude_cell_types = exclude_cell_types
    )
  
  heat$heatmap <- heat$heatmap +
    theme(axis.text = element_text(size = 10))
  
  # Example genes to plot
  heat_terms <- heat$terms %>%
    dplyr::select(Description, cluster, ID)
  
  gns <- get_go_genes(
    go_in    = go_in@compareClusterResult,
    degs_in  = degs_in,
    clust_in = heat_terms,
    genes    = n_genes,
    exclude_cell_types = exclude_cell_types
  )
  
  # Create gene plots
  gn_plts <- create_go_gene_plots(
    all_exp_data       = all_exp_data,
    all_degs_data      = all_degs_data,
    genes              = gns,
    cell_types         = Inf,
    clrs               = clst_clrs,
    only_show_upreg    = only_show_upreg,
    exclude_cell_types = exclude_cell_types
  ) +
    theme(
      plot.margin = margin(6, 40, 6, 40, unit = "pt"),
      axis.text   = element_text(size = 7),
      strip.text  = element_text(size = 8)
    )
  
  # Create final figure
  bot <- plot_grid(
    heat$heatmap + theme(plot.margin = margin(6, 40, 6, 40, unit = "pt")),
    gn_plts,
    nrow = 1,
    labels = c("B", "C"),
    rel_widths = c(0.9, 1),
    align = "h",
    axis  = "tb"
  )
  
  res <- plot_grid(
    tr, bot,
    ncol = 1,
    rel_heights = c(0.3, 1),
    labels = "A"
  )
  
  res
}
```

```{r "setup parameters"}
# Check for saved objects
create_obj <- !file.exists(here(params$so_dir, "so_merge.qs"))

# Cell types for FRCs and LECs
frc_cell_types <- c("Fibroblasts", "Stromal cells", "Stromal cells (DN)")
lec_cell_types <- "Endothelial cells"

# Treatment labels
treat_key <- c(
  M  = "mock",
  A  = "CHIKV",
  AF = "CHIKV"
)

# CHIKV group labels
chikv_grps <- c("CHIKV-low", "CHIKV-high")
```

```{r "references"}
# LEC reference
ref_lec <- ref_immgen[, grepl("^Endothelial cells", colnames(ref_immgen))]
ref_lec <- ref_lec[rownames(ref_lec) %in% rownames(ref_LEC_xiang), ]

colnames(ref_lec) <- colnames(ref_lec) %>%
  str_replace("Endothelial cells \\(BEC\\)", "BEC")

ref_LEC_xiang <- ref_LEC_xiang[rownames(ref_lec), ]

stopifnot(identical(rownames(ref_LEC_xiang), rownames(ref_lec)))

ref_lec <- cbind(ref_LEC_xiang, ref_lec)
ref_lec <- ref_lec[, !grepl("^Endothelial cells", colnames(ref_lec))]

# Fibroblast/stromal cell reference
ref_frc <- ref_immgen[, grepl("^Fibroblast", colnames(ref_immgen))]
ref_frc <- ref_frc[rownames(ref_frc) %in% rownames(ref_lymphnodestromal), ]

ref_lymphnodestromal <- ref_lymphnodestromal[rownames(ref_frc), ]

stopifnot(identical(rownames(ref_lymphnodestromal), rownames(ref_frc)))

ref_frc <- cbind(ref_lymphnodestromal, ref_frc)
```

```{r "create 8hpi object", include = FALSE, eval = create_obj}
# Create Seurat object
mats <- here(params$unenr_dir) %>%
  list.dirs(recursive = FALSE, full.names = FALSE) %>%
  set_names() %>%
  map_chr(~ here(file.path(params$unenr_dir, .x, "outs/filtered_feature_bc_matrix")))

sobjs <- mats %>%
  imap(~ create_virus_obj(
    mat_dir     = .x,
    proj_name   = .y,
    gene_min    = params$gene_min,
    gene_max    = params$gene_max,
    mito_max    = params$mito_max,
    virus_str   = "^CHIKV",
    virus_assay = "CHIKV"
  ))

# Calculate CHIKV stats
# since there are very few cells with detectable CHIKV counts, did not adjust
# QC filter based on CHIKV counts
sobjs <- sobjs %>%
  map(~ {
    .x %>%
      mutate_meta(~ {
        .x %>%
          rename_with(
            .cols = starts_with("CHIKV_AF15561"),
            ~ str_remove(.x, "_AF15561")
          )
      })
  })

# Format sample/replicate names
sobjs <- sobjs %>%
  map(~ {
    .x %>%
      mutate_meta(
        mutate,
        treatment  = str_extract(orig.ident, "^[A-Z]+"),
        treatment  = treat_key[treatment],
        rep        = str_extract(orig.ident, "[0-9]+$"),
        tm         = params$tm,
        orig.ident = str_c(treatment, "-", rep),
        sample     = str_c(treatment, tm, rep, sep = "-")
      )
  })

# Filter, normalize, and merge objects
# cell calls from cellranger do not look as accurate for AF2 (CHIKV-2)
# to account for this remove cells with <= 800 UMIs
sobjs <- sobjs %>%
  map(~ {
    .x %>%
      mutate_meta(
        mutate,
        qc_class = ifelse(
          orig.ident == "CHIKV-2" & nCount_RNA <= 800,
          "low_umi_count",
          qc_class
        )
      )
  })

so <- sobjs %>%
  map(~ {
    .x %>%
      subset(subset = qc_class == "pass") %>%
      norm_sobj(
        cc_scoring = TRUE,
        rna_method = "LogNormalize",
        scale_data = FALSE
      )
  })

so <- merge(so[[1]], so[-1])

# Cluster cells
so <- so %>%
  FindVariableFeatures(
    assay            = "RNA",
    selection.method = "vst",
    nfeatures        = 2000
  ) %>%
  ScaleData(
    assay           = "RNA",
    vars.to.regress = "nCount_RNA"
  ) %>%
  cluster_RNA(
    resolution = c(1, 3, 5, 10),
    dims       = 1:40
  )

# Save unfiltered objects and meta.data
# Save and delete raw objects asap to free up memory
so_raw <- merge(sobjs[[1]], sobjs[-1])

save_objs(so_raw, "so_raw_8", ob_dir = params$so_dir)

so_raw_df <- read_tsv(
  here(params$so_dir, "so_raw_8.tsv.gz"),
  show_col_types = FALSE, progress = FALSE
)

rm(sobjs, so_raw)
```

```{r "add enriched counts to 8hpi object", eval = create_obj}
# Create Seurat object for CHIKV-enriched data
mats <- here(params$enr_dir) %>%
  list.dirs(recursive = FALSE, full.names = FALSE) %>%
  set_names() %>%
  map_chr(~ here(file.path(params$enr_dir, .x, "outs/filtered_feature_bc_matrix")))

so_enr <- mats %>%
  imap(~ {
    .x %>%
      create_virus_obj(
        proj_name   = .y,
        virus_str   = "^CHIKV",
        virus_assay = "CHIKV"
      )
  })

so_enr <- merge(so_enr[[1]], so_enr[-1])

# Format sample/replicate names
so_enr <- so_enr %>%
  mutate_meta(
    mutate,
    treatment  = str_extract(orig.ident, "^[A-Z]+"),
    treatment  = treat_key[treatment],
    rep        = str_extract(orig.ident, "[0-9]+$"),
    tm         = params$tm,
    orig.ident = str_c(treatment, "-", rep),
    sample     = str_c(treatment, tm, rep, sep = "-")
  )

# Add new CHIKV counts to meta.data from unfiltered Seurat objects
# create table with all cells from raw and enriched objects combined
chikv_feats <- c(
  "enr_5"            = "chikv_CHIKV-AF15561-5",
  "enr_sgRNA"        = "chikv_CHIKV-AF15561-sgRNA",
  "enr_neg"          = "chikv_CHIKV-AF15561-neg",
  "enr_nCount_CHIKV" = "nCount_CHIKV",
  "enr_pct_CHIKV"    = "pct_CHIKV",
  "enr_nCount_RNA"   = "nCount_RNA"
)

get_feats <- c("orig.ident", chikv_feats)

so_enr_df <- so_enr %>%
  FetchData(get_feats) %>%
  dplyr::rename(!!!chikv_feats) %>%
  rownames_to_column("cell_id")

so_enr_df <- so_raw_df %>%
  full_join(so_enr_df, by = c("cell_id", "orig.ident"))

clmns <- c(
  "cell_id", "orig.ident",
  "UMAP_1", "UMAP_2"
)

# Add UMAP coordinates to data.frame
# cells that did not pass QC will have NAs
so_enr_df <- so@meta.data %>%
  as_tibble(rownames = "cell_id") %>%
  dplyr::select(all_of(clmns)) %>%
  full_join(so_enr_df, by = c("cell_id", "orig.ident"))

# Format enriched counts
enr_counts <- so_enr_df %>%
  mutate(
    across(starts_with("enr_"), ~ replace_na(.x, 0)),
    
    enr_pct_CHIKV = (enr_nCount_CHIKV / (enr_nCount_CHIKV + enr_nCount_RNA)) * 100,
    enr_pct_CHIKV = replace_na(enr_pct_CHIKV, 0),  # small number of cells have 0 total enr counts
    
    tot_nCount_CHIKV = nCount_CHIKV + enr_nCount_CHIKV,
    tot_nCount_RNA   = nCount_RNA   + enr_nCount_RNA,
    tot_pct_CHIKV    = (tot_nCount_CHIKV / (tot_nCount_CHIKV + tot_nCount_RNA)) * 100,
    
    tot_5     = CHIKV_5     + enr_5,
    tot_sgRNA = CHIKV_sgRNA + enr_sgRNA,
    tot_neg   = CHIKV_neg   + enr_neg
  ) %>%
  dplyr::select(cell_id, starts_with("tot_"), starts_with("enr_")) %>%
  column_to_rownames("cell_id")

# Add enriched counts to object
# use enriched counts to identify CHIKV-high
# lose 7 cells that have >0 unenriched counts but 0 enriched counts
so <- so %>%
  AddMetaData(enr_counts) %>%
  mutate_meta(
    mutate,
    chikv_grp     = ifelse(enr_nCount_CHIKV > 0, chikv_grps[2], chikv_grps[1]),
    tot_chikv_grp = ifelse(tot_nCount_CHIKV > 0, chikv_grps[2], chikv_grps[1])
  )

# Check that samples are in the same order for the enriched and unenriched objects
# this is important for matching the cell barcodes
stopifnot(identical(unique(so$orig.ident), unique(so_enr_df$orig.ident)))

# Save objects
save_objs(so, "so_8", ob_dir = params$so_dir)
save_objs(so_enr, "so_enr_8", ob_dir = params$so_dir, save_meta = FALSE)

# Save enriched table that includes stats for all cells regardless of QC
so_enr_df %>%
  write_tsv(here(params$so_dir, "so_enr_8.tsv.gz"), progress = FALSE)

rm(so_enr)
```

```{r "integrate samples", eval = create_obj}
# Adjust 8 and 24 hpi objects for integration
# calculate sgRNA ratio with and without pseudo count
so_24 <- params$so_24 %>%
  read_rds() %>%
  mutate_meta(
    mutate,
    tm = "24hpi",
    sgRNA_ratio        = CHIKV_sgRNA / CHIKV_5,
    sgRNA_ratio_pseudo = (CHIKV_sgRNA + 1) / (CHIKV_5 + 1)
  )

so_8 <- so

rm(so)

so_8  <- RenameCells(so_8,  add.cell.id = "8hpi")
so_24 <- RenameCells(so_24, add.cell.id = "24hpi")

# Merge 8 and 24 hpi objects
so_merge <- merge(so_8, so_24) %>%
  FindVariableFeatures(nfeatures = 2000) %>%
  ScaleData() %>%
  RunPCA() %>%
  RunUMAP(dims = 1:40)
  
# Integrate samples
# integrate 24hpi-CHIKV samples with remaining samples
so_merge <- so_merge %>%
  mutate_meta(
    mutate,
    integration_var = ifelse(
      tm == "24hpi" & treatment == "CHIKV",
      "chikv_24hpi", "other"
    )
  ) %>%
  RunHarmony(
    c("rep", "integration_var"),
    dims = 1:40, plot_convergence = TRUE
  ) %>%
  RunUMAP(
    dims = 1:40,
    reduction      = "harmony",
    reduction.name = "humap",
    reduction.key  = "hUMAP_"
  ) %>%
  FindNeighbors(reduction = "harmony", dims = 1:40) %>%
  FindClusters(resolution = 5:10)
```

```{r "broad cell types", eval = create_obj}
# Classify broad cell types
type_clst <- str_c("RNA_snn_res.", params$type_res)

so_merge <- so_merge %>%
  mutate_meta(
    dplyr::select,
    -any_of(c("UMAP_1", "UMAP_2", "rough_type", "rough_r", "b_score", "t_score"))
  ) %>%
  clustify(
    ref_mat       = ref_immgen,
    cluster_col   = type_clst,
    rename_prefix = "rough",
    n_genes       = 2000,
    threshold     = 0.6
  )

# Annotate B and T cells
# These cells are often mis-classified
so_merge <- so_merge %>%
  classify_markers(
    feats    = "Cd19",
    filt     = Cd19 > 0.4,
    type     = "B cells",
    clst_col = type_clst,
    type_col = "rough_type"
  ) %>%
  classify_markers(
    feats    = "Cd3e",
    filt     = Cd3e > 0.4,
    type     = "T cells",
    clst_col = type_clst,
    type_col = "rough_type"
  )

# Annotate erythrocytes based on Hba expression
so_merge <- so_merge %>%
  classify_markers(
    feats    = "Hba-a1",
    filt     = `Hba-a1` > 2,
    type     = "Erythrocytes",
    clst_col = type_clst,
    type_col = "rough_type"
  )

# Annotate potential FDCs based on Pdpn, Pecam1, and Cr2 expression
# These cells are often unassigned by clustifyr
so_merge <- so_merge %>%
  classify_markers(
    feats    = c("Pdpn", "Pecam1", "Cr2"),
    filt     = Pdpn > 0.3 & Pecam1 < 0.3 & Cr2 > 1,
    type     = "Fibroblasts",
    clst_col = type_clst,
    type_col = "rough_type"
  ) %>%
  mutate_meta(mutate, cell_type = str_remove(rough_type, " \\(.+$"))
```

```{r "fibroblast subsets", eval = create_obj}
# Recluster fibroblasts and annotate PvCs
so_frc <- so_merge %>%
  subset(cell_type %in% frc_cell_types) %>%
  FindVariableFeatures(nfeatures = 2000) %>%
  ScaleData() %>%
  RunPCA()
  
so_frc <- so_frc %>%
  RunHarmony(
    c("rep", "integration_var"),
    dims = 1:40, plot_convergence = TRUE
  ) %>%
  RunUMAP(
    dims = 1:40,
    reduction      = "harmony",
    reduction.name = "humap",
    reduction.key  = "hUMAP_"
  ) %>%
  FindNeighbors(reduction = "harmony", dims = 1:40) %>%
  FindClusters(resolution = 1:5)

# Set PvCs
# Integration is not great for Cxcl9+ TRCs
# Works good for PvCs
frc_clst <- str_c("RNA_snn_res.", params$frc_res)

so_frc <- so_frc %>%
  mutate_meta(
    dplyr::select,
    -any_of(c("UMAP_1", "UMAP_2", "frc_type", "frc_subtype", "frc_r"))
  ) %>%
  clustify(
    ref_mat       = ref_frc,
    cluster_col   = frc_clst,
    rename_prefix = "frc",
    n_genes       = 2000,
    threshold     = 0.65
  ) %>%
  mutate_meta(~ {
    .x %>%
      mutate(cell_type = ifelse(frc_type == "PvC", frc_type, "FRC")) %>%
      dplyr::rename(frc_subtype = frc_type)
  })

# Add FRC subset to object
so_merge <- so_merge %>%
  AddMetaData(FetchData(so_frc, "frc_subtype")) %>%
  mutate_meta(
    mutate,
    cell_type = case_when(
      frc_subtype == "PvC" & !is.na(frc_subtype) ~ frc_subtype,
      !is.na(frc_subtype)                        ~ "FRC",
      TRUE                                       ~ cell_type
    ),
    frc_type    = ifelse(is.na(frc_subtype), cell_type, frc_subtype),
    frc_subtype = replace_na(frc_subtype, "other")
  )
```

```{r "lec subsets", eval = create_obj}
# Create LEC objects
# * merge 8hpi and 24hpi LECs and BECs, re-cluster
# * integrate replicates and integrate 24hpi CHIKV sample with all other samples
# * key issue with past attempts to perform integrated analysis is that
#   integration does not work well when BECs are excluded
so_lec <- so_merge %>%
  subset(cell_type %in% lec_cell_types) %>%
  FindVariableFeatures(nfeatures = 2000) %>%
  ScaleData() %>%
  RunPCA()

so_lec <- so_lec %>%
  RunHarmony(
    c("rep", "integration_var"),
    dims = 1:40, plot_convergence = TRUE
  ) %>%
  RunUMAP(
    dims = 1:40,
    reduction      = "harmony",
    reduction.name = "humap",
    reduction.key  = "hUMAP_"
  )

# Parameters to test
# get LEC annotations using 100 different settings
# vary clustering resolution and number of genes used for calculating
# correlations
resolutions <- seq(3, 15, 0.5)
n_genes     <- seq(500, 2000, 500)
met         <- "spearman"
bulk        <- "mean"
clst_params <- as.list(expand_grid(resolutions, n_genes, met, bulk))

so_lec <- so_lec %>%
  FindNeighbors(reduction = "harmony", dims = 1:40) %>%
  FindClusters(resolution = resolutions)

# Annotate LEC subsets for each set of parameters
# return data.frame with summary stats for each
cluster_param_results <- clst_params %>%
  pmap_dfr(~ {
    args  <- list(...)
    rsln  <- args$resolutions
    n_gns <- args$n_genes
    
    # Annotate cell types
    clmn <- str_c("RNA_snn_res.", rsln)
    
    typs <- so_lec %>%
      clustify(
        ref_mat           = ref_lec,
        cluster_col       = clmn,
        n_genes           = n_gns,
        threshold         = 0.55,
        compute_method    = args$met,
        pseudobulk_method = args$bulk
      )
    
    typs <- typs@meta.data %>%
      distinct(!!sym(clmn), type)
    
    typs <- set_names(typs$type, as.character(pull(typs, clmn)))
    
    so_lec <- so_lec %>%
      mutate_meta(mutate, type = typs[as.character(!!sym(clmn))])
    
    # Calculate stats
    res <- so_lec %>%
      FetchData(c("type", "tm", "treatment", "chikv_grp", "Marco", "Madcam1", clmn)) %>%
      as_tibble(rownames = ".cell_id")
    
    frac_few <- table(res[[clmn]])
    frac_few <- frac_few[frac_few < 100]
    n_few    <- sum(frac_few)
    frac_few <- n_few / nrow(res)
    
    typ <- res %>%
      group_by(tm, treatment, type) %>%
      summarize(n_type = n(), .groups = "drop") %>%
      group_by(tm, treatment) %>%
      mutate(frac_type = n_type / sum(n_type)) %>%
      ungroup()
    
    # Calculate fraction CHIKV-high cells for each cell type
    chikv <- res %>%
      filter(tm == "24hpi", treatment == "CHIKV", chikv_grp == "CHIKV-high") %>%
      group_by(type) %>%
      summarize(n_chikv = n(), .groups = "drop") %>%
      mutate(frac_chikv = n_chikv / sum(n_chikv)) %>%
      ungroup()
    
    # Identify cell types with highest Marco/Madcam1 expression
    marks <- res %>%
      group_by(tm, treatment, type) %>%
      summarize(
        across(c(Marco, Madcam1), mean, .names = "{.col}_mn"),
        across(c(Marco, Madcam1), median, .names = "{.col}_med"),
        .groups = "drop"
      ) %>%      
      group_by(tm, treatment) %>%
      summarize(
        across(
          matches("^(Marco|Madcam1)_(mn|med)$", ignore.case = FALSE),
          ~ type[.x == max(.x)]
        ),
        .groups = "drop"
      )

    # Format summary data.frame    
    res <- typ %>%
      full_join(chikv, by = "type") %>%
      full_join(marks, by = c("tm", "treatment")) %>%
      mutate(
        rsln     = clmn,
        n_genes  = args$n_genes,
        obj      = args$obj,
        type_key = list(typs),
        n_small_clusters    = n_few,
        frac_small_clusters = frac_few
      )
    
    res
  })
```

```{r "lec consensus annotations", eval = create_obj}
# Determine consensus annotations
# determine which cell type annotations are most consistent for each cell
ann_key <- cluster_param_results %>%
  distinct(type_key, rsln, n_genes) %>%
  mutate(id = row_number())

ann_df <- so_lec@meta.data %>%
  as_tibble(rownames = ".cell_id") %>%
  dplyr::select(
    .cell_id,
    starts_with("RNA_snn_res."), "tm", "orig.ident", "treatment", "lec_type"
  )

ann_key %>%
  pwalk(~ {
    args <- list(...)
    
    new_clmn <- str_c("type-", args$rsln, "-", args$n_genes)
    
    ann_df <<- ann_df %>%
      mutate(!!sym(new_clmn) := args$type_key[as.character(!!sym(args$rsln))])
  })

ann_stats <- ann_df %>%
  dplyr::select(.cell_id, starts_with("type-")) %>%
  pivot_longer(starts_with("type-")) %>%
  
  group_by(.cell_id) %>%
  summarize(
    count = list(table(value)),
    n = n(),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    top_ann  = names(head(sort(count, decreasing = TRUE), 1)),
    sec_ann  = names(tail(head(sort(count, decreasing = TRUE), 2), 1)),
    top_n    = max(count),
    top_frac = top_n / n,
    ann_n    = length(count)
  ) %>%
  ungroup()

top_typs <- set_names(ann_stats$top_ann, ann_stats$.cell_id)
sec_typs <- set_names(ann_stats$sec_ann, ann_stats$.cell_id)
top_frac <- set_names(ann_stats$top_frac, ann_stats$.cell_id)

so_lec <- so_lec %>%
  AddMetaData(top_typs, col.name = "top_type") %>%
  AddMetaData(sec_typs, col.name = "sec_type") %>%
  AddMetaData(top_frac, col.name = "top_frac")

# Cluster cell type annotations
# want to identify common annotation patterns
ann_mat <- ann_df %>%
  dplyr::select(.cell_id, starts_with("type-"))

ann_typs <- ann_mat %>%
  dplyr::select(starts_with("type-")) %>%
  as.matrix() %>%
  as.factor() %>%
  levels()

ann_mat <- ann_mat %>%
  mutate(across(starts_with("type-"), ~ as.numeric(factor(.x, ann_typs)))) %>%
  column_to_rownames(".cell_id") %>%
  as.matrix() %>%
  t()

set.seed(11)

ann_clsts <- kmeans(ann_mat, centers = 10)

ann_clst_res <- tibble(
  key     = names(ann_clsts$cluster),
  cluster = unname(ann_clsts$cluster)
) %>%
  separate(key, into = c("blank", "rsln", "n_genes"), sep = "-") %>%
  dplyr::select(-blank) %>%
  group_by(cluster) %>%
  mutate(n = n()) %>%
  dplyr::slice(1) %>%
  ungroup() %>%
  arrange(desc(n)) %>%
  mutate(rank = row_number())

# Plot representative settings for each cluster
ann_clst_plots <- ann_clst_res %>%
  pmap(~ {
    args <- list(...)
    
    so_lec %>%
      clustify(
        ref_mat     = ref_lec,
        cluster_col = args$rsln,
        n_genes     = args$n_genes,
        threshold   = 0.55
      ) %>%
      plot_scatter(
        "type",
        x = "hUMAP_1", 
        y = "hUMAP_2",
        size = 0.05,
        plot_colors = c(fLEC = "red", tzLEC = "black", Marco_LEC = "green")
      ) + 
      facet_grid(tm ~ treatment)
  })
```

```{r "lec refined annotations", eval = create_obj}
# Use representative settings identified from consensus annotations
lec_clst <- str_c("RNA_snn_res.", params$lec_res)

so_lec <- so_lec %>%
  mutate_meta(dplyr::select, -starts_with("UMAP_")) %>%
  clustify(
    ref_mat     = ref_lec,
    cluster_col = lec_clst,
    n_genes     = params$lec_n_genes,
    threshold   = 0.55
   )

# Adjust clusters based on Marco expression
so_lec <- so_lec %>%
  mutate_meta(mutate, lec_subtype = type) %>%
  classify_markers(
    feats    = "Marco",
    filt     = Marco > 0.6,
    type     = "Marco_LEC",
    clst_col = lec_clst,
    type_col = "lec_subtype"
  )

# Adjust unassigned clusters based on Pdpn and Pecam1 expression
so_lec <- so_lec %>%
  classify_markers(
    feats    = c("Pdpn", "Pecam1"),
    filt     = Pdpn < 0.1 & Pecam1 > 0.5,
    type     = "BEC",
    clst_col = lec_clst,
    type_col = "lec_subtype"
  )

# Add LEC subsets to object
# identify CHIKV-high subsets
so_merge <- so_merge %>%
  AddMetaData(FetchData(so_lec, "lec_subtype")) %>%
  mutate_meta(
    mutate,
    lec_type    = recode(lec_subtype, unassigned = "unassigned-LEC"),
    lec_type    = ifelse(is.na(lec_type), cell_type, lec_type),
    lec_subtype = replace_na(lec_subtype, "other"),
    
    chikv_type = if_else(chikv_grp == chikv_grps[2], lec_type, chikv_grp),
)

# Misc meta.data labels
so_merge <- so_merge %>%
  mutate_meta(
    mutate,
    cell_type_2 = case_when(                   # labels for LECs, BECs, and FRCs
      lec_type %in% c("BEC", "FRC") ~ lec_type,
      lec_type == "PvC"             ~ "FRC",
      cell_type %in% lec_cell_types ~ "LEC",
      TRUE                          ~ lec_type
    ),
    tm_treat = str_c(tm, "-", treatment)       # tm-treatment label for fig S3   
  ) %>%
  AddMetaData(FetchData(., c("hUMAP_1", "hUMAP_2")))

# Add meta.data labels to 8 and 24 hpi objects
clmns <- c(
  "cell_type", "cell_type_2", "tm_treat",
  "lec_type",  "lec_subtype",
  "frc_type",  "frc_subtype",
  "chikv_type"
)

type_dat <- FetchData(so_merge, clmns)
so_8     <- AddMetaData(so_8, type_dat)
so_24    <- AddMetaData(so_24, type_dat)
```

```{r "save objects", eval = create_obj}
save_objs(so_merge, ob_dir = params$so_dir)
save_objs(so_frc,   ob_dir = params$so_dir)
save_objs(so_lec,   ob_dir = params$so_dir)
save_objs(so_8,     ob_dir = params$so_dir)
save_objs(so_24,    ob_dir = params$so_dir)

rm(so_merge, so_frc, so_lec, so_8, so_24)
```

```{r "load objects"}
so_lec   <- qread(file.path(params$so_dir, "so_lec.qs"))
so_8     <- qread(file.path(params$so_dir, "so_8.qs"))
so_24    <- qread(file.path(params$so_dir, "so_24.qs"))

so_merge_df <- read_tsv(file.path(params$so_dir, "so_merge.tsv.gz"))
```

```{r "save matrices"}
geo_dir   <- here(params$geo_dir)
prfx      <- "morrison_"
geo_files <- here(geo_dir, str_c(prfx, "metadata.tsv.gz"))

if (any(!file.exists(geo_files))) {
  
  # Format meta.data
  so_merge <- qread(file.path(params$so_dir, "so_merge.qs"))
  
  u_clmns <- c("UMAP_1", "UMAP_2")
  
  so_merge <- so_merge %>%
    AddMetaData(FetchData(so_8, u_clmns), col.name = str_c(u_clmns, "_8h")) %>%
    AddMetaData(FetchData(so_24, u_clmns), col.name = str_c(u_clmns, "_24h"))
  
  # Write matrices and meta.data
  meta_cols <- c(
    "cell_id",      "orig.ident",
    "treatment",    "rep",
    "tm",
    "nCount_RNA",   "nFeature_RNA",
    "pct_mito",
    "nCount_CHIKV", "CHIKV_sgRNA",
    "CHIKV_5",      "pct_CHIKV",
    
    "enr_nCount_CHIKV", "enr_nCount_RNA",
    "enr_pct_CHIKV",
    
    "cell_type",    "lec_type",
    "chikv_grp",
    "UMAP_1",       "UMAP_2",
    "UMAP_1_8h",    "UMAP_2_8h",
    "UMAP_1_24h",   "UMAP_2_24h"
  )
  
  so_merge %>%
    export_matrices(
      assays      = c("RNA", "CHIKV"),
      columns     = meta_cols,
      out_dir     = geo_dir,
      file_prefix = prfx
    )
  
  rm(so_merge)
}

```

```{r "theme"}
# Set levels for samples and treatments
sam_lvls <- unique(so_24$orig.ident)
tms      <- unique(so_merge_df$tm)
treats   <- unique(treat_key)

# ggplot2 themes
txt_pt1  <- 10
txt_pt2  <- 12
ttl_pt1  <- 14
ttl_pt2  <- 16
ln_pt    <- 0.5
ln_col   <- "grey85"
cir_size <- 3.5
sqr_size <- 4

txt_theme_1 <- theme(
  strip.text   = element_text(size = ttl_pt2),
  legend.text  = element_text(size = txt_pt2),
  axis.title   = element_text(size = ttl_pt2),
  axis.text    = element_text(size = txt_pt2, color = "black"),
  legend.title = element_text(size = ttl_pt2),
)

line_theme <- theme(
  axis.line.x  = element_line(linewidth = ln_pt, color = ln_col),
  axis.line.y  = element_line(linewidth = ln_pt, color = ln_col),
  axis.ticks.x = element_line(linewidth = ln_pt, color = ln_col),
  axis.ticks.y = element_line(linewidth = ln_pt, color = ln_col)
)

base_theme <- djvdj_theme() +
  theme(
    plot.title       = element_text(face = "plain", size = ttl_pt2),
    strip.background = element_blank(),
    strip.text       = element_text(face = "plain")
  ) +
  txt_theme_1

umap_theme <- base_theme +
  theme(
    aspect.ratio = 0.9,
    panel.border = element_rect(color = NA, fill = NA),
    axis.title   = element_blank(),
    axis.line.x  = element_blank(),
    axis.line.y  = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text    = element_blank()
  )

fade_0 <- "#FAFAFA"
fade_1 <- "#F0F0F0"
fade_2 <- "#D9D9D9"

hist_y_lab <- "number of cells"

# alpha for plots
al <- 0.7

# Okabe Ito color palettes
ito_cols <- c(
  palette_OkabeIto[c(1:3, 5)], "#D7301F",
  palette_OkabeIto[c(4, 6)],   "#6A51A3",
  palette_OkabeIto[7],         "#875C04",
  "#065D43", "#F7AF34", "#00446E"
)

ito_cols <- ito_cols[3:length(ito_cols)] %>%
  darken(0.2) %>%
  c(ito_cols, ., "#686868", "#000000")

# Set sample colors
get_cols <- create_col_fun(ito_cols)

sam_cols <- c(
  "#BD0026", "#FECC5C", "#FFFFB2",
  "#00446E", "#035B8F", "#2A8FBF"
)

names(sam_cols) <- sam_lvls

# CHIKV treatment groups
chikv_infctd <- so_24@meta.data %>%
  group_by(treatment) %>%
  summarize(mn = mean(nCount_CHIKV), .groups = "drop") %>%
  filter(mn == max(mn)) %>%
  pull(treatment)

# LEC subset colors
subtype_cols <- c(colnames(ref_lec), colnames(ref_frc))
subtype_cols <- set_names(ito_cols[seq_along(subtype_cols)], subtype_cols)
subtype_cols["unassigned"] <- "#999999"
subtype_cols["other"]      <- fade_0
subtype_cols["CD34+ SC"]   <- "#534379"

lec_type_cols <- so_24$lec_type %>%
  table() %>%
  sort(decreasing = TRUE) %>%
  names()

lec_type_cols <- lec_type_cols[lec_type_cols != "unassigned"]

lec_type_cols <- set_names(
  ito_cols[seq_along(lec_type_cols)],
  lec_type_cols
)

lec_type_cols["unassigned"] <- "grey70"
lec_type_cols["other"]      <- "grey50"

old_cols <- lec_type_cols

lec_type_cols["FRC"]            <- old_cols["Valve"]
lec_type_cols["Valve"]          <- old_cols["fLEC"]
lec_type_cols["fLEC"]           <- old_cols["FRC"]
lec_type_cols["tzLEC"]          <- "black"
lec_type_cols["BEC"]            <- old_cols["unassigned-LEC"]
lec_type_cols["unassigned-LEC"] <- old_cols["BEC"]
lec_type_cols["Marco_LEC"]      <- old_cols["T cells"]
lec_type_cols["T cells"]        <- old_cols["Marco_LEC"]

# Cell type colors
type_cols <- unique(so_24$cell_type)
type_cols <- set_names(ito_cols[seq_along(type_cols)], type_cols)

type_cols["unassigned"] <- "#999999"

type_cols_2        <- lec_type_cols
type_cols_2["LEC"] <- lec_type_cols["Marco_LEC"]

# CHIKV clusters colors
grp_cols <- set_names(
  c("#56B4E9", "#0072B2"),
  chikv_grps
)

n_reps <- n_distinct(so_24$rep)

grp_rep_cols <- grp_cols %>% 
  imap(~ set_names(
    rep(.x, n_reps),
    str_c(.y, "-", 1:n_reps)
  )) %>%
  flatten_chr()

# Vectors to modify cell type labels for plotting
new_cell_labs <- c(
  Valve      = "Valve LEC",
  Collecting = "Collecting LEC",
  Ptx3_LEC   = "Ptx3 LEC"
)

marco_expr <- c(Marco_LEC = "\"Marco\"^\"+\"*\" LEC\"")
```
