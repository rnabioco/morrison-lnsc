---
title:  "CHIKV scRNA-seq"
author: "Ryan Sheridan"
date:   "`r Sys.Date()`"
output: 
  html_document:
    toc:       true
    toc_float: true
    toc_depth: 3
    theme:     cosmo
    highlight: kate
    
params:
  res_dir:      "results/2021-04-16"  # Directory containing matrices
  template_dir: "src"                 # Directory containing Rmd templates
  table_dir:    "tables"              # Directory to write tables
  so_dir:       "sobjs"               # Directory to write Seurat objects
  metrics:      "count_metrics.csv"   # Cell Ranger metrics
  so:           "so.rds"              # Seurat object for filtered cells
  so_raw:       "so_raw.rds"          # Seurat object for unfiltered cells
  so_lec:       "so_lec.rds"          # Seurat object for LECs
  so_fib:       "so_fib.rds"          # Seurat object for fibroblasts
  so_infd:      "so_infd.rds"         # Seurat object for fibroblasts
  so_chikv:     "so_chikv.rds"        # Seurat object for CHIKV-high cells
  gene_min:     250                   # Min number of detected genes per cell
  gene_max:     6000                  # Max number of detected genes per cell
  mito_max:     20                    # Max percentage mito reads per cells
  type_res:     5                     # Clustering resolution for annotating cell types
  lec_res:      5                     # Clustering resolution for annotating LECs
  fib_res:      5                     # Clustering resolution for annotating fibroblasts/stromal cells
  chikv_lim:    5                     # CHIKV read cutoff to include cell for CHIKV clustering
  tm:           "8hpi"                # Hours post infection
                                      # Other timepoints to merge
  other_tms:
    value:
      24hpi: "results/2021-01-08" 
      
  samples:
    - "M1"
    - "M2"
    - "AF1"
    - "AF2"
---

<br>

```{r "chunk opts", echo = F}

# Default chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo    = FALSE
)

```

`r knitr::knit_child(here::here(params$res_dir, "setup.Rmd"))`

```{r "theme"}

# ggplot2 themes
txt_pt1  <- 10
txt_pt2  <- 12
ttl_pt1  <- 14
ttl_pt2  <- 16
ln_pt    <- 0.5
ln_col   <- "grey85"
cir_size <- 3.5
sqr_size <- 4

txt_theme_1 <- theme(
  strip.text  = element_text(size = ttl_pt1),
  legend.text = element_text(size = txt_pt1),
  axis.title  = element_text(size = txt_pt2),
  axis.text   = element_text(size = txt_pt1)
)

line_theme <- theme(
  axis.line.x  = element_line(size = ln_pt, color = ln_col),
  axis.line.y  = element_line(size = ln_pt, color = ln_col),
  axis.ticks.x = element_line(size = ln_pt, color = ln_col),
  axis.ticks.y = element_line(size = ln_pt, color = ln_col)
)

base_theme <- theme_cowplot() +
  theme(
    plot.title       = element_text(face = "plain", size = ttl_pt2),
    strip.background = element_blank(),
    strip.text       = element_text(face = "plain")
  ) +
  txt_theme_1 +
  line_theme

umap_theme <- base_theme +
  theme(
    axis.title   = element_blank(),
    axis.line.x  = element_blank(),
    axis.line.y  = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text    = element_blank()
  )

fade_0 <- "#FAFAFA"
fade_1 <- "#F0F0F0"
fade_2 <- "#D9D9D9"

hist_y_lab <- "number of cells"

# alpha for plots
al <- 0.7

# Okabe Ito color palettes
ito_cols <- c(
  palette_OkabeIto[c(1:3, 5)], "#D7301F",
  palette_OkabeIto[c(4, 6)],   "#6A51A3",
  palette_OkabeIto[7],         "#875C04",
  "#065D43", "#F7AF34", "#00446E"
)

ito_cols <- ito_cols[3:length(ito_cols)] %>%
  darken(0.2) %>%
  c(ito_cols, ., "#686868", "#000000")

# Set sample colors
get_cols <- create_col_fun(ito_cols)

sam_cols <- c(
  "#0072B2", "#56B4E9", "#00446E", "#035B8F", "#2A8FBF",
  "#F03B20", "#FD8D3C", "#BD0026", "#FECC5C", "#FFFFB2"
)

names(sam_cols) <- merge_lvls

# CHIKV treatment groups
chikv_infctd <- so_merge_df %>%
  group_by(treatment) %>%
  summarize(mn = mean(nCount_CHIKV), .groups = "drop") %>%
  filter(mn == max(mn)) %>%
  pull(treatment)

# Cell type colors
type_cols <- unique(so_df$cell_type)
type_cols <- set_names(ito_cols[seq_along(type_cols)], type_cols)

type_cols["unassigned"] <- "#999999"

subtype_cols <- c(colnames(ref_lec), colnames(ref_fib))
subtype_cols <- set_names(ito_cols[seq_along(subtype_cols)], subtype_cols)
subtype_cols["unassigned"] <- "#999999"
subtype_cols["other"]      <- fade_0

# CHIKV clusters colors
grp_cols <- set_names(
  c("#56B4E9", "#0072B2"),
  chikv_grps
)

n_reps <- 3

grp_rep_cols <- grp_cols %>% 
  imap(~ set_names(
    rep(.x, n_reps),
    str_c(.y, "-", 1:n_reps)
  )) %>%
  flatten_chr()

# Treatment groups
treats <- unique(treats)

```

```{r "qc"}

qc_desc <- "The cutoff used by cellranger to identify cell-associated barcodes did not appear as accurate for sample AF2. To account for this AF2 cells were initially filtered to remove cells with <800 UMIs."

qc_chunks <- knit_expand(
  file      = here(params$template_dir, "qc_template.Rmd"),
  desc      = "qc_desc",
  qc_meta   = "so_raw_df",  # meta.data for unfiltered sobj
  filt_meta = "so_df"       # Filtered meta.data to use for UMAPs
)

```

`r knit_child(text = qc_chunks)`

##

After filtering cells, the raw counts for each gene were divided by the total counts for the cell, multiplied by a scaling factor (10,000), and log-transformed (`NormalizeData`). The top 2000 genes that show the most cell-to-cell variation were then identified (`FindVariableFeatures`) and the data were scaled to prevent highly expressed genes from biasing the downstream analysis (`ScaleData`). For clustering and visualizing differences between cells, PCA and UMAP were used to reduce the dimensionality of the dataset (`RunPCA`, `RunUMAP`).

UMAP projections are shown below with cells colored by sample ID, the mock- and CHIKV-infected samples show strong overlap.

```{r "sam umaps 1", fig.width = 15.5, fig.height = 13.5}

# Sample UMAPs
sam_labs <- get_nlab_fun(so_df, "sample")
tot_lab  <- get_nlab_fun(so_df)

rep_umap <- so_df %>%
  mutate(sample = fct_relevel(sample, sam_lvls)) %>%
  plot_features(
    feature     = "sample",
    pt_size     = 0.75,
    feat_levels = names(sam_cols)
  ) +
  
  guides(color = guide_legend(override.aes = list(size = 4.5))) +
  scale_color_manual(values = sam_cols, labels = sam_labs) +
  umap_theme +
  theme(
    legend.key.height = unit(45, "pt"),
    legend.title      = element_blank(),
    legend.text       = element_text(size = txt_pt1 * 1.5)
  )

sam_umap <- rep_umap +
  geom_text(
    aes(Inf, Inf),
    label         = tot_lab,
    check_overlap = TRUE,
    color         = "black",
    hjust         = 1,
    vjust         = 1,
    size          = (txt_pt1 / .pt) * 1.5
  )

sam_umap

```

UMAP projections are shown for cells divided by replicate, colors correspond to sample ID as shown above. The biological replicates show strong overlap and very similar overall structure, suggesting that batch effects are not impacting gene expression patterns. 

```{r "sam umaps 2", fig.width = 15, fig.height = 4}

sam_labs <- get_nlab_fun(so_df, "sample", nm = FALSE)

sam_labs_df <- sam_labs() %>%
  tibble(sample = names(.), n = .) %>%
  mutate(sample = fct_relevel(sample, sam_lvls))

rep_umap <- rep_umap +
  facet_wrap(~ sample, nrow = 1) +
  
  geom_text(
    aes(Inf, Inf, label = n),
    data          = sam_labs_df,
    check_overlap = TRUE,
    color         = "black",
    hjust         = 1,
    vjust         = 1,
    size          = (txt_pt1 / .pt)
  ) +
  
  scale_color_manual(values = sam_cols, labels = sam_labs) +
  theme(
    legend.key.height = unit(20, "pt"),
    legend.position   = "none",
    legend.text       = element_text(size = txt_pt1),
    strip.text        = element_text(size = ttl_pt1)
  )

rep_umap

```

<br>

UMAP projection shows 8 hpi and 24 hpi samples with cells colored by sample ID.

```{r "merged umaps 1", fig.width = 15.5, fig.height = 13.5}

# Sample UMAPs
sam_labs <- get_nlab_fun(so_merge_df, "sample")
tot_lab  <- get_nlab_fun(so_merge_df)

rep_umap <- so_merge_df %>%
  mutate(sample = fct_relevel(sample, merge_lvls)) %>%
  plot_features(
    feature     = "sample",
    pt_size     = 0.1,
    feat_levels = names(sam_cols)
  ) +
  
  guides(color = guide_legend(override.aes = list(size = 4.5))) +
  scale_color_manual(values = sam_cols, labels = sam_labs) +
  umap_theme +
  theme(
    legend.key.height = unit(45, "pt"),
    legend.title      = element_blank(),
    legend.text       = element_text(size = txt_pt1 * 1.5)
  )

rep_umap +
  geom_text(
    aes(Inf, Inf),
    label         = tot_lab,
    check_overlap = TRUE,
    color         = "black",
    hjust         = 1,
    vjust         = 1,
    size          = (txt_pt1 / .pt) * 1.5
  )

```

<br>

UMAP projection shows 8 hpi and 24 hpi samples with cells colored by sample ID. Cells from the 24 hpi samples are shown in grey.

```{r "merged umaps 2", fig.width = 15.5, fig.height = 13.5}

# Sample UMAPs
dat <- so_merge_df %>%
  mutate(
    sample = if_else(sample %in% sam_lvls, sample, "other"),
    sample = fct_relevel(sample, c("other", sam_lvls))
  )

sam_cols["other"] <- "grey85"

sam_labs <- get_nlab_fun(dat, "sample")
tot_lab  <- get_nlab_fun(dat)

rep_umap <- dat %>%
  plot_features(
    feature     = "sample",
    pt_size     = 0.1,
    feat_levels = names(sam_cols)
  ) +
  
  guides(color = guide_legend(override.aes = list(size = 4.5))) +
  scale_color_manual(values = sam_cols, labels = sam_labs) +
  umap_theme +
  theme(
    legend.key.height = unit(45, "pt"),
    legend.title      = element_blank(),
    legend.text       = element_text(size = txt_pt1 * 1.5)
  )

rep_umap +
  geom_text(
    aes(Inf, Inf),
    label         = tot_lab,
    check_overlap = TRUE,
    color         = "black",
    hjust         = 1,
    vjust         = 1,
    size          = (txt_pt1 / .pt) * 1.5
  )

```

UMAP projections are shown for 8 hpi cells divided by sample ID, 24 hpi cells are shown in grey.

```{r "merged umaps 3", fig.width = 15, fig.height = 4}

sam_labs <- get_nlab_fun(dat, "sample", nm = FALSE)

sam_labs_df <- sam_labs() %>%
  tibble(sam_grp = names(.), n = .) %>%
  filter(sam_grp != "other") %>%
  mutate(sam_grp = fct_relevel(sam_grp, sam_lvls))

dat <- sam_lvls %>%
  map_dfr(~ {
    dat %>%
      filter(sample %in% c("other", .x)) %>%
      mutate(sam_grp = .x)
  }) %>%
  mutate(sam_grp = fct_relevel(sam_grp, sam_lvls))

dat %>%
  plot_features(
    feature = "sample",
    pt_size = 0.1
  ) +
  guides(color = guide_legend(override.aes = list(size = 4.5))) +
  scale_color_manual(values = sam_cols, labels = sam_labs) +
  umap_theme +
  theme(
    legend.key.height = unit(45, "pt"),
    legend.title      = element_blank(),
    legend.text       = element_text(size = txt_pt1 * 1.5)
  ) +
  facet_wrap(~ sam_grp, nrow = 1) +
  
  geom_text(
    aes(Inf, Inf, label = n),
    data          = sam_labs_df,
    check_overlap = TRUE,
    color         = "black",
    hjust         = 1,
    vjust         = 1,
    size          = (txt_pt1 / .pt)
  ) +
  
  scale_color_manual(values = sam_cols, labels = sam_labs) +
  theme(
    legend.key.height = unit(20, "pt"),
    legend.position   = "none",
    legend.text       = element_text(size = txt_pt1),
    strip.text        = element_text(size = ttl_pt1)
  )

```

---

<br>

<br>

## Cell type annotation

To identify cell clusters, a k-nearest neighbors graph was generated using the first 40 principal components (`FindNeighbors`). This graph was then used to iteratively group cells together using the Louvain method (`FindClusters`).

Broad cell types were first assigned by comparing gene expression patterns for each cluster with data available from Immgen (`clustify`). UMAPs below show cell type annotations for different clustering resolutions, the number of distinct clusters is shown in parenthesis.

```{r "type clusts", fig.width = 13, fig.height = 10.5}

# Columns to plot
c_clmns <- type_clsts %>%
  map_chr(pluck, 1) %>%
  unname()

t_clmns <- type_clsts %>%
  map_chr(pluck, 2) %>%
  str_c("_type")

r_clmns <- type_clsts %>%
  map_chr(pluck, 2) %>%
  str_c("_r")

# Create UMAPs
so %>%
  plot_clust_rslns(
    c_clmns = c_clmns,
    t_clmns = t_clmns,
    r_clmns = r_clmns
  )

```

<br>

UMAP projections are shown for the selected cell type annotations (clustering resolution `r params$type_res`) with cells colored by type. The fraction of cells belonging to each type is shown on the right.

```{r "cell types", fig.width = 10, fig.height = 6}

so_df %>%
  create_umap_bars(
    fill      = "cell_type",
    grps      = "sample",
    filt      = nCount_RNA > -1,
    plot_clrs = type_cols,
    list_out  = FALSE,
    flip_bars = FALSE
  )

```

---

<br>

<br>

## Cell type markers

```{r "cell type marker chunks"}

m_chunks <- knit_expand(
  file     = here(params$template_dir, "marker_template.Rmd"),
  so_in    = "so",         # Seurat object
  clmn     = "cell_type",  # Column containing cell types
  box_cols = "type_cols",  # Colors to use for boxplots
  prefix   = NULL          # Prefix for file names
)

```

`r knit_child(text = m_chunks)`

## LEC subtypes

To classify LEC subtypes, cells were filtered to only include LECs and re-clustered. UMAPs are shown on the left with cells colored by sample ID. UMAPs shown on the right are colored by sample ID and divided by replicate ID.

```{r "lec samples", fig.width = 9.5, fig.height = 6}

# Create LEC UMAP
sam_labs <- get_nlab_fun(so_lec_df, "sample", sep = " ")
tot_lab  <- get_nlab_fun(so_lec_df)

lec_umap <- so_lec_df %>%
  plot_features(
    feature     = "sample",
    pt_size     = 0.01,
    plot_colors = sam_cols,
    feat_levels = names(sam_cols)
  ) +
  
  scale_color_manual(values = sam_cols, labels = sam_labs) +
  
  guides(color = guide_legend(override.aes = list(size = 3), nrow = 2)) +
  
  umap_theme +
  theme(
    legend.position = "bottom",
    legend.title    = element_blank()
  )

lec_umap_1 <- lec_umap +
  geom_text(
    aes(Inf, Inf),
    label         = tot_lab,
    check_overlap = TRUE,
    color         = "black",
    hjust         = 1,
    vjust         = 1,
    size          = txt_pt1 / .pt
  )

# Create UMAP split by replicate
lec_umap_2 <- lec_umap +
  facet_wrap(~ rep, ncol = 1) +
  theme(
    legend.position  = "none",
    panel.background = element_rect(color = fade_1, fill = NA, size = 0.5)
  )

# Create final figure
plot_grid(
  lec_umap_1, lec_umap_2,
  rel_widths = c(1, 0.42),
  align      = "h",
  axis       = "tb"
)

```

<br>

LEC subtypes were assigned using gene expression data for LEC subsets identified previously [Xiang et al.](https://pubmed.ncbi.nlm.nih.gov/32426372/). UMAPs below show LEC subtype annotations for different clustering resolutions, the number of distinct clusters is shown in parenthesis.

```{r "lec clusts", fig.width = 11, fig.height = 10}

# Columns to plot
c_clmns <- lec_clsts %>%
  map_chr(pluck, 1) %>%
  unname()

t_clmns <- lec_clsts %>%
  map_chr(pluck, 2) %>%
  str_c("_type")

r_clmns <- lec_clsts %>%
  map_chr(pluck, 2) %>%
  str_c("_r")

# Create UMAPs
so_lec %>%
  plot_clust_rslns(
    c_clmns = c_clmns,
    t_clmns = t_clmns,
    r_clmns = r_clmns,
    c_cols  = get_cols(85),
    t_cols  = subtype_cols
  )

```

<br>

UMAP projections are shown for the selected LEC annotations (clustering resolution `r params$lec_res`) with cells colored by subtype, cells that are not LECs are shown in light grey. The fraction of cells belonging to each subtype is shown on the right. 

```{r "lec types", fig.width = 10, fig.height = 6}

so_df %>%
  create_umap_bars(
    fill       = "lec_subtype",
    grps       = "sample",
    filt       = cell_type %in% lec_cell_types,
    plot_clrs  = subtype_cols,
    list_out   = FALSE,
    flip_bars  = FALSE,
    size       = 0.3,
    pt_outline = 0.1
  )

```

<br>

To assess the accuracy of LEC annotations, the subtype assignments were compared back to the reference data ("ref_type"). The correlation with the reference datasets is shown below. 

```{r "lec heatmap", fig.width = 12, fig.height = 5}

# Format data for heatmap for each treatment group
h_mat <- treats %>%
  map_dfr(~ {
    so_lec %>%
      subset(subset = treatment == .x) %>%
      clustify(
        ref_mat     = ref_lec,
        cluster_col = "lec_type",
        seurat_out  = FALSE
      ) %>%
      as_tibble(rownames = "assigned_type") %>%
      pivot_longer(
        cols      = -assigned_type,
        names_to  = "ref_type",
        values_to = "r"
      ) %>%
      mutate(treatment = .x)
  }) %>%
  mutate(treatment = fct_relevel(treatment, treats))

# Create subtype heatmaps for each treatment group
h_mat %>%
  ggplot(aes(ref_type, assigned_type, fill = r)) +
  geom_tile(color = fade_0, size = 0.2) +
  
  geom_text(
    aes(label = round(r, 2)),
    data  = filter(h_mat, assigned_type == ref_type),
    color = "white",
    size  = txt_pt1 / .pt
  ) +
  
  facet_wrap(~ treatment, nrow = 1) +
  
  guides(fill = bar_gd()) +
  scale_fill_gradientn(colors = c(fade_0, "#E69F00")) +
  base_theme +
  theme(
    axis.line.x = element_blank(),
    axis.line.y = element_blank(),
    axis.text.x = element_text(hjust = 1, angle = 45)
  )

```

---

<br>

<br>

## LEC markers

UMAP projection shows Marco expression.

```{r "marco umap", fig.width = 12, fig.height = 10}

marco_df <- so %>%
  FetchData(c("nCount_CHIKV", "Marco", "UMAP_1", "UMAP_2"))

# Create UMAP of CHIKV counts
tot_lab <- get_nlab_fun(marco_df)

marco_df %>%
  plot_features(
    feature     = "Marco",
    pt_size     = 0.7,
    pt_outline  = 0.1,
    plot_colors = c(fade_0, "#D7301F")
  ) +
  
  geom_text(
    aes(Inf, Inf),
    label         = tot_lab,
    check_overlap = TRUE,
    color         = "black",
    hjust         = 1,
    vjust         = 1,
    size          = txt_pt1 / .pt
  ) +
  
  guides(color = bar_gd(direction   = "horizontal")) +
  umap_theme

```

<br>

```{r "lec marker chunks"}

m_chunks <- knit_expand(
  file     = here(params$template_dir, "marker_template.Rmd"),
  so_in    = "so_lec",        # Seurat object
  clmn     = "lec_type",      # Column containing cell types
  box_cols = "subtype_cols",  # Colors to use for boxplots 
  prefix   = "lec"            # Prefix for file names
)

```

`r knit_child(text = m_chunks)`

```{r "cLEC UMAP", fig.width = 12, fig.height = 10, eval = F}

# cLEC CHIKV markers
clec_marks <- read_tsv(here("results/2021-04-16/tables/A-M_lec_cLEC_markers.tsv")) %>%
  pull(gene)

# Data for plotting
clec_dat <- so %>%
  FetchData(c("lec_subtype", "treatment", "UMAP_1", "UMAP_2", clec_marks)) %>%
  mutate(
    clec_type = if_else(lec_subtype == "cLEC", lec_subtype, "other"),
    clec_type = if_else(clec_type == "cLEC", str_c(clec_type, "-", treatment), clec_type)
  )

clec_labs <- get_nlab_fun(clec_dat, "clec_type")

clec_cols <- c(
  "other"      = "grey70",
  "cLEC-mock"  = "#56B4E9",
  "cLEC-CHIKV" = "#D7301F"
)

# cLEC UMAP
clec_dat %>%
  mutate(clec_type = fct_relevel(clec_type, names(clec_cols))) %>%
  arrange(clec_type) %>%
  ggplot(aes(UMAP_1, UMAP_2, color = clec_type)) +
  geom_point() +
  umap_theme +
  scale_color_manual(values = clec_cols, labels = clec_labs)

# Marker UMAPs
# clec_marks %>%
#   map(~ {
#     clec_dat %>%
#       plot_features(
#         feature = .x,
#         pt_size = 0.1,plot_colors = c("#f0f0f0", "red")
#       ) +
#       umap_theme
#   }) %>%
#   plot_grid(
#     plotlist = .,
#     align    = "vh",
#     axis     = "trbl"
#   )

```

## Non-endothelial SC subtypes

To classify non-endothelial SC subtypes, cells were filtered to only include stromal cells and re-clustered. UMAPs are shown on the left with cells colored by sample ID. UMAPs shown on the right are colored by sample ID and divided by replicate ID.

```{r "fib samples", fig.width = 9.5, fig.height = 6}

# Create LEC UMAP
sam_labs <- get_nlab_fun(so_fib_df, "sample", sep = " ")
tot_lab  <- get_nlab_fun(so_fib_df)

fib_umap <- so_fib_df %>%
  plot_features(
    feature     = "sample",
    pt_size     = 0.01,
    plot_colors = sam_cols,
    feat_levels = names(sam_cols)
  ) +
  
  scale_color_manual(values = sam_cols, labels = sam_labs) +
  
  guides(color = guide_legend(override.aes = list(size = 3), nrow = 2)) +
  
  umap_theme +
  theme(
    legend.position = "bottom",
    legend.title    = element_blank()
  )

fib_umap_1 <- fib_umap +
  geom_text(
    aes(Inf, Inf),
    label         = tot_lab,
    check_overlap = TRUE,
    color         = "black",
    hjust         = 1,
    vjust         = 1,
    size          = txt_pt1 / .pt
  )

# Create UMAP split by replicate
fib_umap_2 <- fib_umap +
  facet_wrap(~ rep, ncol = 1) +
  theme(
    legend.position  = "none",
    panel.background = element_rect(color = fade_1, fill = NA, size = 0.5)
  )

# Create final figure
plot_grid(
  fib_umap_1, fib_umap_2,
  rel_widths = c(1, 0.42),
  align      = "h",
  axis       = "tb"
)

```

<br>

Non-endothelial SC subsets were assigned using gene expression data published previously [Rodda et al.](https://pubmed.ncbi.nlm.nih.gov/29752062/). UMAPs below show annotations for different clustering resolutions, the number of distinct clusters is shown in parenthesis.

```{r "fib clusts", fig.width = 11, fig.height = 10}

# Columns to plot
c_clmns <- fib_clsts %>%
  map_chr(pluck, 1) %>%
  unname()

t_clmns <- fib_clsts %>%
  map_chr(pluck, 2) %>%
  str_c("_type")

r_clmns <- fib_clsts %>%
  map_chr(pluck, 2) %>%
  str_c("_r")

# Create UMAPs
so_fib %>%
  plot_clust_rslns(
    c_clmns = c_clmns,
    t_clmns = t_clmns,
    r_clmns = r_clmns,
    c_cols  = get_cols(85),
    t_cols  = subtype_cols
  )

```

<br>

UMAP projections are shown for the selected non-endothelial SC annotations (clustering resolution `r params$fib_res`) with cells colored by subtype, other cells are shown in light grey. The fraction of cells belonging to each subtype is shown on the right. 

```{r "fib types", fig.width = 10, fig.height = 6}

so_df %>%
  create_umap_bars(
    fill        = "fib_subtype",
    grps        = "sample",
    filt        = cell_type %in% fib_cell_types,
    plot_clrs   = subtype_cols,
    list_out    = FALSE,
    flip_bars   = FALSE,
    size        = 0.3,
    pt_outline  = 0.1
  )

```

<br>

To assess the accuracy of these cell annotations, the subtype assignments were compared back to the reference data ("ref_type"). The correlation with the reference datasets is shown below. 

```{r "fib type heatmap", fig.width = 12, fig.height = 5}

# Format data for heatmap for each treatment group
h_mat <- treats %>%
  map_dfr(~ {
    so_fib %>%
      subset(subset = treatment == .x) %>%
      clustify(
        ref_mat     = ref_lymphnodestromal,
        cluster_col = "fib_type",
        seurat_out  = FALSE
      ) %>%
      as_tibble(rownames = "assigned_type") %>%
      pivot_longer(
        cols      = -assigned_type,
        names_to  = "ref_type",
        values_to = "r"
      ) %>%
      mutate(treatment = .x)
  }) %>%
  mutate(treatment = fct_relevel(treatment, treats))

# Create subtype heatmaps for each treatment group
h_mat %>%
  ggplot(aes(ref_type, assigned_type, fill = r)) +
  geom_tile(color = fade_0, size = 0.2) +
  
  geom_text(
    aes(label = round(r, 2)),
    data  = filter(h_mat, assigned_type == ref_type),
    color = "white",
    size  = txt_pt1 / .pt
  ) +
  
  facet_wrap(~ treatment, nrow = 1) +
  
  guides(fill = bar_gd()) +
  scale_fill_gradientn(colors = c(fade_0, "#035B8F")) +
  base_theme +
  theme(
    axis.line.x = element_blank(),
    axis.line.y = element_blank(),
    axis.text.x = element_text(hjust = 1, angle = 45)
  )

```

---

<br>

<br>

## Non-endothelial SC markers

```{r "fib marker chunks"}

m_chunks <- knit_expand(
  file     = here(params$template_dir, "marker_template.Rmd"),
  so_in    = "so_fib",       # Seurat object
  clmn     = "fib_type",     # Column containing cell types
  box_cols = "subtype_cols", # Colors to use for boxplots 
  prefix   = "fib"           # Prefix for file names
)

```

`r knit_child(text = m_chunks)`

```{r "PvC CD34+ UMAPs", fig.width = 14, fig.height = 7, eval = F}

# Data for plotting
dat <- so %>%
  FetchData(c("fib_subtype", "treatment", "UMAP_1", "UMAP_2")) %>%
  mutate(
    cd34_type = if_else(fib_subtype == "CD34+ SC", fib_subtype, "other"),
    cd34_type = if_else(cd34_type == "CD34+ SC", str_c(cd34_type, "-", treatment), cd34_type)
  ) %>%
  mutate(
    pvc_type = if_else(fib_subtype == "PvC", fib_subtype, "other"),
    pvc_type = if_else(pvc_type == "PvC", str_c(pvc_type, "-", treatment), pvc_type)
  )

clmns <- c(
  "cd34_type" = "CD34+ SC",
  "pvc_type"  = "PvC"
)

clmns %>%
  imap(~ {
    plt_labs <- get_nlab_fun(dat, .y, sep = "     ")
    
    plt_cols <- str_c(.x, "-", c("mock", "CHIKV"))
    plt_cols <- c("other", plt_cols)
    
    plt_cols <- set_names(
      c("grey70", "#56B4E9", "#D7301F"),
      plt_cols
    )
    
    dat %>%
      mutate(!!sym(.y) := fct_relevel(!!sym(.y), names(plt_cols))) %>%
      arrange(!!sym(.y)) %>%
      
      plot_features(
        feature = .y,
        pt_size = 0.7
      ) +
      scale_color_manual(values = plt_cols, labels = plt_labs) +
      ggtitle(.x) +
      guides(color = guide_legend(ncol = 1, override.aes = list(size = 4))) +
      umap_theme +
      theme(
        plot.title      = element_text(size = 24),
        legend.position = "bottom",
        legend.title    = element_blank(),
        panel.border    = element_rect(fill = NA, color = "grey85"),
        legend.text     = element_text(size = 20)
      )
  }) %>%
  plot_grid(
    plotlist = .,
    align = "vh",
    axis  = "trbl"
  )

```

## CHIKV RNA

To identify cells containing CHIKV RNA, reads were aligned to an mm10 reference containing the CHIKV genome. Viral counts are shown below on a UMAP projection.

```{r "chikv umap", fig.width = 12, fig.height = 10}

# Create UMAP of CHIKV counts
tot_lab <- get_nlab_fun(so_df)

so_df %>%
  mutate(nCount_CHIKV = nCount_CHIKV + 1) %>%
  plot_features(
    feature     = "nCount_CHIKV",
    pt_size     = 0.7,
    pt_outline  = 0.1,
    plot_colors = c(fade_0, "#D7301F")
    # max_q       = 99.99
  ) +
  
  geom_text(
    aes(Inf, Inf),
    label         = tot_lab,
    check_overlap = TRUE,
    color         = "black",
    hjust         = 1,
    vjust         = 1,
    size          = txt_pt1 / .pt
  ) +
  
  guides(color = bar_gd(direction   = "horizontal")) +
  scale_color_gradientn(colours = c(fade_0, "#D7301F"), trans = "log10") +
  umap_theme

n_chikv <- so_df %>%
  filter(nCount_CHIKV > params$chikv_lim) %>%
  pull(cell_id) %>%
  n_distinct()

```

<br>

To identify cells with high amounts of viral RNA, cells were first filtered to only include those with >`r params$chikv_lim` CHIKV counts (`r format(n_chikv, big.mark = ",", scientific = FALSE)` cells). K-means clustering was then used to divide each sample into CHIKV low and high populations. CHIKV counts are shown below for each sample. Cells are colored by the CHIKV low/high groupings.

```{r "chikv clust hist", fig.width = 12, fig.height = 3.5}

# Histogram data
sam_labs <- get_nlab_fun(so_df, "sample", nm = FALSE)
grp_labs <- get_nlab_fun(so_df, "chikv_grp", sep = " ")

# Create histograms for CHIKV counts
so_df %>%
  mutate(
    n      = sam_labs(sample),
    sample = fct_relevel(sample, sam_lvls)
  ) %>%
  ggplot(aes(nCount_CHIKV + 1, ..count.. + 1, fill = chikv_grp)) +
  geom_histogram(bins = 35, alpha = 0.8) +
  
  geom_text(
    aes(Inf, Inf, label = n),
    check_overlap = TRUE,
    color         = "black",
    hjust         = 1.2,
    vjust         = 1.5,
    size          = txt_pt1 / .pt
  ) +
  
  facet_wrap(~ sample, nrow = 1) +
  scale_x_log10(labels = trans_format("log10", math_format(10^.x))) +
  scale_y_log10(labels = trans_format("log10", math_format(10^.x))) +
  
  scale_fill_manual(values = grp_cols, labels = grp_labs) +
  
  labs(x = "CHIKV counts + 1", y = str_c(hist_y_lab, " + 1")) +
  guides(fill = guide_legend(nrow = 2)) +
  base_theme +
  theme(
    legend.position = "top",
    legend.title    = element_blank(),
    axis.line       = element_blank(),
    panel.border    = element_rect(fill = NA, color = "grey85")
  )

```

<br>

